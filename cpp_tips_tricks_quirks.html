<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C++ tips, tricks and quirks.</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">C++ tips, tricks and quirks.</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#pitfall-of-for-const-pairk-v-kv-my_map"
id="toc-pitfall-of-for-const-pairk-v-kv-my_map"><span
class="toc-section-number">1</span> pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></a></li>
<li><a href="#declare-function-with-typedefusing"
id="toc-declare-function-with-typedefusing"><span
class="toc-section-number">2</span> declare function with
typedef/using</a></li>
<li><a href="#protectedprivate-virtual-functions-override"
id="toc-protectedprivate-virtual-functions-override"><span
class="toc-section-number">3</span> protected/private virtual functions
override</a></li>
<li><a href="#function-try-block" id="toc-function-try-block"><span
class="toc-section-number">4</span> function try block</a></li>
<li><a href="#omiting-public-when-deriving"
id="toc-omiting-public-when-deriving"><span
class="toc-section-number">5</span> omiting <code>public</code> when
deriving</a></li>
<li><a href="#void0-to-force-for-macros"
id="toc-void0-to-force-for-macros"><span
class="toc-section-number">6</span> <code>(void)0</code> to force
<code>;</code> for macros</a></li>
<li><a href="#call-a-method-of-a-template-base-class"
id="toc-call-a-method-of-a-template-base-class"><span
class="toc-section-number">7</span> call a method of a template base
class</a></li>
<li><a href="#default-on-implementation"
id="toc-default-on-implementation"><span
class="toc-section-number">8</span> <code>= default</code> on
implementation</a></li>
<li><a href="#delete-for-free-functions"
id="toc-delete-for-free-functions"><span
class="toc-section-number">9</span> <code>= delete</code> for free
functions</a></li>
<li><a href="#line-and-file-renaming"
id="toc-line-and-file-renaming"><span
class="toc-section-number">10</span> <code>#line</code> and file
renaming</a></li>
<li><a href="#meyers-cons_cast" id="toc-meyers-cons_cast"><span
class="toc-section-number">11</span> Meyers cons_cast</a></li>
<li><a href="#missing-std-and-why-it-still-compiles-adl"
id="toc-missing-std-and-why-it-still-compiles-adl"><span
class="toc-section-number">12</span> missing <code>std::</code> and why
it still compiles (ADL)</a></li>
<li><a href="#why-stl-is-using-stdmove-everywhere"
id="toc-why-stl-is-using-stdmove-everywhere"><span
class="toc-section-number">13</span> why STL is using
<code>::std::move</code> everywhere?</a></li>
<li><a href="#stdshared_ptr-aliasing-constructor"
id="toc-stdshared_ptr-aliasing-constructor"><span
class="toc-section-number">14</span> <code>std::shared_ptr</code>
aliasing constructor</a></li>
<li><a href="#dynamic_castvoid" id="toc-dynamic_castvoid"><span
class="toc-section-number">15</span>
<code>dynamic_cast&lt;void*&gt;</code></a></li>
</ul>
</nav>
<p>To generate this .html out of <a
href="https://raw.githubusercontent.com/grishavanika/grishavanika.github.io/refs/heads/master/cpp_tips_tricks_quirks.md">cpp_tips_tricks_quirks.md</a>:</p>
<pre><code>pandoc -s --toc --toc-depth=4 ^
  --number-sections ^
  --highlight=kate ^
  -f markdown -t html ^
  cpp_tips_tricks_quirks.md ^
  -o cpp_tips_tricks_quirks.html </code></pre>
<hr />
<p><mark>TODO</mark></p>
<ul>
<li>friend injection</li>
<li>(go thru idioms, shwartz counter,
https://en.m.wikibooks.org/wiki/More_C++_Idioms)</li>
<li>(go thru shortcuts, like immediately invoked lambda)</li>
<li>see also https://github.com/shafik/cpp_blogs quiz questions</li>
<li>(and https://cppquiz.org/)</li>
<li>identity to disable template argument deduction</li>
<li>hierarhical tag dispatch (see artur,
https://quuxplusone.github.io/blog/2021/07/09/priority-tag/)</li>
<li>cout and stdout synchronization</li>
<li>initializer list crap (no move only)</li>
<li>std::function crap (no move only)</li>
<li>shared_ptr aliasing ctor</li>
<li>shared_ptr delete base, no need for virtual</li>
<li>non-trivial types in union</li>
<li>+[]()</li>
<li>no capture needed for globals/const for lambda</li>
<li>extern template</li>
<li>operator-&gt; and non pointer return type recursion</li>
<li>operator Type for perfect forward construction</li>
<li>overload struct for variant visit (inherit from lambda)</li>
<li>pseudo destructors (~int)</li>
<li>reference collapsing (even pre c++11)</li>
<li>map and modifying keys ub</li>
<li>picewise construct</li>
<li>map[x]</li>
<li>emplace back with placement new pre c++11</li>
<li>unreal conditionaldestroy uobject</li>
<li>unreal assign null (??)</li>
<li>instanced structs</li>
<li>mayers singletong</li>
<li>universal references, mayers</li>
<li>https://gist.github.com/fay59/5ccbe684e6e56a7df8815c3486568f01</li>
<li>https://jorenar.com/blog/less-known-c</li>
<li>http://www.danielvik.com/2010/05/c-language-quirks.html</li>
<li>https://codeforces.com/blog/entry/74684</li>
<li>inherit multiple classes from template, with tags</li>
<li>variadic templates default argument emulation</li>
<li>mixing variadic templates and variadic c</li>
<li>type promotion passing custom type/float to variadic c</li>
<li>shared_ptr void</li>
<li>dynamic cast reference/pointer</li>
<li>https://andreasfertig.blog/2021/07/cpp20-a-neat-trick-with-consteval/</li>
<li>templates sfinae/enable_if/checks/void_t</li>
<li>https://en.cppreference.com/w/cpp/meta</li>
<li>https://landelare.github.io/2023/01/07/cpp-speedrun.html</li>
<li>https://andreasfertig.com/courses/programming-with-cpp11-to-cpp17/</li>
<li>x-macro</li>
<li>https://www.foonathan.net/2020/05/fold-tricks/</li>
<li>rdbuf, read whole file</li>
<li>rdbuf, redirect:
https://stackoverflow.com/questions/10150468/how-to-redirect-cin-and-cout-to-files</li>
<li>allocconsole, reopen</li>
<li>https://chromium.googlesource.com/chromium/src/base/+/master/strings/stringprintf.h</li>
<li>see chromium/base</li>
<li>see boost/base</li>
<li>see abseil</li>
<li>forcing constexpr to be compile time</li>
<li>type id / magic enum (parsing <code>__PRETTY_FUNCTION__</code>)</li>
<li>injected class name recursion</li>
<li>swap idiom (unqualified call to swap in generic context)</li>
<li>https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick</li>
<li>https://en.wikipedia.org/wiki/Category:C%2B%2B</li>
</ul>
<hr />
<p><mark>TODO Unreal</mark></p>
<ul>
<li>https://erikbern.com/2024/09/27/its-hard-to-write-code-for-humans.html</li>
<li>https://itscai.us/blog/post/ue-physics-framework/</li>
<li>https://github.com/mtmucha/coros</li>
<li>https://achavezmixco.com/blog/f/how-to-write-c-blueprint-friendly-code-in-unreal-engine</li>
<li>https://isaratech.com/all-articles/</li>
<li>https://jasperdelaat.com/unreal-engine/damage-1/</li>
<li>https://github.com/landelare/ue5coro</li>
<li>https://landelare.github.io/2022/09/27/tips-and-tricks.html</li>
<li>https://zomgmoz.tv/unreal/Unreal-Insights</li>
<li>https://www.stevestreeting.com/2021/09/14/ue4-editor-visualisation-helper/</li>
<li>https://www.stevestreeting.com/2020/11/02/ue4-c-interfaces-hints-n-tips/</li>
<li>https://www.foonathan.net/2020/05/fold-tricks/</li>
<li>https://tamir.dev/posts/that-overloaded-trick-overloading-lambdas-in-cpp17/</li>
<li>http://mikejsavage.co.uk/cpp-tricks-type-id/</li>
<li>https://andreasfertig.com/courses/programming-with-cpp11-to-cpp17/</li>
<li>https://www.scs.stanford.edu/~dm/blog/param-pack.html</li>
<li>https://www.modernescpp.com/index.php/smart-tricks-with-fold-expressions/</li>
<li>https://andreasfertig.com/books/notebookcpp-tips-and-tricks-with-templates/</li>
<li>https://abseil.io/tips/</li>
<li>https://github.com/tip-of-the-week/cpp</li>
<li>https://stackoverflow.com/questions/75538/hidden-features-of-c</li>
<li>https://www.reddit.com/r/cpp_questions/comments/161wfp1/do_you_know_some_lesser_known_cc_tricks_or/</li>
<li>https://learn.microsoft.com/en-us/shows/pure-virtual-cpp-2022/cute-cpp-tricks-part-2-of-n-more-code-you-should-learn-from-and-never-write</li>
<li>https://prajwalshetty.com/ue5/Useful-Unreal-Links/</li>
<li>https://www.codeproject.com/Tips/5249485/The-Most-Essential-Cplusplus-Advice</li>
<li>https://jorenar.com/blog/less-known-c</li>
<li>https://theorangeduck.com/page/delta-time-frame-behind</li>
<li>https://www.reddit.com/r/unrealengine/s/ZvVB2DkX4c</li>
<li></li>
</ul>
<h4 data-number="1" id="pitfall-of-for-const-pairk-v-kv-my_map"><span
class="header-section-number">1</span> pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></h4>
<p>Here, <code>kv</code> is a copy instead of const reference since
std::meow_map <code>value_type</code> is
<code>std::pair&lt;const Key, T&gt;</code>, notice <strong>const
Key</strong>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// wrong</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p><code>pair&lt;std::string, int&gt;</code> is copy-constructed from
<code>pair&lt;const std::string, int&gt;</code> . Proper version:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// correct</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Note, <a
href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">AAA
style (Almost Always Auto)</a> recommends to go with
<code>const auto&amp;</code> that also solves the problem (sadly, with
the loss of explicitly written types):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// correct</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>with C++17 structured binding, it’s also:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// correct</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>key<span class="op">,</span> value<span class="op">]</span> <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>See <a href="https://www.reddit.com/user/STL/">/u/STL</a> <a
href="https://www.reddit.com/r/cpp/comments/1fhncm2/comment/lndnk8m/">comments</a>.
Note on /u/STL <a
href="https://brevzin.github.io/c++/2023/03/14/prefer-views-meow/">meow</a>.</p>
<h4 data-number="2" id="declare-function-with-typedefusing"><span
class="header-section-number">2</span> declare function with
typedef/using</h4>
<p>Surprisingly, you can declare a function with using declaration:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">using</span> MyFunction <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">// same as `void Foo(int);`</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>MyFunction Foo<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">// actual definition</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">}</span></span></code></pre></div>
<p>Notice, Foo is <strong>not</strong> a variable, but function
declaration. Running the code above with
<code>clang -Xclang -ast-dump</code>, shows:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>`-FunctionDecl 0xcc10e50 &lt;line:4:1, col:12&gt; col:12 Foo &#39;MyFunction&#39;:&#39;void (int)&#39;</span>
<span id="cb7-2"><a href="#cb7-2"></a>  `-ParmVarDecl 0xcc10f10 &lt;col:12&gt; col:12 implicit &#39;int&#39;</span></code></pre></div>
<p>Same can be done to declare a method:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">using</span> MyMethod <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co">// member function declaration</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    MyMethod Bar<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co">// equivalent too:</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co">// void Bar(int);</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">// actual definition</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="dt">void</span> MyClass<span class="op">::</span>Bar<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="op">}</span></span></code></pre></div>
<p>Mentioned at least <a
href="https://www.reddit.com/r/C_Programming/comments/2pkwvf/comment/cmxlx0e">there</a>.
See also:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">typedef</span> <span class="dt">double</span> MyFunction<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">float</span><span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>MyFunction foo<span class="op">,</span> bar<span class="op">,</span> baz<span class="op">;</span> <span class="co">// functions declarations</span></span></code></pre></div>
<h4 data-number="3"
id="protectedprivate-virtual-functions-override"><span
class="header-section-number">3</span> protected/private virtual
functions override</h4>
<p>Access rights are resolved at compile-time, virtual function target -
at run-time. It’s perfectly fine to move virtual-override to private
section:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">class</span> MyBase</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="co">// ...</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="op">};</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">class</span> MyDerived <span class="op">:</span> <span class="kw">public</span> MyBase</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="co">// note: Foo is private now</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="kw">override</span> <span class="op">{}</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="op">};</span></span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="dt">void</span> Use<span class="op">(</span><span class="at">const</span> MyBase<span class="op">&amp;</span> base<span class="op">)</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    base<span class="op">.</span>Foo<span class="op">(</span><span class="dv">42</span><span class="op">);</span> <span class="co">// calls override, if any</span></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a>Use<span class="op">(</span>MyDerived<span class="op">{});</span></span></code></pre></div>
<p>It (a) clean-ups derived classes public API/interface (b) explicitly
signals that function is expected to be invoked from within
framework/base class and (c) does not break Liskov substitution
principle.</p>
<p>In heavy OOP frameworks that rely on inheritance (Unreal Engine, as
an example), it makes sense to make virtual-overrides protected instead
of private so derived class could invoke Super:: version in the
implementation.</p>
<h4 data-number="4" id="function-try-block"><span
class="header-section-number">4</span> function try block</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/try#Function_try_block">cppreference</a>.
Specifically, to handle exceptions for constructor initializer:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">int</span> Bar<span class="op">()</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="cf">throw</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">struct</span> MyFoo</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a> </span>
<span id="cb11-10"><a href="#cb11-10"></a>    MyFoo<span class="op">()</span> <span class="cf">try</span> <span class="op">:</span> data<span class="op">(</span>Bar<span class="op">())</span> <span class="op">{}</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="co">// handles the exception</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="op">};</span></span></code></pre></div>
<p>but also works just fine for regular functions to handle arguments
construction exceptions:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="cf">try</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="co">// function body</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="co">// exception handling for arguments</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="5" id="omiting-public-when-deriving"><span
class="header-section-number">5</span> omiting <code>public</code> when
deriving</h4>
<p>Minor, still, see <a
href="https://en.cppreference.com/w/cpp/language/derived_class">cppreference,
access-specifier</a>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> MyBase <span class="op">{};</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">struct</span> MyDerived1 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : public  MyBase</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">class</span>  MyDerived2 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : private MyBase</span></span></code></pre></div>
<h4 data-number="6" id="void0-to-force-for-macros"><span
class="header-section-number">6</span> <code>(void)0</code> to force
<code>;</code> for macros</h4>
<p>To be consistent and force the user of the macro to put
<code>;</code> at the line end:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#define MY_FOO</span><span class="op">(</span>MY_INPUT<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">    </span><span class="cf">while</span><span class="pp"> </span><span class="op">(</span><span class="kw">true</span><span class="op">)</span><span class="pp"> </span><span class="op">{</span><span class="pp">       </span><span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">        </span>MY_INPUT<span class="op">;</span><span class="pp">        </span><span class="op">\</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">        </span><span class="cf">break</span><span class="op">;</span><span class="pp">           </span><span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)</span><span class="dv">0</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="co">// ^^^^^^</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;X&quot;</span><span class="op">));</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;Y&quot;</span><span class="op">));</span></span></code></pre></div>
<h4 data-number="7" id="call-a-method-of-a-template-base-class"><span
class="header-section-number">7</span> call a method of a template base
class</h4>
<p>See also <a
href="https://yunmingzhang.wordpress.com/2019/01/26/accessing-template-base-class-members-in-c/">Accessing
template base class members in C++</a>.</p>
<p>Given standard code like this:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="op">};</span></span></code></pre></div>
<p>we can call <code>Base::Foo()</code> with no issues. However, in case
when we use templates, Foo() can’t be found. The trick is to use
<code>this-&gt;Foo()</code>. Or <code>MyBase&lt;U&gt;::Foo()</code>:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase<span class="op">&lt;</span>U<span class="op">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="op">};</span></span></code></pre></div>
<p><code>this-&gt;Foo()</code> becomes <a
href="https://en.cppreference.com/w/cpp/language/dependent_name">type-dependent
expression</a>.</p>
<h4 data-number="8" id="default-on-implementation"><span
class="header-section-number">8</span> <code>= default</code> on
implementation</h4>
<p>You can default special member functions in the .cpp/out of line
definition:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    MyClass<span class="op">();</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">};</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">// myclass.cpp, for instance:</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>MyClass<span class="op">::</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span></code></pre></div>
<p>Note, this is almost the same as = default in-place, but makes
constructor user-defined. Sometimes it’s not a desired side effect.
However, it’s nice in case you want to change the body of constructor
later or put breakpoint (since you don’t need to change header and
recompile dependencies, only .cpp file).</p>
<p>Another use-case is to move destructor to .cpp file so you don’t
delete incomplete types:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">struct</span> MyInterface<span class="op">;</span> <span class="co">// forward-declare</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> MyClass</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>MyInterface<span class="op">&gt;</span> my_ptr<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="op">~</span>MyClass<span class="op">();</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="op">};</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">// myclass.cpp</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="pp">#include </span><span class="im">&quot;MyInterface.h&quot;</span><span class="pp"> </span><span class="co">// include only now</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>MyClass<span class="op">::~</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="co">// generate a call to my_ptr.~unique_ptr()</span></span></code></pre></div>
<h4 data-number="9" id="delete-for-free-functions"><span
class="header-section-number">9</span> <code>= delete</code> for free
functions</h4>
<p>You can delete unneeded function overload anywhere:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">char</span><span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p><code>MyHandle('x')</code> does not compile now.</p>
<h4 data-number="10" id="line-and-file-renaming"><span
class="header-section-number">10</span> <code>#line</code> and file
renaming</h4>
<p>See <a
href="https://en.cppreference.com/w/c/preprocessor/line">cppreference</a>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// main.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#line 777 &quot;any_filename.x&quot;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="op">}</span></span></code></pre></div>
<p>wich outputs:</p>
<blockquote>
<p>output.s: any_filename.x:777: int main(): Assertion
<code>false</code> failed.</p>
</blockquote>
<p>Note: this could break .pdb(s).<br />
Bonus: what happens if you do <code>#line 4294967295</code>?</p>
<h4 data-number="11" id="meyers-cons_cast"><span
class="header-section-number">11</span> Meyers cons_cast</h4>
<p>To not repeat code inside const and non-const function, <a
href="https://stackoverflow.com/a/123995">see SO</a>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> MyArray</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">char</span> data<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span> <span class="at">const</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>        <span class="ot">assert</span><span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="cf">return</span> data<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="op">}</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>        <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> MyArray<span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">).</span>get<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="op">};</span></span></code></pre></div>
<p>Note: mutable <code>get()</code> is implemented in terms of const
version, not the other way around (which would be UB).</p>
<p>Kind-a outdated with <a
href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23’s
Deducing this</a> or is it? (template, compile time, .h vs .cpp).</p>
<h4 data-number="12"
id="missing-std-and-why-it-still-compiles-adl"><span
class="header-section-number">12</span> missing <code>std::</code> and
why it still compiles (ADL)</h4>
<p>Notice, that code below will compile (most of the time):</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vs<span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>sort<span class="op">(</span>vs<span class="op">.</span>begin<span class="op">(),</span> vs<span class="op">.</span>end<span class="op">());</span> <span class="co">// note: missing std:: when calling sort()</span></span></code></pre></div>
<p>Since std::vector iterator lives in namespace <code>std::</code> (*),
ADL will be performed to find std::sort and use it. ADL = <a
href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent
lookup (ADL), also known as Koenig lookup</a>.</p>
<p>(*) Note, iterator could be just raw pointer (<code>int*</code>) and
it’s implementation defined (?) where or not iterator is inside std.
Meaning the code above is not portable (across different implementations
of STL).</p>
<h4 data-number="13" id="why-stl-is-using-stdmove-everywhere"><span
class="header-section-number">13</span> why STL is using
<code>::std::move</code> everywhere?</h4>
<p>Take a look at <a
href="https://github.com/microsoft/STL/blob/faccf0084ed9b8b58df103358174537233b178c7/stl/inc/algorithm#L452-L453">MSVC’s
implementation of the C++ Standard Library</a>:</p>
<div class="sourceCode" id="cb23" data-startFrom="452"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 451;"><span id="cb23-452"><a href="#cb23-452"></a>_STD _Seek_wrapped<span class="op">(</span>_First<span class="op">,</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>in<span class="op">));</span></span>
<span id="cb23-453"><a href="#cb23-453"></a><span class="cf">return</span> <span class="op">{</span>_STD move<span class="op">(</span>_First<span class="op">),</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>fun<span class="op">)};</span></span></code></pre></div>
<p>where _STD is <code>#define _STD ::std::</code>.<br />
So <code>::std::move</code> is used to <strong>disable</strong> ADL and
make sure implementation of <code>move</code> from namespace
<code>std</code> is choosen. Who knows what user-defined custom type
could bring into the table?</p>
<h4 data-number="14" id="stdshared_ptr-aliasing-constructor"><span
class="header-section-number">14</span> <code>std::shared_ptr</code>
aliasing constructor</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr">aliasing
constructor</a>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">struct</span> MyType</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="op">};</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyType<span class="op">&gt;</span> v1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyType<span class="op">&gt;();</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">{</span>v1<span class="op">,</span> <span class="op">&amp;</span>v1<span class="op">-&gt;</span>data<span class="op">};</span></span></code></pre></div>
<p>v2 and v1 now share the same control block. You can also put a
pointer to unrelative data (is there real-life use-case?).</p>
<h4 data-number="15" id="dynamic_castvoid"><span
class="header-section-number">15</span>
<code>dynamic_cast&lt;void*&gt;</code></h4>
<p>From anywhere in the hierarhy of polimorphic type, you can restore a
pointer to most-derived instance (i.e., the one created by
<code>new</code> initially):</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>MyBase<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase <span class="op">{};</span></span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>MyDerived<span class="op">*</span> original_ptr <span class="op">=</span> <span class="kw">new</span> MyDerived<span class="op">{};</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>MyBase<span class="op">*</span> base_ptr <span class="op">=</span> original_ptr<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="dt">void</span><span class="op">*</span> void_ptr <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>base_ptr<span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="ot">assert</span><span class="op">(</span>void_ptr <span class="op">==</span> original_ptr<span class="op">);</span></span></code></pre></div>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/dynamic_cast">cppreference</a>.
Most-likely useful to interop with C library/external code.</p>
</body>
</html>
