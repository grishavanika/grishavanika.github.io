<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C++ tips, tricks and quirks.</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">C++ tips, tricks and quirks.</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#pitfall-of-for-const-pairk-v-kv-my_map"
id="toc-pitfall-of-for-const-pairk-v-kv-my_map"><span
class="toc-section-number">1</span> # pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></a></li>
<li><a href="#declare-function-with-typedefusing"
id="toc-declare-function-with-typedefusing"><span
class="toc-section-number">2</span> # declare function with
typedef/using</a></li>
<li><a href="#protectedprivate-virtual-functions-override"
id="toc-protectedprivate-virtual-functions-override"><span
class="toc-section-number">3</span> # protected/private virtual
functions override</a></li>
<li><a href="#function-try-block" id="toc-function-try-block"><span
class="toc-section-number">4</span> # function try block</a></li>
<li><a href="#omiting-public-when-deriving"
id="toc-omiting-public-when-deriving"><span
class="toc-section-number">5</span> # omiting <code>public</code> when
deriving</a></li>
<li><a href="#void0-to-force-for-macros"
id="toc-void0-to-force-for-macros"><span
class="toc-section-number">6</span> # <code>(void)0</code> to force
<code>;</code> for macros</a></li>
<li><a href="#call-a-method-of-a-template-base-class"
id="toc-call-a-method-of-a-template-base-class"><span
class="toc-section-number">7</span> # call a method of a template base
class</a></li>
<li><a href="#default-on-implementation"
id="toc-default-on-implementation"><span
class="toc-section-number">8</span> # <code>= default</code> on
implementation</a></li>
<li><a href="#delete-for-free-functions"
id="toc-delete-for-free-functions"><span
class="toc-section-number">9</span> # <code>= delete</code> for free
functions</a></li>
<li><a href="#line-and-file-renaming"
id="toc-line-and-file-renaming"><span
class="toc-section-number">10</span> # <code>#line</code> and file
renaming</a></li>
<li><a href="#meyers-cons_cast" id="toc-meyers-cons_cast"><span
class="toc-section-number">11</span> # Meyers cons_cast</a></li>
<li><a href="#missing-std-and-why-it-still-compiles-adl"
id="toc-missing-std-and-why-it-still-compiles-adl"><span
class="toc-section-number">12</span> # missing <code>std::</code> and
why it still compiles (ADL)</a></li>
<li><a href="#why-stl-is-using-stdmove-everywhere"
id="toc-why-stl-is-using-stdmove-everywhere"><span
class="toc-section-number">13</span> # why STL is using
<code>::std::move</code> everywhere?</a></li>
<li><a href="#the-use-of-shared_ptr-in-public-api-is-a-code-smell"
id="toc-the-use-of-shared_ptr-in-public-api-is-a-code-smell"><span
class="toc-section-number">14</span> # the use of shared_ptr in public
API is a code smell</a></li>
<li><a href="#enable_shared_from_this-requires-factory-function"
id="toc-enable_shared_from_this-requires-factory-function"><span
class="toc-section-number">15</span> # enable_shared_from_this requires
factory function</a></li>
<li><a href="#stdshared_ptr-aliasing-constructor"
id="toc-stdshared_ptr-aliasing-constructor"><span
class="toc-section-number">16</span> # <code>std::shared_ptr</code>
aliasing constructor</a></li>
<li><a href="#dynamic_castvoid-to-get-most-derived-object"
id="toc-dynamic_castvoid-to-get-most-derived-object"><span
class="toc-section-number">17</span> #
<code>dynamic_cast&lt;void*&gt;</code> to get most-derived
object</a></li>
<li><a href="#stdshared_ptrbase-with-no-virtual-destructor"
id="toc-stdshared_ptrbase-with-no-virtual-destructor"><span
class="toc-section-number">18</span> #
<code>std::shared_ptr&lt;base&gt;</code> with no virtual
destructor</a></li>
<li><a href="#stateful-metaprogramming"
id="toc-stateful-metaprogramming"><span
class="toc-section-number">19</span> # stateful metaprogramming</a></li>
<li><a href="#access-private-members"
id="toc-access-private-members"><span
class="toc-section-number">20</span> # access private members</a></li>
<li><a href="#extern-templates" id="toc-extern-templates"><span
class="toc-section-number">21</span> # extern templates</a></li>
<li><a href="#templates-in-.cpp-file"
id="toc-templates-in-.cpp-file"><span
class="toc-section-number">22</span> # templates in .cpp file</a></li>
<li><a href="#double-template-syntax"
id="toc-double-template-syntax"><span
class="toc-section-number">23</span> # double-template syntax</a></li>
<li><a href="#when-type-t-is-bitcopyable"
id="toc-when-type-t-is-bitcopyable"><span
class="toc-section-number">24</span> # when type T is
bitcopyable?</a></li>
<li><a href="#pseudo-destructors-int"
id="toc-pseudo-destructors-int"><span
class="toc-section-number">25</span> # pseudo destructors
(~int)</a></li>
<li><a href="#manually-invoke-constructor"
id="toc-manually-invoke-constructor"><span
class="toc-section-number">26</span> # manually invoke
constructor</a></li>
<li><a href="#injected-class-name" id="toc-injected-class-name"><span
class="toc-section-number">27</span> # injected-class-name</a></li>
<li><a href="#invoke-base-virtual-function-directly"
id="toc-invoke-base-virtual-function-directly"><span
class="toc-section-number">28</span> # invoke base virtual function
directly</a></li>
<li><a href="#perfect-construct-with-factory-function"
id="toc-perfect-construct-with-factory-function"><span
class="toc-section-number">29</span> # perfect construct with factory
function</a></li>
<li><a href="#disable-template-argument-deduction"
id="toc-disable-template-argument-deduction"><span
class="toc-section-number">30</span> # disable template argument
deduction</a></li>
<li><a href="#priority_tag-for-tag-dispatch"
id="toc-priority_tag-for-tag-dispatch"><span
class="toc-section-number">31</span> # priority_tag for tag
dispatch</a></li>
<li><a href="#new-auto10" id="toc-new-auto10"><span
class="toc-section-number">32</span> # new auto(10)</a></li>
<li><a href="#stdforward-use-in-stdfunction-like-case"
id="toc-stdforward-use-in-stdfunction-like-case"><span
class="toc-section-number">33</span> # <code>std::forward</code> use in
std::function-like case</a></li>
<li><a href="#virtual-functions-default-arguments"
id="toc-virtual-functions-default-arguments"><span
class="toc-section-number">34</span> # virtual functions default
arguments</a></li>
<li><a href="#virtual-functions-overloads"
id="toc-virtual-functions-overloads"><span
class="toc-section-number">35</span> # virtual functions
overloads</a></li>
<li><a href="#change-base-class-member-access-rights"
id="toc-change-base-class-member-access-rights"><span
class="toc-section-number">36</span> # change base class member access
rights</a></li>
<li><a href="#use-default-constructor-for-state-reset"
id="toc-use-default-constructor-for-state-reset"><span
class="toc-section-number">37</span> # use default constructor for state
reset</a></li>
<li><a href="#default-constructor-is-a-must-for-modern-c"
id="toc-default-constructor-is-a-must-for-modern-c"><span
class="toc-section-number">38</span> # default constructor is a must for
modern C++</a></li>
<li><a href="#default-constructor-must-do-no-work"
id="toc-default-constructor-must-do-no-work"><span
class="toc-section-number">39</span> # default constructor must do no
work</a></li>
<li><a href="#constructors-should-do-no-work"
id="toc-constructors-should-do-no-work"><span
class="toc-section-number">40</span> # constructors should do no
work</a></li>
<li><a href="#stdunique_ptr-with-decltype-lambda"
id="toc-stdunique_ptr-with-decltype-lambda"><span
class="toc-section-number">41</span> # <code>std::unique_ptr</code> with
decltype lambda</a></li>
<li><a href="#auto-vs-auto-for-pointers"
id="toc-auto-vs-auto-for-pointers"><span
class="toc-section-number">42</span> # <code>auto</code> vs
<code>auto*</code> for pointers</a></li>
<li><a href="#stdtransform-and-lift-passing-overload-set"
id="toc-stdtransform-and-lift-passing-overload-set"><span
class="toc-section-number">43</span> # std::transform and LIFT (passing
overload set)</a></li>
<li><a href="#tolower-is-not-an-addressible-function"
id="toc-tolower-is-not-an-addressible-function"><span
class="toc-section-number">44</span> # <code>tolower</code> is not an
addressible function</a></li>
<li><a
href="#replace-operator-new-to-track-third-party-code-allocations"
id="toc-replace-operator-new-to-track-third-party-code-allocations"><span
class="toc-section-number">45</span> # replace operator new to track
third-party code allocations</a></li>
<li><a href="#stdshared_ptrvoid-as-user-data-pointer"
id="toc-stdshared_ptrvoid-as-user-data-pointer"><span
class="toc-section-number">46</span> #
<code>std::shared_ptr&lt;void&gt;</code> as user-data pointer</a></li>
<li><a href="#sync_with_stdio-for-stdout-vs-stdcout"
id="toc-sync_with_stdio-for-stdout-vs-stdcout"><span
class="toc-section-number">47</span> # sync_with_stdio for stdout vs
std::cout</a></li>
<li><a href="#stdclog-vs-stdcerr" id="toc-stdclog-vs-stdcerr"><span
class="toc-section-number">48</span> # std::clog vs std::cerr</a></li>
<li><a href="#capture-less-lambda-can-be-converted-to-c-function"
id="toc-capture-less-lambda-can-be-converted-to-c-function"><span
class="toc-section-number">49</span> # capture-less lambda can be
converted to c-function</a></li>
<li><a href="#to-convert-lambda-to-c-function"
id="toc-to-convert-lambda-to-c-function"><span
class="toc-section-number">50</span> # <code>+[](){}</code> to convert
lambda to c-function</a></li>
<li><a href="#virtual-operator-int" id="toc-virtual-operator-int"><span
class="toc-section-number">51</span> # virtual operator int</a></li>
<li><a href="#placement-new-emplace_back-pre-c11"
id="toc-placement-new-emplace_back-pre-c11"><span
class="toc-section-number">52</span> # placement new emplace_back
pre-C++11</a></li>
<li><a href="#operator--recursion-returning-non-pointer-type"
id="toc-operator--recursion-returning-non-pointer-type"><span
class="toc-section-number">53</span> # <code>operator-&gt;</code>
recursion (returning non-pointer type)</a></li>
<li><a href="#move-only-types-and-initializer_list"
id="toc-move-only-types-and-initializer_list"><span
class="toc-section-number">54</span> # move-only types and
initializer_list</a></li>
<li><a href="#uniform-initialization-is-not-uniform-use-parentheses-vs"
id="toc-uniform-initialization-is-not-uniform-use-parentheses-vs"><span
class="toc-section-number">55</span> # uniform initialization is not
uniform, use parentheses (<code>()</code> vs <code>{}</code>)</a></li>
<li><a href="#move-only-lambda-and-stdfunction"
id="toc-move-only-lambda-and-stdfunction"><span
class="toc-section-number">56</span> # move-only lambda and
std::function</a></li>
<li><a href="#stdfunction-issues" id="toc-stdfunction-issues"><span
class="toc-section-number">57</span> # std::function issues</a></li>
<li><a href="#non-trivial-types-in-union"
id="toc-non-trivial-types-in-union"><span
class="toc-section-number">58</span> # non-trivial types in
union</a></li>
<li><a href="#lambda-with-access-to-const-and-global-variables"
id="toc-lambda-with-access-to-const-and-global-variables"><span
class="toc-section-number">59</span> # lambda with access to const and
global variables</a></li>
<li><a href="#stdvariant-overload-pattern"
id="toc-stdvariant-overload-pattern"><span
class="toc-section-number">60</span> # std::variant overload
pattern</a></li>
<li><a href="#unique_ptr-to-incomplete-type-and-class-destructor"
id="toc-unique_ptr-to-incomplete-type-and-class-destructor"><span
class="toc-section-number">61</span> # unique_ptr to incomplete type and
class destructor</a></li>
<li><a href="#the-use-of-shared_ptrconst-t"
id="toc-the-use-of-shared_ptrconst-t"><span
class="toc-section-number">62</span> # the use of
<code>shared_ptr&lt;const T&gt;</code></a></li>
<li><a href="#string_view-issues" id="toc-string_view-issues"><span
class="toc-section-number">63</span> # string_view issues</a></li>
<li><a href="#user-provided-constructor-and-garbage-initialization"
id="toc-user-provided-constructor-and-garbage-initialization"><span
class="toc-section-number">64</span> # user-provided constructor and
garbage initialization</a></li>
<li><a href="#beaware-of-stdstring_view-like-key-with-stdmeow_map"
id="toc-beaware-of-stdstring_view-like-key-with-stdmeow_map"><span
class="toc-section-number">65</span> # beaware of std::string_view-like
key with std::meow_map</a></li>
<li><a href="#stdpiecewise_construct"
id="toc-stdpiecewise_construct"><span
class="toc-section-number">66</span> #
<code>std::piecewise_construct</code></a></li>
<li><a href="#mapkey-creates-default-constructed-value-first"
id="toc-mapkey-creates-default-constructed-value-first"><span
class="toc-section-number">67</span> # <code>map[key]</code> creates
default-constructed value first</a></li>
<li><a href="#const-mapkey-does-not-compile-use-.find"
id="toc-const-mapkey-does-not-compile-use-.find"><span
class="toc-section-number">68</span> # const <code>map[key]</code> does
not compile, use <code>.find()</code></a></li>
<li><a href="#if-not-map.findx-then-mapx-is-an-antipattern"
id="toc-if-not-map.findx-then-mapx-is-an-antipattern"><span
class="toc-section-number">69</span> #
<code>if not map.find(x) then map[x]</code> is an antipattern</a></li>
<li><a href="#meyers-singleton" id="toc-meyers-singleton"><span
class="toc-section-number">70</span> # Meyer’s singleton</a></li>
<li><a href="#magic-static" id="toc-magic-static"><span
class="toc-section-number">71</span> # magic static</a></li>
<li><a href="#stdminx-y-thanks-to-windows.h"
id="toc-stdminx-y-thanks-to-windows.h"><span
class="toc-section-number">72</span> # (std::min)(x, y) thanks to
Windows.h</a></li>
<li><a href="#v-double-negation" id="toc-v-double-negation"><span
class="toc-section-number">73</span> # !!v double-negation</a></li>
<li><a href="#sizeof-v-and-sizeofv" id="toc-sizeof-v-and-sizeofv"><span
class="toc-section-number">74</span> # <code>sizeof v</code> and
<code>sizeof(v)</code></a></li>
<li><a href="#six-dots-ts......" id="toc-six-dots-ts......"><span
class="toc-section-number">75</span> # six dots
<code>Ts......</code></a></li>
<li><a href="#assertx-message" id="toc-assertx-message"><span
class="toc-section-number">76</span> #
<code>assert(x &amp;&amp; "message")</code></a></li>
<li><a href="#assert.h-and-ndebug-with-no-include-guard"
id="toc-assert.h-and-ndebug-with-no-include-guard"><span
class="toc-section-number">77</span> # <code>&lt;assert.h&gt;</code> and
NDEBUG with no include guard</a></li>
<li><a href="#universal-reference-vs-forwarding-reference"
id="toc-universal-reference-vs-forwarding-reference"><span
class="toc-section-number">78</span> # universal reference vs forwarding
reference</a></li>
<li><a href="#force-constexpr-to-evaluate-at-compile-time"
id="toc-force-constexpr-to-evaluate-at-compile-time"><span
class="toc-section-number">79</span> # force constexpr to evaluate at
compile time</a></li>
<li><a href="#variadic-template-with-default-argument"
id="toc-variadic-template-with-default-argument"><span
class="toc-section-number">80</span> # variadic template with default
argument</a></li>
<li><a href="#variadic-template-with-default-stdsource_locationcurrent"
id="toc-variadic-template-with-default-stdsource_locationcurrent"><span
class="toc-section-number">81</span> # variadic template with default
std::source_location::current()</a></li>
<li><a
href="#variadic-template-with-default-argument-and-deduction-guide"
id="toc-variadic-template-with-default-argument-and-deduction-guide"><span
class="toc-section-number">82</span> # variadic template with default
argument and deduction guide</a></li>
<li><a href="#debug-print-type-at-compile-time-with-error"
id="toc-debug-print-type-at-compile-time-with-error"><span
class="toc-section-number">83</span> # debug: print type at compile time
with error</a></li>
<li><a href="#debug-useful-custom-assert"
id="toc-debug-useful-custom-assert"><span
class="toc-section-number">84</span> # debug: useful custom
assert</a></li>
<li><a href="#stdmove-does-not-move"
id="toc-stdmove-does-not-move"><span
class="toc-section-number">85</span> # std::move does not move</a></li>
<li><a href="#no-destructive-move" id="toc-no-destructive-move"><span
class="toc-section-number">86</span> # no destructive move</a></li>
<li><a href="#stdmove-on-return" id="toc-stdmove-on-return"><span
class="toc-section-number">87</span> # std::move on return</a></li>
<li><a href="#enum-struct" id="toc-enum-struct"><span
class="toc-section-number">88</span> # enum struct</a></li>
<li><a href="#using-enum-declaration"
id="toc-using-enum-declaration"><span
class="toc-section-number">89</span> # using enum declaration</a></li>
<li><a href="#using-declaration-vs-using-directive"
id="toc-using-declaration-vs-using-directive"><span
class="toc-section-number">90</span> # using declaration vs using
directive</a></li>
<li><a href="#dynamic_castt-and-dynamic_castt"
id="toc-dynamic_castt-and-dynamic_castt"><span
class="toc-section-number">91</span> #
<code>dynamic_cast&lt;T*&gt;</code> and
<code>dynamic_cast&lt;T&amp;&gt;</code></a></li>
<li><a href="#dynamic_castconst-t-adds-const"
id="toc-dynamic_castconst-t-adds-const"><span
class="toc-section-number">92</span> #
<code>dynamic_cast&lt;const T*&gt;</code> adds const</a></li>
<li><a href="#conout-conin-for-allocconsole"
id="toc-conout-conin-for-allocconsole"><span
class="toc-section-number">93</span> # <code>CONOUT$</code>,
<code>CONIN$</code> for <code>::AllocConsole()</code></a></li>
<li><a href="#rdbuf-to-read-whole-file"
id="toc-rdbuf-to-read-whole-file"><span
class="toc-section-number">94</span> # rdbuf to read whole file</a></li>
<li><a href="#rdbuf-to-redirect" id="toc-rdbuf-to-redirect"><span
class="toc-section-number">95</span> # rdbuf to redirect</a></li>
<li><a href="#compile-error-on-missing-switch-enum-case"
id="toc-compile-error-on-missing-switch-enum-case"><span
class="toc-section-number">96</span> # compile error on missing switch
enum case</a></li>
<li><a href="#use-compiler-to-write-down-pointer-to-member-syntax"
id="toc-use-compiler-to-write-down-pointer-to-member-syntax"><span
class="toc-section-number">97</span> # use compiler to write down
pointer-to-member syntax</a></li>
<li><a
href="#all-enum-cases-are-handled-but-its-still-possible-to-fall-out-of-switch"
id="toc-all-enum-cases-are-handled-but-its-still-possible-to-fall-out-of-switch"><span
class="toc-section-number">98</span> # all enum cases are handled, but
it’s still possible to fall out of switch</a></li>
<li><a href="#on_scope_exit" id="toc-on_scope_exit"><span
class="toc-section-number">99</span> # ON_SCOPE_EXIT</a></li>
<li><a href="#float-to-double-and-integer-promotions-variadic-function"
id="toc-float-to-double-and-integer-promotions-variadic-function"><span
class="toc-section-number">100</span> # float to double and integer
promotions (variadic function)</a></li>
<li><a href="#surrogate-call-functions-conversion-operator"
id="toc-surrogate-call-functions-conversion-operator"><span
class="toc-section-number">101</span> # surrogate call functions (/
conversion operator)</a></li>
<li><a href="#array_size-function-returning-reference-to-an-array"
id="toc-array_size-function-returning-reference-to-an-array"><span
class="toc-section-number">102</span> # ARRAY_SIZE / function returning
reference to an array</a></li>
<li><a href="#infinite-function-pointer-dereference"
id="toc-infinite-function-pointer-dereference"><span
class="toc-section-number">103</span> # infinite function pointer
dereference</a></li>
<li><a
href="#historical-schwarz-counter-nifty-counter-static-initialization"
id="toc-historical-schwarz-counter-nifty-counter-static-initialization"><span
class="toc-section-number">104</span> # (historical?) Schwarz Counter /
Nifty Counter (static initialization)</a></li>
<li><a href="#emulate-concept-passing-as-template-argument"
id="toc-emulate-concept-passing-as-template-argument"><span
class="toc-section-number">105</span> # emulate concept passing as
template argument</a></li>
</ul>
</nav>
<p>To generate this .html out of <a
href="https://raw.githubusercontent.com/grishavanika/grishavanika.github.io/refs/heads/master/cpp_tips_tricks_quirks.md">cpp_tips_tricks_quirks.md</a>:</p>
<pre><code>pandoc -s --toc --toc-depth=4
  --standalone
  --number-sections
  --highlight=kate
  --from markdown --to=html5
  --lua-filter=anchor-links.lua
  cpp_tips_tricks_quirks.md
  -o cpp_tips_tricks_quirks.html</code></pre>
<p>Inspired by <a href="https://jorenar.com/blog/less-known-c">Lesser
known tricks, quirks and features of C</a>.</p>
<p><mark>C++ reference</mark>:</p>
<ul>
<li><a href="https://eel.is/c++draft">Working Draft/eel.is</a></li>
<li><a href="https://en.cppreference.com/w/">cppreference</a>, <a
href="https://en.cppreference.com/w/cpp/compiler_support">compiler
support</a></li>
<li><a href="https://wg21.link/">WG21 redirect
service/wg21.link</a></li>
<li><a href="https://godbolt.org/">Compiler Explorer/godbolt</a></li>
<li><a href="https://cppinsights.io/">Cpp Insights</a></li>
</ul>
<hr />
<h4 data-number="1" id="pitfall-of-for-const-pairk-v-kv-my_map"><span
class="header-section-number">1</span> <a
href="#pitfall-of-for-const-pairk-v-kv-my_map"># </a>pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></h4>
<p>Here, <code>kv</code> is a copy instead of const reference since
std::meow_map <code>value_type</code> is
<code>std::pair&lt;const Key, T&gt;</code>, notice <strong>const
Key</strong>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// wrong</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p><code>pair&lt;std::string, int&gt;</code> is copy-constructed from
<code>pair&lt;const std::string, int&gt;</code> . Proper version:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// correct</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Note, <a
href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">AAA
style (Almost Always Auto)</a> recommends to go with
<code>const auto&amp;</code> that also solves the problem (sadly, with
the loss of explicitly written types):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// correct</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>with C++17 structured binding, it’s also:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// correct</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>key<span class="op">,</span> value<span class="op">]</span> <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>See <a href="https://www.reddit.com/user/STL/">/u/STL</a> <a
href="https://www.reddit.com/r/cpp/comments/1fhncm2/comment/lndnk8m/">comments</a>.
Note on /u/STL <a
href="https://brevzin.github.io/c++/2023/03/14/prefer-views-meow/">meow</a>.</p>
<h4 data-number="2" id="declare-function-with-typedefusing"><span
class="header-section-number">2</span> <a
href="#declare-function-with-typedefusing"># </a>declare function with
typedef/using</h4>
<p>Surprisingly, you can declare a function with using declaration:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">using</span> MyFunction <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">// same as `void Foo(int);`</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>MyFunction Foo<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">// actual definition</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">}</span></span></code></pre></div>
<p>Notice, Foo is <strong>not</strong> a variable, but function
declaration. Running the code above with
<code>clang -Xclang -ast-dump</code>, shows:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>`-FunctionDecl 0xcc10e50 &lt;line:4:1, col:12&gt; col:12 Foo &#39;MyFunction&#39;:&#39;void (int)&#39;</span>
<span id="cb7-2"><a href="#cb7-2"></a>  `-ParmVarDecl 0xcc10f10 &lt;col:12&gt; col:12 implicit &#39;int&#39;</span></code></pre></div>
<p>Same can be done to declare a method:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">using</span> MyMethod <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co">// member function declaration</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    MyMethod Bar<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co">// equivalent too:</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co">// void Bar(int);</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">// actual definition</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="dt">void</span> MyClass<span class="op">::</span>Bar<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="op">}</span></span></code></pre></div>
<p>Mentioned at least <a
href="https://www.reddit.com/r/C_Programming/comments/2pkwvf/comment/cmxlx0e">there</a>.
See also:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">typedef</span> <span class="dt">double</span> MyFunction<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">float</span><span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>MyFunction foo<span class="op">,</span> bar<span class="op">,</span> baz<span class="op">;</span> <span class="co">// functions declarations</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">// OR</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="dt">int</span> foo<span class="op">(</span><span class="dt">char</span><span class="op">),</span> bar<span class="op">();</span></span></code></pre></div>
<h4 data-number="3"
id="protectedprivate-virtual-functions-override"><span
class="header-section-number">3</span> <a
href="#protectedprivate-virtual-functions-override">#
</a>protected/private virtual functions override</h4>
<p>Access rights are resolved at compile-time, virtual function target -
at run-time. It’s perfectly fine to move virtual-override to private
section:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">class</span> MyBase</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="co">// ...</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="op">};</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">class</span> MyDerived <span class="op">:</span> <span class="kw">public</span> MyBase</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="co">// note: Foo is private now</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="kw">override</span> <span class="op">{}</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="op">};</span></span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="dt">void</span> Use<span class="op">(</span><span class="at">const</span> MyBase<span class="op">&amp;</span> base<span class="op">)</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    base<span class="op">.</span>Foo<span class="op">(</span><span class="dv">42</span><span class="op">);</span> <span class="co">// calls override, if any</span></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a>Use<span class="op">(</span>MyDerived<span class="op">{});</span></span></code></pre></div>
<p>It (a) clean-ups derived classes public API/interface (b) explicitly
signals that function is expected to be invoked from within
framework/base class and (c) does not break Liskov substitution
principle.</p>
<p>In heavy OOP frameworks that rely on inheritance (Unreal Engine, as
an example), it makes sense to make virtual-overrides protected instead
of private so derived class could invoke Super:: version in the
implementation.</p>
<h4 data-number="4" id="function-try-block"><span
class="header-section-number">4</span> <a href="#function-try-block">#
</a>function try block</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/try#Function_try_block">cppreference</a>.
Specifically, to handle exceptions for constructor initializer:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">int</span> Bar<span class="op">()</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="cf">throw</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">struct</span> MyFoo</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a> </span>
<span id="cb11-10"><a href="#cb11-10"></a>    MyFoo<span class="op">()</span> <span class="cf">try</span> <span class="op">:</span> data<span class="op">(</span>Bar<span class="op">())</span> <span class="op">{}</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="co">// handles the exception</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="op">};</span></span></code></pre></div>
<p>but also works just fine for regular functions to handle arguments
construction exceptions:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="cf">try</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="co">// function body</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="co">// exception handling for arguments</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="5" id="omiting-public-when-deriving"><span
class="header-section-number">5</span> <a
href="#omiting-public-when-deriving"># </a>omiting <code>public</code>
when deriving</h4>
<p>Minor, still, see <a
href="https://en.cppreference.com/w/cpp/language/derived_class">cppreference,
access-specifier</a>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> MyBase <span class="op">{};</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">struct</span> MyDerived1 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : public  MyBase</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">class</span>  MyDerived2 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : private MyBase</span></span></code></pre></div>
<h4 data-number="6" id="void0-to-force-for-macros"><span
class="header-section-number">6</span> <a
href="#void0-to-force-for-macros"># </a><code>(void)0</code> to force
<code>;</code> for macros</h4>
<p>To be consistent and force the user of the macro to put
<code>;</code> at the line end:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#define MY_FOO</span><span class="op">(</span>MY_INPUT<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">    </span><span class="cf">while</span><span class="pp"> </span><span class="op">(</span><span class="kw">true</span><span class="op">)</span><span class="pp"> </span><span class="op">{</span><span class="pp">       </span><span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">        </span>MY_INPUT<span class="op">;</span><span class="pp">        </span><span class="op">\</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">        </span><span class="cf">break</span><span class="op">;</span><span class="pp">           </span><span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)</span><span class="dv">0</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="co">// ^^^^^^</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;X&quot;</span><span class="op">));</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;Y&quot;</span><span class="op">));</span></span></code></pre></div>
<h4 data-number="7" id="call-a-method-of-a-template-base-class"><span
class="header-section-number">7</span> <a
href="#call-a-method-of-a-template-base-class"># </a>call a method of a
template base class</h4>
<p>See also <a
href="https://yunmingzhang.wordpress.com/2019/01/26/accessing-template-base-class-members-in-c/">Accessing
template base class members in C++</a>.</p>
<p>Given standard code like this:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="op">};</span></span></code></pre></div>
<p>we can call <code>Base::Foo()</code> with no issues. However, in case
when we use templates, Foo() can’t be found. The trick is to use
<code>this-&gt;Foo()</code>. Or <code>MyBase&lt;U&gt;::Foo()</code>:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase<span class="op">&lt;</span>U<span class="op">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="op">};</span></span></code></pre></div>
<p><code>this-&gt;Foo()</code> becomes <a
href="https://en.cppreference.com/w/cpp/language/dependent_name">type-dependent
expression</a>.</p>
<h4 data-number="8" id="default-on-implementation"><span
class="header-section-number">8</span> <a
href="#default-on-implementation"># </a><code>= default</code> on
implementation</h4>
<p>You can default special member functions in the .cpp/out of line
definition:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    MyClass<span class="op">();</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">};</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">// myclass.cpp, for instance:</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>MyClass<span class="op">::</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span></code></pre></div>
<p>Note, this is almost the same as = default in-place, but makes
constructor user-defined. Sometimes it’s not a desired side effect.
However, it’s nice in case you want to change the body of constructor
later or put breakpoint (since you don’t need to change header and
recompile dependencies, only .cpp file).</p>
<p>Another use-case is to move destructor to .cpp file so you don’t
delete incomplete types:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">struct</span> MyInterface<span class="op">;</span> <span class="co">// forward-declare</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> MyClass</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>MyInterface<span class="op">&gt;</span> my_ptr<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="op">~</span>MyClass<span class="op">();</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="op">};</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">// myclass.cpp</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="pp">#include </span><span class="im">&quot;MyInterface.h&quot;</span><span class="pp"> </span><span class="co">// include only now</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>MyClass<span class="op">::~</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="co">// generate a call to my_ptr.~unique_ptr()</span></span></code></pre></div>
<h4 data-number="9" id="delete-for-free-functions"><span
class="header-section-number">9</span> <a
href="#delete-for-free-functions"># </a><code>= delete</code> for free
functions</h4>
<p>You can delete unneeded function overload anywhere:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">char</span><span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p><code>MyHandle('x')</code> does not compile now.</p>
<h4 data-number="10" id="line-and-file-renaming"><span
class="header-section-number">10</span> <a
href="#line-and-file-renaming"># </a><code>#line</code> and file
renaming</h4>
<p>See <a
href="https://en.cppreference.com/w/c/preprocessor/line">cppreference</a>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// main.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#line 777 &quot;any_filename.x&quot;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="op">}</span></span></code></pre></div>
<p>wich outputs:</p>
<blockquote>
<p>output.s: any_filename.x:777: int main(): Assertion
<code>false</code> failed.</p>
</blockquote>
<p>Note: this could break .pdb(s).<br />
Bonus: what happens if you do <code>#line 4294967295</code>?</p>
<h4 data-number="11" id="meyers-cons_cast"><span
class="header-section-number">11</span> <a href="#meyers-cons_cast">#
</a>Meyers cons_cast</h4>
<p>To not repeat code inside const and non-const function, <a
href="https://stackoverflow.com/a/123995">see SO</a>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> MyArray</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">char</span> data<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span> <span class="at">const</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>        <span class="ot">assert</span><span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="cf">return</span> data<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="op">}</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>        <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> MyArray<span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">).</span>get<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="op">};</span></span></code></pre></div>
<p>Note: mutable <code>get()</code> is implemented in terms of const
version, not the other way around (which would be UB).</p>
<p>Kind-a outdated with <a
href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23’s
Deducing this</a> or is it? (template, compile time, .h vs .cpp).</p>
<h4 data-number="12"
id="missing-std-and-why-it-still-compiles-adl"><span
class="header-section-number">12</span> <a
href="#missing-std-and-why-it-still-compiles-adl"># </a>missing
<code>std::</code> and why it still compiles (ADL)</h4>
<p>Notice, that code below will compile (most of the time):</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vs<span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>sort<span class="op">(</span>vs<span class="op">.</span>begin<span class="op">(),</span> vs<span class="op">.</span>end<span class="op">());</span> <span class="co">// note: missing std:: when calling sort()</span></span></code></pre></div>
<p>Since std::vector iterator lives in namespace <code>std::</code> (*),
ADL will be performed to find std::sort and use it. ADL = <a
href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent
lookup (ADL), also known as Koenig lookup</a>.</p>
<p>(*) Note, iterator could be just raw pointer (<code>int*</code>) and
it’s implementation defined (?) where or not iterator is inside std.
Meaning the code above is not portable (across different implementations
of STL).</p>
<h4 data-number="13" id="why-stl-is-using-stdmove-everywhere"><span
class="header-section-number">13</span> <a
href="#why-stl-is-using-stdmove-everywhere"># </a>why STL is using
<code>::std::move</code> everywhere?</h4>
<p>Take a look at <a
href="https://github.com/microsoft/STL/blob/faccf0084ed9b8b58df103358174537233b178c7/stl/inc/algorithm#L452-L453">MSVC’s
implementation of the C++ Standard Library</a>:</p>
<div class="sourceCode" id="cb23" data-startFrom="452"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 451;"><span id="cb23-452"><a href="#cb23-452"></a>_STD _Seek_wrapped<span class="op">(</span>_First<span class="op">,</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>in<span class="op">));</span></span>
<span id="cb23-453"><a href="#cb23-453"></a><span class="cf">return</span> <span class="op">{</span>_STD move<span class="op">(</span>_First<span class="op">),</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>fun<span class="op">)};</span></span></code></pre></div>
<p>_STD is <code>#define _STD ::std::</code>. Why?</p>
<p>So <code>::std::move</code> is used to <strong>disable</strong> ADL
and make sure implementation of <code>move</code> from namespace
<code>std</code> is choosen. Who knows what user-defined custom type
could bring into the table?</p>
<h4 data-number="14"
id="the-use-of-shared_ptr-in-public-api-is-a-code-smell"><span
class="header-section-number">14</span> <a
href="#the-use-of-shared_ptr-in-public-api-is-a-code-smell"># </a>the
use of shared_ptr in public API is a code smell</h4>
<p><mark>TBD</mark></p>
<h4 data-number="15"
id="enable_shared_from_this-requires-factory-function"><span
class="header-section-number">15</span> <a
href="#enable_shared_from_this-requires-factory-function">#
</a>enable_shared_from_this requires factory function</h4>
<p>If class derives from <code>enable_shared_from_this</code>:</p>
<ul>
<li>most likely, objects are required to be created with shared_ptr
and</li>
<li>the use of <code>shared_from_this()</code> in constructor is not
safe anyway.</li>
</ul>
<p>Hence, provide <code>Create()</code> factory function to encode the
behavior:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">struct</span> MyData <span class="op">:</span> <span class="kw">public</span> <span class="bu">std::</span>enable_shared_from_this<span class="op">&lt;</span>MyData<span class="op">&gt;</span></span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb24-4"><a href="#cb24-4"></a>    <span class="at">static</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyData<span class="op">&gt;</span> Create<span class="op">()</span></span>
<span id="cb24-5"><a href="#cb24-5"></a>    <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6"></a>        <span class="co">// Quiz: why not std::make_shared?</span></span>
<span id="cb24-7"><a href="#cb24-7"></a>        <span class="cf">return</span> <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyData<span class="op">&gt;(</span><span class="kw">new</span> MyData<span class="op">{});</span></span>
<span id="cb24-8"><a href="#cb24-8"></a>    <span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9"></a></span>
<span id="cb24-10"><a href="#cb24-10"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb24-11"><a href="#cb24-11"></a>    <span class="kw">explicit</span> MyData<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb24-12"><a href="#cb24-12"></a><span class="op">};</span></span></code></pre></div>
<p>See <a
href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this#Example">cppreference
example</a>.</p>
<h4 data-number="16" id="stdshared_ptr-aliasing-constructor"><span
class="header-section-number">16</span> <a
href="#stdshared_ptr-aliasing-constructor">#
</a><code>std::shared_ptr</code> aliasing constructor</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr">aliasing
constructor</a>:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">struct</span> MyType</span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="op">{</span></span>
<span id="cb25-3"><a href="#cb25-3"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb25-4"><a href="#cb25-4"></a><span class="op">};</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyType<span class="op">&gt;</span> v1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyType<span class="op">&gt;();</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">{</span>v1<span class="op">,</span> <span class="op">&amp;</span>v1<span class="op">-&gt;</span>data<span class="op">};</span></span></code></pre></div>
<p>v2 and v1 now share the same control block. You can also put a
pointer to unrelative data (is there real-life use-case?).</p>
<h4 data-number="17"
id="dynamic_castvoid-to-get-most-derived-object"><span
class="header-section-number">17</span> <a
href="#dynamic_castvoid-to-get-most-derived-object">#
</a><code>dynamic_cast&lt;void*&gt;</code> to get most-derived
object</h4>
<p>From anywhere in the hierarhy of polimorphic type, you can restore a
pointer to most-derived instance (i.e., the one created by
<code>new</code> initially):</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>MyBase<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase <span class="op">{};</span></span>
<span id="cb26-3"><a href="#cb26-3"></a></span>
<span id="cb26-4"><a href="#cb26-4"></a>MyDerived<span class="op">*</span> original_ptr <span class="op">=</span> <span class="kw">new</span> MyDerived<span class="op">{};</span></span>
<span id="cb26-5"><a href="#cb26-5"></a></span>
<span id="cb26-6"><a href="#cb26-6"></a>MyBase<span class="op">*</span> base_ptr <span class="op">=</span> original_ptr<span class="op">;</span></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="dt">void</span><span class="op">*</span> void_ptr <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>base_ptr<span class="op">);</span></span>
<span id="cb26-8"><a href="#cb26-8"></a></span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="ot">assert</span><span class="op">(</span>void_ptr <span class="op">==</span> original_ptr<span class="op">);</span></span></code></pre></div>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/dynamic_cast">cppreference</a>.
Most-likely useful to interop with C library/external code.</p>
<h4 data-number="18"
id="stdshared_ptrbase-with-no-virtual-destructor"><span
class="header-section-number">18</span> <a
href="#stdshared_ptrbase-with-no-virtual-destructor">#
</a><code>std::shared_ptr&lt;base&gt;</code> with no virtual
destructor</h4>
<p>Usually, if you delete pointer-to-base, destructor needs to be
declared virtual so proper destructor is invoked. Hovewer, for
std::shared_ptr this is not required:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="op">~</span>MyBase<span class="op">();</span> <span class="op">};</span> <span class="co">// no virtual!</span></span>
<span id="cb27-2"><a href="#cb27-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb27-3"><a href="#cb27-3"></a><span class="op">{</span></span>
<span id="cb27-4"><a href="#cb27-4"></a>    <span class="op">~</span>MyDerived<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;~MyDerived()&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb27-5"><a href="#cb27-5"></a><span class="op">};</span></span>
<span id="cb27-6"><a href="#cb27-6"></a></span>
<span id="cb27-7"><a href="#cb27-7"></a><span class="op">{</span></span>
<span id="cb27-8"><a href="#cb27-8"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyBase<span class="op">&gt;</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyDerived<span class="op">&gt;();</span>    </span>
<span id="cb27-9"><a href="#cb27-9"></a><span class="op">}</span> <span class="co">// invokes ~MyDerived()</span></span></code></pre></div>
<p><code>std::shared_ptr&lt;MyBase&gt;</code> holds <code>MyBase*</code>
pointer, but has <a
href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">type-erased</a>
destroy function that remembers the actual type it was created with.</p>
<p>See also <a href="http://www.gotw.ca/gotw/005.htm">GotW #5,
Overriding Virtual Functions</a>:</p>
<blockquote>
<p>Make base class destructors virtual</p>
</blockquote>
<h4 data-number="19" id="stateful-metaprogramming"><span
class="header-section-number">19</span> <a
href="#stateful-metaprogramming"># </a>stateful metaprogramming</h4>
<p>This <a href="https://b.atch.se/posts/constexpr-counter/">works</a>
and a and b have different values:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="dt">int</span> main <span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="kw">constexpr</span> <span class="dt">int</span> a <span class="op">=</span> f<span class="op">();</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>  <span class="kw">constexpr</span> <span class="dt">int</span> b <span class="op">=</span> f<span class="op">();</span></span>
<span id="cb28-4"><a href="#cb28-4"></a></span>
<span id="cb28-5"><a href="#cb28-5"></a>  <span class="kw">static_assert</span><span class="op">(</span>a <span class="op">!=</span> b<span class="op">);</span></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="op">}</span></span></code></pre></div>
<p>See, for instance, <a
href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting
Stateful Metaprogramming in C++20</a>:</p>
<ul>
<li><a
href="https://b.atch.se/posts/constexpr-counter/">constant-expression
counter</a></li>
<li><a
href="https://b.atch.se/posts/constexpr-meta-container/">compile-time
list</a></li>
<li><a
href="https://b.atch.se/posts/non-constant-constant-expressions/">nonconstant
constant expressions</a></li>
<li><a
href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg%5Factive.html#2118">stateful
metaprogramming via friend injection</a></li>
<li><a
href="https://www.worldcadaccess.com/blog/2020/05/how-to-hack-c-with-templates-and-friends.html">hack
C++ with templates and friends</a></li>
</ul>
<h4 data-number="20" id="access-private-members"><span
class="header-section-number">20</span> <a
href="#access-private-members"># </a>access private members</h4>
<p>See <a href="https://github.com/martong/access_private">this</a> for
more details and explanations. Similar to stateful metaprogramming.</p>
<p>Example <a href="https://github.com/schaumb/access_private_20">from
C++20 version</a>:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="dt">int</span> <span class="va">m_i</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>  <span class="dt">int</span> <span class="va">m_f</span><span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">14</span> <span class="op">*</span> p<span class="op">;</span> <span class="op">}</span></span>
<span id="cb29-4"><a href="#cb29-4"></a><span class="op">};</span></span>
<span id="cb29-5"><a href="#cb29-5"></a></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="kw">template</span> <span class="kw">struct</span> access_private<span class="op">::</span>access<span class="op">&lt;&amp;</span>A<span class="op">::</span><span class="va">m_i</span><span class="op">&gt;;</span></span>
<span id="cb29-7"><a href="#cb29-7"></a></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb29-9"><a href="#cb29-9"></a>  A a<span class="op">;</span></span>
<span id="cb29-10"><a href="#cb29-10"></a>  <span class="kw">auto</span> <span class="op">&amp;</span>i <span class="op">=</span> access_private<span class="op">::</span>accessor<span class="op">&lt;</span><span class="st">&quot;m_i&quot;</span><span class="op">&gt;(</span>a<span class="op">);</span></span>
<span id="cb29-11"><a href="#cb29-11"></a>  <span class="ot">assert</span><span class="op">(</span>i <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb29-12"><a href="#cb29-12"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="21" id="extern-templates"><span
class="header-section-number">21</span> <a href="#extern-templates">#
</a>extern templates</h4>
<p>See, <a
href="https://isocpp.org/wiki/faq/cpp11-language-templates#extern-templates">this</a>
or <a
href="https://en.cppreference.com/w/cpp/language/class_template">cppreference</a>.</p>
<p>Allows to declare some set of template instantiations and actually
intantiate them in another place. Usually, you extern template in the
header and instantiate in <strong>your own</strong>/library .cpp
file:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">// myvector.h</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="kw">class</span> MyVector <span class="op">{</span> <span class="co">/**/</span> <span class="op">};</span></span>
<span id="cb30-4"><a href="#cb30-4"></a></span>
<span id="cb30-5"><a href="#cb30-5"></a><span class="co">// declare frequently used instantiations</span></span>
<span id="cb30-6"><a href="#cb30-6"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb30-8"><a href="#cb30-8"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="co">// myvector.cpp</span></span>
<span id="cb30-11"><a href="#cb30-11"></a><span class="pp">#include </span><span class="im">&quot;myvector.h&quot;</span></span>
<span id="cb30-12"><a href="#cb30-12"></a></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="co">// instantiate frequent cases **once**;</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="co">// client needs to link with myvector.o</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb30-16"><a href="#cb30-16"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;;</span></span></code></pre></div>
<p>C++ had also never implemeted C++98 <a
href="https://en.cppreference.com/w/cpp/keyword/export">export
keyword</a> (C++98, nothing to do with <a
href="https://en.cppreference.com/w/cpp/language/modules">modules</a>).</p>
<h4 data-number="22" id="templates-in-.cpp-file"><span
class="header-section-number">22</span> <a
href="#templates-in-.cpp-file"># </a>templates in .cpp file</h4>
<p>It’s usually stated that templates could only be defined in header
file. However, you just need to define them anywhere so definition is
visible at the point of use/instantiation.</p>
<p>For intance, this works just fine:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="co">// myclass.h</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">class</span> MyClass</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="dt">int</span> Foo<span class="op">();</span></span>
<span id="cb31-6"><a href="#cb31-6"></a></span>
<span id="cb31-7"><a href="#cb31-7"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb31-8"><a href="#cb31-8"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb31-9"><a href="#cb31-9"></a>    <span class="dt">int</span> Bar<span class="op">();</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="op">};</span></span>
<span id="cb31-11"><a href="#cb31-11"></a></span>
<span id="cb31-12"><a href="#cb31-12"></a><span class="co">// myclass.cpp</span></span>
<span id="cb31-13"><a href="#cb31-13"></a><span class="co">// template class, defined in this .cpp file</span></span>
<span id="cb31-14"><a href="#cb31-14"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb31-15"><a href="#cb31-15"></a><span class="kw">struct</span> MyHelper <span class="op">{};</span></span>
<span id="cb31-16"><a href="#cb31-16"></a></span>
<span id="cb31-17"><a href="#cb31-17"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb31-18"><a href="#cb31-18"></a><span class="dt">int</span> MyClass<span class="op">::</span>Bar<span class="op">()</span></span>
<span id="cb31-19"><a href="#cb31-19"></a><span class="op">{</span></span>
<span id="cb31-20"><a href="#cb31-20"></a>    <span class="co">// definition of member-function-template Bar();</span></span>
<span id="cb31-21"><a href="#cb31-21"></a>    <span class="co">// also, the use of MyHelper template above,</span></span>
<span id="cb31-22"><a href="#cb31-22"></a>    <span class="co">// visible only to this transtlation unit</span></span>
<span id="cb31-23"><a href="#cb31-23"></a>    <span class="cf">return</span> <span class="kw">sizeof</span><span class="op">(</span>MyHelper<span class="op">&lt;</span>T<span class="op">&gt;{});</span></span>
<span id="cb31-24"><a href="#cb31-24"></a><span class="op">}</span></span>
<span id="cb31-25"><a href="#cb31-25"></a></span>
<span id="cb31-26"><a href="#cb31-26"></a><span class="dt">int</span> MyClass<span class="op">::</span>Foo<span class="op">()</span></span>
<span id="cb31-27"><a href="#cb31-27"></a><span class="op">{</span></span>
<span id="cb31-28"><a href="#cb31-28"></a>    <span class="co">// use of function template</span></span>
<span id="cb31-29"><a href="#cb31-29"></a>    <span class="cf">return</span> Bar<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;();</span></span>
<span id="cb31-30"><a href="#cb31-30"></a><span class="op">}</span></span></code></pre></div>
<p>See also <a href="#extern-templates">extern templates</a>.</p>
<h4 data-number="23" id="double-template-syntax"><span
class="header-section-number">23</span> <a
href="#double-template-syntax"># </a>double-template syntax</h4>
<p>If you have template class that has template member function and you
want to define such function out-of-class, you need:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1<span class="op">,</span> <span class="kw">typename</span> T2<span class="op">&gt;</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="kw">class</span> MyClass</span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="op">{</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb32-5"><a href="#cb32-5"></a>    <span class="dt">void</span> Foo<span class="op">(</span>U v<span class="op">);</span></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="op">};</span></span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1<span class="op">,</span> <span class="kw">typename</span> T2<span class="op">&gt;</span>  <span class="co">// for MyClass</span></span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span>                <span class="co">// for Foo</span></span>
<span id="cb32-10"><a href="#cb32-10"></a><span class="dt">void</span> MyClass<span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">&gt;::</span>Foo<span class="op">(</span>U v<span class="op">)</span> <span class="op">{}</span></span></code></pre></div>
<h4 data-number="24" id="when-type-t-is-bitcopyable"><span
class="header-section-number">24</span> <a
href="#when-type-t-is-bitcopyable"># </a>when type T is
bitcopyable?</h4>
<p>When implementors do use memcopy/memmove to construct/assign range of
values for some user-defined type T? Use
<code>std::is_trivially_*</code> <a
href="https://en.cppreference.com/w/cpp/meta">type traits</a> to query
the property:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">struct</span> MyType</span>
<span id="cb33-2"><a href="#cb33-2"></a><span class="op">{</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    <span class="dt">char</span> str<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb33-5"><a href="#cb33-5"></a><span class="op">};</span></span>
<span id="cb33-6"><a href="#cb33-6"></a></span>
<span id="cb33-7"><a href="#cb33-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb33-8"><a href="#cb33-8"></a><span class="op">{</span></span>
<span id="cb33-9"><a href="#cb33-9"></a>    MyType v1<span class="op">{</span><span class="dv">42</span><span class="op">};</span></span>
<span id="cb33-10"><a href="#cb33-10"></a>    MyType v2<span class="op">{</span><span class="dv">66</span><span class="op">};</span></span>
<span id="cb33-11"><a href="#cb33-11"></a></span>
<span id="cb33-12"><a href="#cb33-12"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_copy_assignable<span class="op">&lt;</span>MyType<span class="op">&gt;{});</span></span>
<span id="cb33-13"><a href="#cb33-13"></a>    <span class="bu">std::</span>memcpy<span class="op">(&amp;</span>v1<span class="op">,</span> <span class="op">&amp;</span>v2<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>v1<span class="op">));</span> <span class="co">// fine</span></span>
<span id="cb33-14"><a href="#cb33-14"></a>    <span class="ot">assert</span><span class="op">(</span>v1<span class="op">.</span>data <span class="op">==</span> <span class="dv">66</span><span class="op">);</span></span>
<span id="cb33-15"><a href="#cb33-15"></a><span class="op">}</span></span></code></pre></div>
<p>Overall, see also <a
href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">std::uninitialized_*</a>
memory management and <a
href="https://en.cppreference.com/w/cpp/algorithm/copy">std::copy
algorithm</a> and/or analogs that are already optimized for trivial/pod
types by your standard library implementation for you.</p>
<h4 data-number="25" id="pseudo-destructors-int"><span
class="header-section-number">25</span> <a
href="#pseudo-destructors-int"># </a>pseudo destructors (~int)</h4>
<p>In generic context, it’s possible to invoke the destructor of
int:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">using</span> MyInt <span class="op">=</span> <span class="dt">int</span><span class="op">;</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>MyInt v <span class="op">=</span> <span class="dv">86</span><span class="op">;</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>v<span class="op">.~</span>MyInt<span class="op">();</span></span></code></pre></div>
<p>which is no-op. See <a
href="https://en.cppreference.com/w/cpp/language/destructor#Notes">destructor</a>
and <a
href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators">built-in
member access operators</a>. Exists so you don’t need to special-case
destructor call in generic/template code.</p>
<h4 data-number="26" id="manually-invoke-constructor"><span
class="header-section-number">26</span> <a
href="#manually-invoke-constructor"># </a>manually invoke
constructor</h4>
<p>In the same way you can call destructor manually, you can call
constructor:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">alignas</span><span class="op">(</span>T<span class="op">)</span> <span class="dt">unsigned</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)];</span></span>
<span id="cb35-2"><a href="#cb35-2"></a>T<span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span><span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>buffer<span class="op">))</span> T<span class="op">;</span> <span class="co">// call constructor</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>ptr<span class="op">-&gt;~</span>T<span class="op">();</span>                                  <span class="co">// call destructor</span></span></code></pre></div>
<p>which is <a
href="https://en.cppreference.com/w/cpp/lanzguage/new#Placement_new">placement
new</a>.</p>
<p>Note on the use of <code>static_cast&lt;void*&gt;</code> - while not
needed in this example, it’s needed to be done in generic context to
avoid invoking overloaded version of new, if any.</p>
<h4 data-number="27" id="injected-class-name"><span
class="header-section-number">27</span> <a href="#injected-class-name">#
</a>injected-class-name</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/injected-class-name">cppreference</a>.
In short, every class has its own name inside the class itself. Which
happens to apply recursively. This leads to surprising syntax noone
uses:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="op">{</span></span>
<span id="cb36-3"><a href="#cb36-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="dt">void</span> Foo<span class="op">();</span></span>
<span id="cb36-5"><a href="#cb36-5"></a><span class="op">};</span></span>
<span id="cb36-6"><a href="#cb36-6"></a></span>
<span id="cb36-7"><a href="#cb36-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb36-8"><a href="#cb36-8"></a><span class="op">{</span></span>
<span id="cb36-9"><a href="#cb36-9"></a>    MyClass m<span class="op">;</span></span>
<span id="cb36-10"><a href="#cb36-10"></a>    <span class="co">// access m.data</span></span>
<span id="cb36-11"><a href="#cb36-11"></a>    m<span class="op">.</span>MyClass<span class="op">::</span>data <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb36-12"><a href="#cb36-12"></a>    <span class="ot">assert</span><span class="op">(</span>m<span class="op">.</span>data <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb36-13"><a href="#cb36-13"></a>    <span class="co">// now with recursion</span></span>
<span id="cb36-14"><a href="#cb36-14"></a>    m<span class="op">.</span>MyClass<span class="op">::</span>MyClass<span class="op">::</span>MyClass<span class="op">::</span>data <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb36-15"><a href="#cb36-15"></a>    <span class="ot">assert</span><span class="op">(</span>m<span class="op">.</span>data <span class="op">==</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb36-16"><a href="#cb36-16"></a>    <span class="co">// call a member function</span></span>
<span id="cb36-17"><a href="#cb36-17"></a>    MyClass<span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>m<span class="op">;</span></span>
<span id="cb36-18"><a href="#cb36-18"></a>    ptr<span class="op">-&gt;</span>MyClass<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb36-19"><a href="#cb36-19"></a><span class="op">}</span></span></code></pre></div>
<p>For templates, this allows to reference class type without specifying
template arguments.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> A<span class="op">&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="kw">struct</span> MyVector</span>
<span id="cb37-3"><a href="#cb37-3"></a><span class="op">{</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>    <span class="co">// same as Self = MyVector&lt;T, A&gt;</span></span>
<span id="cb37-5"><a href="#cb37-5"></a>    <span class="kw">using</span> Self <span class="op">=</span> MyVector<span class="op">;</span></span>
<span id="cb37-6"><a href="#cb37-6"></a><span class="op">};</span></span></code></pre></div>
<h4 data-number="28" id="invoke-base-virtual-function-directly"><span
class="header-section-number">28</span> <a
href="#invoke-base-virtual-function-directly"># </a>invoke base virtual
function directly</h4>
<p>Given an instance of derived class, one can skip invoking its own
function override and call parent function directly (see <a
href="#injected-class-name">injected-class-name</a>):</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">()</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;MyBase&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb38-5"><a href="#cb38-5"></a><span class="op">};</span></span>
<span id="cb38-6"><a href="#cb38-6"></a></span>
<span id="cb38-7"><a href="#cb38-7"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="op">{</span></span>
<span id="cb38-9"><a href="#cb38-9"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">()</span> <span class="kw">override</span></span>
<span id="cb38-10"><a href="#cb38-10"></a>    <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;MyDerived&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="op">};</span></span>
<span id="cb38-12"><a href="#cb38-12"></a></span>
<span id="cb38-13"><a href="#cb38-13"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb38-14"><a href="#cb38-14"></a><span class="op">{</span></span>
<span id="cb38-15"><a href="#cb38-15"></a>    MyDerived derived<span class="op">;</span></span>
<span id="cb38-16"><a href="#cb38-16"></a>    derived<span class="op">.</span>MyBase<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb38-17"><a href="#cb38-17"></a>    MyDerived<span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>derived<span class="op">;</span></span>
<span id="cb38-18"><a href="#cb38-18"></a>    ptr<span class="op">-&gt;</span>MyBase<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb38-19"><a href="#cb38-19"></a><span class="op">}</span></span></code></pre></div>
<p>This will print <code>MyBase</code> 2 times since we explicitly call
MyBase::Foo().</p>
<h4 data-number="29" id="perfect-construct-with-factory-function"><span
class="header-section-number">29</span> <a
href="#perfect-construct-with-factory-function"># </a>perfect construct
with factory function</h4>
<p>See <code>class rvalue</code> trick discussed <a
href="https://akrzemi1.wordpress.com/2018/05/16/rvalues-redefined/">there</a>;
see same trick discussed in <a
href="https://groups.google.com/a/isocpp.org/g/std-proposals/c/hQ654zTNyiM">guaranteed
copy elision in C++17</a>.</p>
<p>In short, we can return non-copyable/non-movable type from a
function:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="kw">struct</span> Widget</span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>    <span class="kw">explicit</span> Widget<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>    Widget<span class="op">(</span><span class="at">const</span> Widget<span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Widget<span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-6"><a href="#cb39-6"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-7"><a href="#cb39-7"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb39-8"><a href="#cb39-8"></a><span class="op">};</span></span>
<span id="cb39-9"><a href="#cb39-9"></a></span>
<span id="cb39-10"><a href="#cb39-10"></a>Widget MakeWidget<span class="op">()</span></span>
<span id="cb39-11"><a href="#cb39-11"></a><span class="op">{</span></span>
<span id="cb39-12"><a href="#cb39-12"></a>    <span class="cf">return</span> Widget<span class="op">{</span><span class="dv">68</span><span class="op">};</span> <span class="co">// works</span></span>
<span id="cb39-13"><a href="#cb39-13"></a><span class="op">}</span></span>
<span id="cb39-14"><a href="#cb39-14"></a></span>
<span id="cb39-15"><a href="#cb39-15"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb39-16"><a href="#cb39-16"></a><span class="op">{</span></span>
<span id="cb39-17"><a href="#cb39-17"></a>    Widget w <span class="op">=</span> MakeWidget<span class="op">();</span> <span class="co">// works</span></span>
<span id="cb39-18"><a href="#cb39-18"></a><span class="op">}</span></span></code></pre></div>
<p>However, how to construct, let say
<code>std::optional&lt;Widget&gt;</code>? That does not work:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o1<span class="op">{</span>MakeWidget<span class="op">()};</span> <span class="co">// does not compile</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o2<span class="op">;</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>    o2<span class="op">.</span>emplace<span class="op">(</span>MakeWidget<span class="op">());</span> <span class="co">// does not compile</span></span>
<span id="cb40-6"><a href="#cb40-6"></a><span class="op">}</span></span></code></pre></div>
<p>The trick is to use any type that has <a
href="https://en.cppreference.com/w/cpp/language/cast_operator">implicit
conversion operator</a>:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">struct</span> WidgetFactory</span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="op">{</span></span>
<span id="cb41-3"><a href="#cb41-3"></a>    <span class="kw">operator</span> Widget<span class="op">()</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>    <span class="op">{</span></span>
<span id="cb41-5"><a href="#cb41-5"></a>        <span class="cf">return</span> MakeWidget<span class="op">();</span></span>
<span id="cb41-6"><a href="#cb41-6"></a>    <span class="op">}</span></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="op">};</span></span>
<span id="cb41-8"><a href="#cb41-8"></a></span>
<span id="cb41-9"><a href="#cb41-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="op">{</span></span>
<span id="cb41-11"><a href="#cb41-11"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o<span class="op">;</span></span>
<span id="cb41-12"><a href="#cb41-12"></a>    o<span class="op">.</span>emplace<span class="op">(</span>WidgetFactory<span class="op">{});</span> <span class="co">// works</span></span>
<span id="cb41-13"><a href="#cb41-13"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="30" id="disable-template-argument-deduction"><span
class="header-section-number">30</span> <a
href="#disable-template-argument-deduction"># </a>disable template
argument deduction</h4>
<p>See, for instance, <a
href="https://devblogs.microsoft.com/oldnewthing/20240607-00/?p=109865">What’s
the deal with std::type_identity?</a> or <a
href="https://artificial-mind.net/blog/2020/09/26/dont-deduce">dont_deduce&lt;T&gt;</a>.
In short, this will not compile:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="dt">void</span> Process<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span>T<span class="op">)&gt;</span> f<span class="op">,</span> T v<span class="op">)</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    f<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="op">}</span></span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="op">{</span></span>
<span id="cb42-9"><a href="#cb42-9"></a>    Process<span class="op">([](</span><span class="dt">int</span><span class="op">)</span> <span class="op">{},</span> <span class="dv">64</span><span class="op">);</span></span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="op">}</span></span></code></pre></div>
<p>We try to pass a lambda that has unique type X which has nothing to
do with <code>std::function&lt;void (T)&gt;</code>. Compiler does not
know how to deduce T from X.</p>
<p>Here, we want to ask compiler to not deduce anything for parameter
<code>f</code>:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="dt">void</span> Process<span class="op">(</span><span class="bu">std::</span>type_identity_t<span class="op">&lt;</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span>T<span class="op">)&gt;&gt;</span> f<span class="op">,</span> T v<span class="op">)</span></span>
<span id="cb43-3"><a href="#cb43-3"></a><span class="op">{</span></span>
<span id="cb43-4"><a href="#cb43-4"></a>    f<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="op">}</span></span>
<span id="cb43-6"><a href="#cb43-6"></a></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="op">{</span></span>
<span id="cb43-9"><a href="#cb43-9"></a>    Process<span class="op">([](</span><span class="dt">int</span><span class="op">){},</span> <span class="dv">64</span><span class="op">);</span></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="op">}</span></span></code></pre></div>
<p>T is deduced from 2nd argument, std::function is constructed from a
given lamda as it is.</p>
<h4 data-number="31" id="priority_tag-for-tag-dispatch"><span
class="header-section-number">31</span> <a
href="#priority_tag-for-tag-dispatch"># </a>priority_tag for tag
dispatch</h4>
<p>From <a
href="https://quuxplusone.github.io/blog/2021/07/09/priority-tag/">priority_tag
for ad-hoc tag dispatch</a> and <a
href="https://youtu.be/ybaE9qlhHvw?t=56m36s">CppCon 2017: Arthur O’Dwyer
“A Soupcon of SFINAE”</a>.</p>
<p>Here, we convert x to string trying first <code>x.stringify()</code>
if that exists, otherwise <code>std::to_string(x)</code> if that works
and finally fallback to ostringstream as a final resort:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb44-3"><a href="#cb44-3"></a></span>
<span id="cb44-4"><a href="#cb44-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">unsigned</span> I<span class="op">&gt;</span> <span class="kw">struct</span> priority_tag <span class="op">:</span> priority_tag<span class="op">&lt;</span>I <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb44-5"><a href="#cb44-5"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> priority_tag<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb44-6"><a href="#cb44-6"></a></span>
<span id="cb44-7"><a href="#cb44-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-8"><a href="#cb44-8"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;)</span></span>
<span id="cb44-9"><a href="#cb44-9"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>x<span class="op">.</span>stringify<span class="op">())</span></span>
<span id="cb44-10"><a href="#cb44-10"></a><span class="op">{</span></span>
<span id="cb44-11"><a href="#cb44-11"></a>    <span class="cf">return</span> x<span class="op">.</span>stringify<span class="op">();</span></span>
<span id="cb44-12"><a href="#cb44-12"></a><span class="op">}</span></span>
<span id="cb44-13"><a href="#cb44-13"></a></span>
<span id="cb44-14"><a href="#cb44-14"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-15"><a href="#cb44-15"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;)</span></span>
<span id="cb44-16"><a href="#cb44-16"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">))</span></span>
<span id="cb44-17"><a href="#cb44-17"></a><span class="op">{</span></span>
<span id="cb44-18"><a href="#cb44-18"></a>    <span class="cf">return</span> <span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb44-19"><a href="#cb44-19"></a><span class="op">}</span></span>
<span id="cb44-20"><a href="#cb44-20"></a></span>
<span id="cb44-21"><a href="#cb44-21"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-22"><a href="#cb44-22"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;)</span></span>
<span id="cb44-23"><a href="#cb44-23"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;()</span> <span class="op">&lt;&lt;</span> x<span class="op">).</span>str<span class="op">())</span></span>
<span id="cb44-24"><a href="#cb44-24"></a><span class="op">{</span></span>
<span id="cb44-25"><a href="#cb44-25"></a>    <span class="bu">std::</span>ostringstream s<span class="op">;</span></span>
<span id="cb44-26"><a href="#cb44-26"></a>    s <span class="op">&lt;&lt;</span> x<span class="op">;</span></span>
<span id="cb44-27"><a href="#cb44-27"></a>    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>s<span class="op">).</span>str<span class="op">();</span></span>
<span id="cb44-28"><a href="#cb44-28"></a><span class="op">}</span></span>
<span id="cb44-29"><a href="#cb44-29"></a></span>
<span id="cb44-30"><a href="#cb44-30"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb44-31"><a href="#cb44-31"></a><span class="kw">auto</span> stringify<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="cb44-32"><a href="#cb44-32"></a><span class="op">{</span></span>
<span id="cb44-33"><a href="#cb44-33"></a>    <span class="cf">return</span> stringify_impl<span class="op">(</span>x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;());</span></span>
<span id="cb44-34"><a href="#cb44-34"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="32" id="new-auto10"><span
class="header-section-number">32</span> <a href="#new-auto10"># </a>new
auto(10)</h4>
<p>You can leave type dedcution to the compiler when using new:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="kw">auto</span> ptr1 <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// works -&gt; int*</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="dt">int</span><span class="op">*</span> ptr2 <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// works</span></span></code></pre></div>
<p>From <a
href="https://en.cppreference.com/w/cpp/language/new">cppreference</a>:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="dt">double</span><span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// creates an array of type double[3]</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="kw">auto</span> p <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="ch">&#39;c&#39;</span><span class="op">);</span>             <span class="co">// creates a single object of type char. p is a char*</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="kw">auto</span> q <span class="op">=</span> <span class="kw">new</span> <span class="bu">std::</span>integral <span class="kw">auto</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="co">// OK: q is an int*</span></span>
<span id="cb46-4"><a href="#cb46-4"></a><span class="kw">auto</span> r <span class="op">=</span> <span class="kw">new</span> <span class="bu">std::</span>pair<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">);</span>    <span class="co">// OK: r is a std::pair&lt;int, bool&gt;*</span></span></code></pre></div>
<h4 data-number="33" id="stdforward-use-in-stdfunction-like-case"><span
class="header-section-number">33</span> <a
href="#stdforward-use-in-stdfunction-like-case">#
</a><code>std::forward</code> use in std::function-like case</h4>
<p>Most of the times, we say that std::forward should be used in the
context of forwarding references that, <em>usually</em>, look like
this:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="dt">void</span> Process<span class="op">(</span>T<span class="op">&amp;&amp;</span> v<span class="op">)</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>    Handle<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>v<span class="op">));</span></span>
<span id="cb47-5"><a href="#cb47-5"></a><span class="op">}</span></span></code></pre></div>
<p>v is <a
href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">forwarding
reference</a> specifically because T&amp;&amp; is used and T
<strong>is</strong> template parameter of Process function template.</p>
<p>However, classic example would be std::function call operator()
implementation:</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Ret<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="kw">class</span> function<span class="op">&lt;</span>Ret <span class="op">(</span>Types<span class="op">...)&gt;</span></span>
<span id="cb48-3"><a href="#cb48-3"></a><span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>    Ret <span class="kw">operator</span><span class="op">()(</span>Types<span class="op">...</span> Args<span class="op">)</span> <span class="at">const</span></span>
<span id="cb48-5"><a href="#cb48-5"></a>    <span class="op">{</span></span>
<span id="cb48-6"><a href="#cb48-6"></a>        <span class="cf">return</span> Do_call<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Types<span class="op">&gt;(</span>Args<span class="op">)...);</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>    <span class="op">}</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="op">};</span></span>
<span id="cb48-9"><a href="#cb48-9"></a></span>
<span id="cb48-10"><a href="#cb48-10"></a><span class="co">// usage</span></span>
<span id="cb48-11"><a href="#cb48-11"></a>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;,</span> <span class="dt">char</span><span class="op">)&gt;</span> f<span class="op">;</span> <span class="co">// (1)</span></span>
<span id="cb48-12"><a href="#cb48-12"></a>f<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="ch">&#39;x&#39;</span><span class="op">);</span>                     <span class="co">// (2)</span></span></code></pre></div>
<p>where user specifies <code>Types</code> at (1) that has nothing to do
with <code>operator()</code> call at (2) which is not even a function
template now.</p>
<p>If you run <a
href="https://en.cppreference.com/w/cpp/language/reference">reference
collapsing</a> rules over possible <code>Types</code> and
<code>Args</code>, <code>std::forward</code> is just right.</p>
<h4 data-number="34" id="virtual-functions-default-arguments"><span
class="header-section-number">34</span> <a
href="#virtual-functions-default-arguments"># </a>virtual functions
default arguments</h4>
<p>See <a href="http://www.gotw.ca/gotw/005.htm">GotW #5, Overriding
Virtual Functions</a>:</p>
<blockquote>
<p>Never change the default parameters of overridden inherited
functions</p>
</blockquote>
<p>Going more strict: don’t have virtual functions with default
arguments.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">34</span><span class="op">);</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="op">};</span></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="op">{</span></span>
<span id="cb49-7"><a href="#cb49-7"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">43</span><span class="op">);</span></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="op">};</span></span>
<span id="cb49-9"><a href="#cb49-9"></a>MyBase<span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span> MyDerived<span class="op">;</span></span>
<span id="cb49-10"><a href="#cb49-10"></a>ptr<span class="op">-&gt;</span>Foo<span class="op">();</span> <span class="co">// calls MyDerived::Foo, but with v = 34 from MyBase</span></span></code></pre></div>
<p>default arguments are resolved at compile time, override function
target - at run-time; may lead to confusion.</p>
<h4 data-number="35" id="virtual-functions-overloads"><span
class="header-section-number">35</span> <a
href="#virtual-functions-overloads"># </a>virtual functions
overloads</h4>
<p>See <a href="http://www.gotw.ca/gotw/005.htm">GotW #5, Overriding
Virtual Functions</a>:</p>
<blockquote>
<p>When providing a function with the same name as an inherited
function, be sure to bring the inherited functions into scope with a
“using” declaration if you don’t want to hide them</p>
</blockquote>
<p>Going more strict: avoid providing overloads to virtual
functions.<br />
For modern C++: use <a
href="https://en.cppreference.com/w/cpp/language/override">override
specifier</a>.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">char</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb50-4"><a href="#cb50-4"></a><span class="op">};</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb50-6"><a href="#cb50-6"></a><span class="op">{</span></span>
<span id="cb50-7"><a href="#cb50-7"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb50-8"><a href="#cb50-8"></a><span class="op">};</span></span>
<span id="cb50-9"><a href="#cb50-9"></a></span>
<span id="cb50-10"><a href="#cb50-10"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb50-11"><a href="#cb50-11"></a><span class="op">{</span></span>
<span id="cb50-12"><a href="#cb50-12"></a>    MyDerived derived<span class="op">;</span></span>
<span id="cb50-13"><a href="#cb50-13"></a>    <span class="cf">return</span> derived<span class="op">.</span>Foo<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">);</span></span>
<span id="cb50-14"><a href="#cb50-14"></a><span class="op">}</span></span></code></pre></div>
<p>main is going to return 2 since <code>MyDerived::Foo(int)</code> is
used. To use <code>MyBase::Foo(char)</code>:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3"></a>    <span class="kw">using</span> MyBase<span class="op">::</span>Foo<span class="op">;</span> <span class="co">// add char overload</span></span>
<span id="cb51-4"><a href="#cb51-4"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="op">};</span></span></code></pre></div>
<p>Note: bringing base class method with using declation is,
potentially, a breaking change (see above, <code>derived.Foo('x')</code>
now returns 1 instead of 2).</p>
<h4 data-number="36" id="change-base-class-member-access-rights"><span
class="header-section-number">36</span> <a
href="#change-base-class-member-access-rights"># </a>change base class
member access rights</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/using_declaration">Using-declaration</a>.
You can make protected member to be public in derived class:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb52-5"><a href="#cb52-5"></a><span class="op">};</span></span>
<span id="cb52-6"><a href="#cb52-6"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb52-7"><a href="#cb52-7"></a><span class="op">{</span></span>
<span id="cb52-8"><a href="#cb52-8"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb52-9"><a href="#cb52-9"></a>    <span class="kw">using</span> MyBase<span class="op">::</span>data<span class="op">;</span> <span class="co">// make data public now</span></span>
<span id="cb52-10"><a href="#cb52-10"></a><span class="op">};</span></span></code></pre></div>
<h4 data-number="37" id="use-default-constructor-for-state-reset"><span
class="header-section-number">37</span> <a
href="#use-default-constructor-for-state-reset"># </a>use default
constructor for state reset</h4>
<p>It’s observed that, often, class API has .Reset() function (even more
often when two phase initialization is used):</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="op">{</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb53-4"><a href="#cb53-4"></a>    <span class="co">// ...</span></span>
<span id="cb53-5"><a href="#cb53-5"></a>    <span class="dt">void</span> Reset<span class="op">()</span> <span class="op">{</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb53-6"><a href="#cb53-6"></a><span class="op">};</span></span></code></pre></div>
<p>If your API is anything close to modern C++ and supports <a
href="https://youtu.be/G9MxNwUoSt0?si=qbFFjdXYKT58ZThN">value
semantics</a>, just have move assignment implemented with default
constructor, which leads to:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a>MyClass instance<span class="op">;</span></span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="co">// ...</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>instance <span class="op">=</span> MyClass<span class="op">{};</span> <span class="co">// same as .Reset()</span></span></code></pre></div>
<p>See also “default constructor is a must for modern C++”</p>
<h4 data-number="38"
id="default-constructor-is-a-must-for-modern-c"><span
class="header-section-number">38</span> <a
href="#default-constructor-is-a-must-for-modern-c"># </a>default
constructor is a must for modern C++</h4>
<p>What happens with the object after the move? The known answer for C++
library types is that it’s in <a
href="https://en.cppreference.com/w/cpp/utility/move">“valid but
unspecified state”</a>. Note, that for most cases in practice, the
object is in empty/null state (see <a
href="https://gist.github.com/sean-parent/fed31bee69bc41d888f84f25743da9f1">Sean
Parent comments</a>) or, to say it another way - you should put the
object into empty state and be nice.</p>
<p>Why it’s in “empty” state? Simply because destructor still runs after
the move and we need to know whether or not it’s needed to free
resources <strong>most of the times</strong>:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="kw">struct</span> MyFile</span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="op">{</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>    <span class="dt">int</span> handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-4"><a href="#cb55-4"></a>    <span class="co">// ...</span></span>
<span id="cb55-5"><a href="#cb55-5"></a>    <span class="op">~</span>MyFile<span class="op">()</span></span>
<span id="cb55-6"><a href="#cb55-6"></a>    <span class="op">{</span></span>
<span id="cb55-7"><a href="#cb55-7"></a>        <span class="cf">if</span> <span class="op">(</span>handle <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb55-8"><a href="#cb55-8"></a>        <span class="op">{</span></span>
<span id="cb55-9"><a href="#cb55-9"></a>            <span class="op">::</span>close<span class="op">(</span>handle<span class="op">);</span></span>
<span id="cb55-10"><a href="#cb55-10"></a>            handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-11"><a href="#cb55-11"></a>        <span class="op">}</span></span>
<span id="cb55-12"><a href="#cb55-12"></a>    <span class="op">}</span></span>
<span id="cb55-13"><a href="#cb55-13"></a>    MyFile<span class="op">(</span>MyFile<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb55-14"><a href="#cb55-14"></a>        <span class="op">:</span> handle<span class="op">(</span>rhs<span class="op">.</span>handle<span class="op">)</span></span>
<span id="cb55-15"><a href="#cb55-15"></a>    <span class="op">{</span></span>
<span id="cb55-16"><a href="#cb55-16"></a>        rhs<span class="op">.</span>handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// take ownership</span></span>
<span id="cb55-17"><a href="#cb55-17"></a>    <span class="op">}</span></span>
<span id="cb55-18"><a href="#cb55-18"></a><span class="op">}</span></span></code></pre></div>
<p>For a user or even class author, it’s also often needed to check if
the object was not moved to ensure correct use:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a><span class="dt">void</span> MyFile<span class="op">::</span>Read<span class="op">(...)</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="op">{</span></span>
<span id="cb56-3"><a href="#cb56-3"></a>    <span class="ot">assert</span><span class="op">(</span>handle <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// hidden/implicit is_valid check</span></span>
<span id="cb56-4"><a href="#cb56-4"></a><span class="op">}</span></span></code></pre></div>
<p>Now, should the class expose <code>is_valid()</code> API? Maybe,
maybe not; up to you. More elegant solution that requires smaller amount
of exposed APIs could be just a pair of default construction and
<code>operator==</code>:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a>MyFile file <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb57-2"><a href="#cb57-2"></a><span class="cf">if</span> <span class="op">(</span>file <span class="op">==</span> MyFile<span class="op">{})</span></span>
<span id="cb57-3"><a href="#cb57-3"></a>    <span class="co">// empty, was moved from, can&#39;t invoke Read().</span></span></code></pre></div>
<p>Leaving validity check alone, any time you support move, just expose
such state with default constructor. More often then not it makes life
easier. See also “state reset”.</p>
<p>Relative: <a
href="https://www.foonathan.net/2016/08/move-default-ctor/">Move
Semantics and Default Constructors – Rule of Six?</a>.</p>
<h4 data-number="39" id="default-constructor-must-do-no-work"><span
class="header-section-number">39</span> <a
href="#default-constructor-must-do-no-work"># </a>default constructor
must do no work</h4>
<p>Default constructor may be used as a fallback in a few places of
STL/your code:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>MyData<span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>v<span class="op">.</span>resize<span class="op">(</span><span class="dv">1&#39;000</span><span class="op">);</span> <span class="co">// insert 1&#39;000 default-constructed MyData elements</span></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyData<span class="op">&gt;</span> m<span class="op">;</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>m<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> MyData<span class="op">{</span><span class="dv">98</span><span class="op">};</span> <span class="co">// default construct MyData, then reassign</span></span>
<span id="cb58-5"><a href="#cb58-5"></a><span class="bu">std::</span>variant<span class="op">&lt;</span>MyData<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span> <span class="co">// default construct MyData</span></span></code></pre></div>
<p>Following C++ value semantic, move semantic with its empty state, it
may also be used to reset state or check whether or not the instance is
valid:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ptr <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb59-2"><a href="#cb59-2"></a>ptr <span class="op">=</span> <span class="op">{};</span> <span class="co">// reset, set to nullptr</span></span></code></pre></div>
<p>Default constructor should contain nothing except default/trivial
data member initialization. Specifically, no memory allocations, no side
effects.</p>
<p>Bonus question: why does this code allocates under MSVC debug?</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1"></a><span class="bu">std::</span>string s<span class="op">;</span> <span class="co">// ?</span></span></code></pre></div>
<p>Hint: MSVC STL debug iterators machinery.</p>
<h4 data-number="40" id="constructors-should-do-no-work"><span
class="header-section-number">40</span> <a
href="#constructors-should-do-no-work"># </a>constructors should do no
work</h4>
<p>Constructors (at least of objects for types that are part of your
applicaiton domain) should just assign/default initialize data members,
NO business/application logic inside. This applies to copy constructor,
constructors with parameters, move constructor.</p>
<p>Simply because you don’t control when and who and how can invoke
and/or ignore/skip your constructor invocation. See, for instance, (but
not only) <a
href="https://en.cppreference.com/w/cpp/language/copy_elision">Copy
elision/RVO/NRVO/URVO</a>.</p>
<p>But what about RAII? How to make RAII classes then?</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">struct</span> MyFile</span>
<span id="cb61-2"><a href="#cb61-2"></a><span class="op">{</span></span>
<span id="cb61-3"><a href="#cb61-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb61-4"><a href="#cb61-4"></a>    <span class="kw">using</span> FileHandle <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb61-5"><a href="#cb61-5"></a></span>
<span id="cb61-6"><a href="#cb61-6"></a>    <span class="at">static</span> Open<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name<span class="op">)</span></span>
<span id="cb61-7"><a href="#cb61-7"></a>    <span class="op">{</span></span>
<span id="cb61-8"><a href="#cb61-8"></a>        FileHandle handle <span class="op">=</span> <span class="op">::</span>open<span class="op">(</span>file_name<span class="op">);</span> <span class="co">// imaginary system API</span></span>
<span id="cb61-9"><a href="#cb61-9"></a>        <span class="cf">return</span> MyFile<span class="op">{</span>handle<span class="op">};</span></span>
<span id="cb61-10"><a href="#cb61-10"></a>    <span class="op">}</span></span>
<span id="cb61-11"><a href="#cb61-11"></a></span>
<span id="cb61-12"><a href="#cb61-12"></a>    <span class="kw">explicit</span> MyFile<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb61-13"><a href="#cb61-13"></a>    <span class="op">~</span>MyFile<span class="op">();</span> <span class="co">// ...</span></span>
<span id="cb61-14"><a href="#cb61-14"></a></span>
<span id="cb61-15"><a href="#cb61-15"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb61-16"><a href="#cb61-16"></a>    <span class="kw">explicit</span> MyFile<span class="op">(</span>FileHandle handle<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb61-17"><a href="#cb61-17"></a>        <span class="op">:</span> file_handle<span class="op">{</span>handle<span class="op">}</span></span>
<span id="cb61-18"><a href="#cb61-18"></a>    <span class="op">{</span></span>
<span id="cb61-19"><a href="#cb61-19"></a>    <span class="op">}</span></span>
<span id="cb61-20"><a href="#cb61-20"></a>    FileHandle file_handle<span class="op">{};</span></span>
<span id="cb61-21"><a href="#cb61-21"></a><span class="op">};</span></span></code></pre></div>
<p>Isn’t this makes sense only when exceptions are disabled? Not sure
exceptions change anything there.</p>
<p>Sometimes I even leave <code>MyFile(FileHandle handle)</code>-like
constructors public. This makes API extremely hackable and testable.</p>
<h4 data-number="41" id="stdunique_ptr-with-decltype-lambda"><span
class="header-section-number">41</span> <a
href="#stdunique_ptr-with-decltype-lambda">#
</a><code>std::unique_ptr</code> with decltype lambda</h4>
<p>Since C++20, with <a
href="https://andreasfertig.blog/2022/08/cpp-insights-lambdas-in-unevaluated-contexts/">Lambdas
in unevaluated contexts</a>, you can have poor man’s scope exit as a
side effect:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">using</span> on_exit <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="at">const</span> <span class="dt">char</span><span class="op">,</span></span>
<span id="cb62-2"><a href="#cb62-2"></a>    <span class="kw">decltype</span><span class="op">([](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> msg<span class="op">)</span> <span class="op">{</span> puts<span class="op">(</span>msg<span class="op">);</span> <span class="op">})&gt;;</span></span>
<span id="cb62-3"><a href="#cb62-3"></a></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="dt">void</span> Foo<span class="op">()</span></span>
<span id="cb62-5"><a href="#cb62-5"></a><span class="op">{</span></span>
<span id="cb62-6"><a href="#cb62-6"></a>    on_exit msg<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">);</span></span>
<span id="cb62-7"><a href="#cb62-7"></a><span class="op">}</span> <span class="co">// prints Foo on scope exit</span></span></code></pre></div>
<p>from <a
href="https://youtu.be/O2G3bwNP5p4?si=_2yfyq9BEoxF3etB">Creating a
Sender/Receiver HTTP Server for Asynchronous Operations in C++</a>.</p>
<h4 data-number="42" id="auto-vs-auto-for-pointers"><span
class="header-section-number">42</span> <a
href="#auto-vs-auto-for-pointers"># </a><code>auto</code> vs
<code>auto*</code> for pointers</h4>
<p>Since auto type deduction comes from <a
href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts">template
argument deduction</a>, it’s fine to have <code>auto*</code> in the same
way it’s fine to have <code>T*</code> as a template parameter:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="kw">auto</span>  p1 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>        <span class="co">// p1 = int*</span></span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="kw">auto</span><span class="op">*</span> p2 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>        <span class="co">// p2 = int*</span></span>
<span id="cb63-3"><a href="#cb63-3"></a><span class="at">const</span> <span class="kw">auto</span>  p3 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>  <span class="co">// p3 = int* const</span></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">*</span> p4 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>  <span class="co">// p4 = const int*</span></span></code></pre></div>
<p>Still, note the difference for p3 vs p4 - const pointer to int vs
just pointer to const int!</p>
<h4 data-number="43"
id="stdtransform-and-lift-passing-overload-set"><span
class="header-section-number">43</span> <a
href="#stdtransform-and-lift-passing-overload-set"># </a>std::transform
and LIFT (passing overload set)</h4>
<p>See <a
href="https://blog.tartanllama.xyz/passing-overload-sets/">Passing
overload sets to functions</a>:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="pp">#define FWD</span><span class="op">(...)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="pp">    </span><span class="bu">std::</span>forward<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="ot">__VA_ARGS__</span><span class="op">)&gt;(</span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span>
<span id="cb64-3"><a href="#cb64-3"></a></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="pp">#define LIFT</span><span class="op">(</span>X<span class="op">)</span><span class="pp"> </span><span class="op">[](</span><span class="kw">auto</span><span class="pp"> </span><span class="op">&amp;&amp;...</span><span class="pp"> </span>args<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb64-5"><a href="#cb64-5"></a><span class="pp">    </span><span class="kw">noexcept</span><span class="op">(</span><span class="kw">noexcept</span><span class="op">(</span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...)))</span><span class="pp">  </span><span class="op">\</span></span>
<span id="cb64-6"><a href="#cb64-6"></a><span class="pp">    </span><span class="op">-&gt;</span><span class="pp"> </span><span class="kw">decltype</span><span class="op">(</span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...))</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb64-7"><a href="#cb64-7"></a><span class="op">{</span><span class="pp">  </span><span class="op">\</span></span>
<span id="cb64-8"><a href="#cb64-8"></a><span class="pp">    </span><span class="cf">return</span><span class="pp"> </span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb64-9"><a href="#cb64-9"></a><span class="op">}</span></span>
<span id="cb64-10"><a href="#cb64-10"></a></span>
<span id="cb64-11"><a href="#cb64-11"></a><span class="co">// ...</span></span>
<span id="cb64-12"><a href="#cb64-12"></a><span class="bu">std::</span>transform<span class="op">(</span>first<span class="op">,</span> last<span class="op">,</span> target<span class="op">,</span> LIFT<span class="op">(</span>foo<span class="op">));</span></span></code></pre></div>
<h4 data-number="44" id="tolower-is-not-an-addressible-function"><span
class="header-section-number">44</span> <a
href="#tolower-is-not-an-addressible-function">#
</a><code>tolower</code> is not an addressible function</h4>
<p>You can’t take an adress of std:: function since function could be
implemented differently with different STL(s) and/or in the feature the
function may change, hence such code is not portable. From <a
href="https://devblogs.microsoft.com/oldnewthing/20241007-00/?p=110345">A
popular but wrong way to convert a string to uppercase or
lowercase</a>:</p>
<blockquote>
<p>The standard imposes this limitation because the implementation may
need to add default function parameters, template default parameters, or
overloads in order to accomplish the various requirements of the
standard.</p>
</blockquote>
<p>So, strictly speaking, ignoring facts from the article, this is not
portable C++:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1"></a><span class="bu">std::</span>wstring name<span class="op">;</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="bu">std::</span>transform<span class="op">(</span>name<span class="op">.</span>begin<span class="op">(),</span> name<span class="op">.</span>end<span class="op">(),</span> name<span class="op">.</span>begin<span class="op">(),</span></span>
<span id="cb65-3"><a href="#cb65-3"></a>    <span class="bu">std::</span>tolower<span class="op">);</span></span></code></pre></div>
<h4 data-number="45"
id="replace-operator-new-to-track-third-party-code-allocations"><span
class="header-section-number">45</span> <a
href="#replace-operator-new-to-track-third-party-code-allocations">#
</a>replace operator new to track third-party code allocations</h4>
<p><code>operator new</code>/<code>operator delete</code> can have <a
href="https://en.cppreference.com/w/cpp/memory/new/operator_new#Global_replacements">global
replacement</a>. Usually used to actually inject custom memory
allocator, but also is used for tracking/profiling purpose. And can be
used for debugging:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1"></a><span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span><span class="bu">std::</span>size_t size<span class="op">)</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="op">{</span></span>
<span id="cb66-3"><a href="#cb66-3"></a>    <span class="cf">return</span> malloc<span class="op">(</span>size<span class="op">);</span> <span class="co">// assume size &gt; 0</span></span>
<span id="cb66-4"><a href="#cb66-4"></a><span class="op">}</span></span>
<span id="cb66-5"><a href="#cb66-5"></a><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span><span class="dt">void</span><span class="op">*</span> ptr<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb66-6"><a href="#cb66-6"></a><span class="op">{</span></span>
<span id="cb66-7"><a href="#cb66-7"></a>    free<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb66-8"><a href="#cb66-8"></a><span class="op">}</span></span>
<span id="cb66-9"><a href="#cb66-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb66-10"><a href="#cb66-10"></a><span class="op">{</span></span>
<span id="cb66-11"><a href="#cb66-11"></a>    <span class="bu">std::</span>string s<span class="op">{</span><span class="st">&quot;does it allocate for this input?&quot;</span><span class="op">};</span></span>
<span id="cb66-12"><a href="#cb66-12"></a>    <span class="co">// ...</span></span>
<span id="cb66-13"><a href="#cb66-13"></a><span class="op">}</span></span></code></pre></div>
<p>Just put a breakpoint inside your version of new/delete; observe
callstack and all the useful context.</p>
<p>Hint: same can be done with, let say, WinAPI - use <a
href="https://github.com/microsoft/Detours">Detours</a>.</p>
<h4 data-number="46" id="stdshared_ptrvoid-as-user-data-pointer"><span
class="header-section-number">46</span> <a
href="#stdshared_ptrvoid-as-user-data-pointer">#
</a><code>std::shared_ptr&lt;void&gt;</code> as user-data pointer</h4>
<p><code>std::shared_ptr&lt;void&gt;</code> holds <code>void*</code>
pointer, but also has <a
href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">type-erased</a>
destroy function that remembers the actual type it was created with, so
this is fine:</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span>   ptr1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyData<span class="op">&gt;();</span>             <span class="co">// ok</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyData<span class="op">&gt;</span> ptr2 <span class="op">=</span> <span class="bu">std::</span>static_pointer_cast<span class="op">&lt;</span>MyData<span class="op">&gt;(</span>ptr1<span class="op">);</span> <span class="co">// ok</span></span></code></pre></div>
<p>See <a
href="https://stackoverflow.com/questions/5913396/why-do-stdshared-ptrvoid-work">Why
do std::shared_ptr<void> work</a> and <a
href="https://www.nextptr.com/tutorial/ta1227747841/the-stdshared_ptrvoid-as-arbitrary-userdata-pointer">The
std::shared_ptr as arbitrary user-data pointer</a>.</p>
<h4 data-number="47" id="sync_with_stdio-for-stdout-vs-stdcout"><span
class="header-section-number">47</span> <a
href="#sync_with_stdio-for-stdout-vs-stdcout"># </a>sync_with_stdio for
stdout vs std::cout</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio">sync_with_stdio</a>.</p>
<blockquote>
<p>In practice, this means that the synchronized C++ streams are
unbuffered, and each I/O operation on a C++ stream is immediately
applied to the corresponding C stream’s buffer. This makes it possible
to freely mix C++ and C I/O.</p>
</blockquote>
<blockquote>
<p>In addition, synchronized C++ streams are guaranteed to be
thread-safe (individual characters output from multiple threads may
interleave, but no data races occur).</p>
</blockquote>
<div class="sourceCode" id="cb68"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1"></a><span class="bu">std::</span>ios::sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="bu">std::</span>printf<span class="op">(</span><span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="co">// may be output before &#39;a&#39; above</span></span>
<span id="cb68-4"><a href="#cb68-4"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;c</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Note: not the same as <a
href="https://en.cppreference.com/w/cpp/io/basic_osyncstream">syncstream/C++20</a>.</p>
<p>See also <code>cin.tie(nullptr)</code>.</p>
<h4 data-number="48" id="stdclog-vs-stdcerr"><span
class="header-section-number">48</span> <a href="#stdclog-vs-stdcerr">#
</a>std::clog vs std::cerr</h4>
<p><a href="https://en.cppreference.com/w/cpp/io/clog">clog</a>
cppreference and <a
href="https://en.cppreference.com/w/cpp/io/cerr">cerr</a>. Associated
with the standard C error output stream <code>stderr</code> (same as
cerr), but:</p>
<blockquote>
<p>Output to stderr via std::cerr flushes out the pending output on
std::cout, while output to stderr via std::clog does not.</p>
</blockquote>
<div class="sourceCode" id="cb69"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;aaaaa</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb69-2"><a href="#cb69-2"></a><span class="bu">std::</span>clog <span class="op">&lt;&lt;</span> <span class="st">&quot;bbbbb</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// may not flush &quot;aaaaa&quot;</span></span>
<span id="cb69-3"><a href="#cb69-3"></a><span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;ccccc</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// flush &quot;aaaaa&quot;</span></span></code></pre></div>
<h4 data-number="49"
id="capture-less-lambda-can-be-converted-to-c-function"><span
class="header-section-number">49</span> <a
href="#capture-less-lambda-can-be-converted-to-c-function">#
</a>capture-less lambda can be converted to c-function</h4>
<div class="sourceCode" id="cb70"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> Handle<span class="op">(</span><span class="dt">void</span> <span class="op">(*</span>MyCallback<span class="op">)(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb70-2"><a href="#cb70-2"></a></span>
<span id="cb70-3"><a href="#cb70-3"></a>Handle<span class="op">([](</span><span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> V<span class="op">);</span> <span class="op">});</span> <span class="co">// pass to C-function</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="dt">void</span> <span class="op">(*</span>MyFunction<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span><span class="op">)</span> <span class="op">{};</span>         <span class="co">// convert to C-function</span></span></code></pre></div>
<p>In case lambda has empty capture list (and no deducing this is used),
it can be converted to c-style function pointer (has conversion
operator). See <a
href="https://en.cppreference.com/w/cpp/language/lambda">lambda</a>.</p>
<h4 data-number="50" id="to-convert-lambda-to-c-function"><span
class="header-section-number">50</span> <a
href="#to-convert-lambda-to-c-function"># </a><code>+[](){}</code> to
convert lambda to c-function</h4>
<p>See <a
href="https://stackoverflow.com/questions/18889028/a-positive-lambda-what-sorcery-is-this">A
positive lambda: ‘+<span></span>’ - What sorcery is this?</a>:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb71-2"><a href="#cb71-2"></a></span>
<span id="cb71-3"><a href="#cb71-3"></a><span class="dt">void</span> foo<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">()&gt;</span> f<span class="op">)</span> <span class="op">{</span> f<span class="op">();</span> <span class="op">}</span></span>
<span id="cb71-4"><a href="#cb71-4"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span> <span class="op">(*</span>f<span class="op">)())</span> <span class="op">{</span> f<span class="op">();</span> <span class="op">}</span></span>
<span id="cb71-5"><a href="#cb71-5"></a></span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="dt">int</span> main <span class="op">()</span></span>
<span id="cb71-7"><a href="#cb71-7"></a><span class="op">{</span></span>
<span id="cb71-8"><a href="#cb71-8"></a>    foo<span class="op">(</span>  <span class="op">[](){}</span> <span class="op">);</span> <span class="co">// ambiguous</span></span>
<span id="cb71-9"><a href="#cb71-9"></a>    foo<span class="op">(</span> <span class="op">+[](){}</span> <span class="op">);</span> <span class="co">// not ambiguous (calls the function pointer overload)</span></span>
<span id="cb71-10"><a href="#cb71-10"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>The + in the expression <code>+[](){}</code> is the unary + operator
[…] forces the conversion to the function pointer type</p>
</blockquote>
<p>In addition: what <code>*[](){}</code> does? And
<code>+*[](){}</code>?.</p>
<h4 data-number="51" id="virtual-operator-int"><span
class="header-section-number">51</span> <a
href="#virtual-operator-int"># </a>virtual operator int</h4>
<p><a
href="https://en.cppreference.com/w/cpp/language/cast_operator">conversion
function or cast operator</a> is the same as regular function and could
also be made virtual:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="op">{</span></span>
<span id="cb72-3"><a href="#cb72-3"></a>    <span class="kw">virtual</span> <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span></span>
<span id="cb72-4"><a href="#cb72-4"></a>    <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="op">};</span></span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb72-7"><a href="#cb72-7"></a><span class="op">{</span></span>
<span id="cb72-8"><a href="#cb72-8"></a>    <span class="kw">virtual</span> <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span> <span class="kw">override</span></span>
<span id="cb72-9"><a href="#cb72-9"></a>    <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb72-10"><a href="#cb72-10"></a><span class="op">};</span></span>
<span id="cb72-11"><a href="#cb72-11"></a></span>
<span id="cb72-12"><a href="#cb72-12"></a><span class="dt">void</span> Handle<span class="op">(</span><span class="at">const</span> MyBase<span class="op">&amp;</span> Base<span class="op">)</span></span>
<span id="cb72-13"><a href="#cb72-13"></a><span class="op">{</span></span>
<span id="cb72-14"><a href="#cb72-14"></a>    <span class="at">const</span> <span class="dt">int</span> V <span class="op">=</span> Base<span class="op">;</span></span>
<span id="cb72-15"><a href="#cb72-15"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> V<span class="op">);</span></span>
<span id="cb72-16"><a href="#cb72-16"></a><span class="op">}</span></span>
<span id="cb72-17"><a href="#cb72-17"></a></span>
<span id="cb72-18"><a href="#cb72-18"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb72-19"><a href="#cb72-19"></a><span class="op">{</span></span>
<span id="cb72-20"><a href="#cb72-20"></a>    Handle<span class="op">(</span>MyDerived<span class="op">{});</span> <span class="co">// prints 2</span></span>
<span id="cb72-21"><a href="#cb72-21"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="52" id="placement-new-emplace_back-pre-c11"><span
class="header-section-number">52</span> <a
href="#placement-new-emplace_back-pre-c11"># </a>placement new
emplace_back pre-C++11</h4>
<p>Used to perfect-construct object in-place. Below is valid C++98:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb73-3"><a href="#cb73-3"></a></span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="co">// array of max size 2 for int(s) for illustation</span></span>
<span id="cb73-5"><a href="#cb73-5"></a><span class="kw">struct</span> MyArray</span>
<span id="cb73-6"><a href="#cb73-6"></a><span class="op">{</span></span>
<span id="cb73-7"><a href="#cb73-7"></a>    <span class="co">/*alignas(int)*/</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">2</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)];</span></span>
<span id="cb73-8"><a href="#cb73-8"></a>    <span class="dt">int</span> size<span class="op">;</span> <span class="co">// = 0;</span></span>
<span id="cb73-9"><a href="#cb73-9"></a></span>
<span id="cb73-10"><a href="#cb73-10"></a>    <span class="dt">void</span><span class="op">*</span> emplace_back<span class="op">()</span></span>
<span id="cb73-11"><a href="#cb73-11"></a>    <span class="op">{</span></span>
<span id="cb73-12"><a href="#cb73-12"></a>        <span class="ot">assert</span><span class="op">(</span>size <span class="op">&lt;</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb73-13"><a href="#cb73-13"></a>        <span class="dt">void</span><span class="op">*</span> memory <span class="op">=</span> <span class="op">(</span>buffer <span class="op">+</span> size <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb73-14"><a href="#cb73-14"></a>        size <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb73-15"><a href="#cb73-15"></a>        <span class="cf">return</span> memory<span class="op">;</span></span>
<span id="cb73-16"><a href="#cb73-16"></a>    <span class="op">}</span></span>
<span id="cb73-17"><a href="#cb73-17"></a><span class="op">};</span></span>
<span id="cb73-18"><a href="#cb73-18"></a></span>
<span id="cb73-19"><a href="#cb73-19"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb73-20"><a href="#cb73-20"></a><span class="op">{</span></span>
<span id="cb73-21"><a href="#cb73-21"></a>    MyArray v<span class="op">;</span></span>
<span id="cb73-22"><a href="#cb73-22"></a>    <span class="kw">new</span><span class="op">(</span>v<span class="op">.</span>emplace_back<span class="op">())</span> <span class="dt">int</span><span class="op">(</span><span class="dv">44</span><span class="op">);</span></span>
<span id="cb73-23"><a href="#cb73-23"></a>    <span class="kw">new</span><span class="op">(</span>v<span class="op">.</span>emplace_back<span class="op">())</span> <span class="dt">int</span><span class="op">(</span><span class="dv">45</span><span class="op">);</span></span>
<span id="cb73-24"><a href="#cb73-24"></a><span class="op">}</span></span></code></pre></div>
<p>Observed in Unreal Engine:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a>TArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Data<span class="op">;</span></span>
<span id="cb74-2"><a href="#cb74-2"></a><span class="kw">new</span><span class="op">(</span>Data<span class="op">)</span> <span class="dt">int</span><span class="op">{</span><span class="dv">67</span><span class="op">};</span> <span class="co">// push_back to Data</span></span></code></pre></div>
<h4 data-number="53"
id="operator--recursion-returning-non-pointer-type"><span
class="header-section-number">53</span> <a
href="#operator--recursion-returning-non-pointer-type">#
</a><code>operator-&gt;</code> recursion (returning non-pointer
type)</h4>
<p>If <code>operator-&gt;</code> returns non-pointer type, compiler will
automatically invoke <code>operator-&gt;</code> on returned value until
its return type is pointer:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data<span class="op">;</span> <span class="co">// for illustration purpose</span></span>
<span id="cb75-2"><a href="#cb75-2"></a></span>
<span id="cb75-3"><a href="#cb75-3"></a><span class="kw">struct</span> A0</span>
<span id="cb75-4"><a href="#cb75-4"></a><span class="op">{</span></span>
<span id="cb75-5"><a href="#cb75-5"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">&amp;</span>data<span class="op">;</span> <span class="op">}</span></span>
<span id="cb75-6"><a href="#cb75-6"></a><span class="op">};</span></span>
<span id="cb75-7"><a href="#cb75-7"></a><span class="kw">struct</span> A1</span>
<span id="cb75-8"><a href="#cb75-8"></a><span class="op">{</span></span>
<span id="cb75-9"><a href="#cb75-9"></a>    A0 <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> A0<span class="op">{};</span> <span class="op">}</span> <span class="co">// note: returns value</span></span>
<span id="cb75-10"><a href="#cb75-10"></a><span class="op">};</span></span>
<span id="cb75-11"><a href="#cb75-11"></a><span class="kw">struct</span> A2</span>
<span id="cb75-12"><a href="#cb75-12"></a><span class="op">{</span></span>
<span id="cb75-13"><a href="#cb75-13"></a>    A1 <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> A1<span class="op">{};</span> <span class="op">}</span> <span class="co">// note: returns value</span></span>
<span id="cb75-14"><a href="#cb75-14"></a><span class="op">};</span></span>
<span id="cb75-15"><a href="#cb75-15"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb75-16"><a href="#cb75-16"></a><span class="op">{</span></span>
<span id="cb75-17"><a href="#cb75-17"></a>    A2 v<span class="op">;</span></span>
<span id="cb75-18"><a href="#cb75-18"></a>    v<span class="op">-&gt;</span>resize<span class="op">(</span><span class="dv">3</span><span class="op">);</span> <span class="co">// finds A0::operator-&gt;()</span></span>
<span id="cb75-19"><a href="#cb75-19"></a><span class="op">}</span></span></code></pre></div>
<p>Used for <a
href="https://quuxplusone.github.io/blog/2019/02/06/arrow-proxy/">arrow_proxy</a>.</p>
<h4 data-number="54" id="move-only-types-and-initializer_list"><span
class="header-section-number">54</span> <a
href="#move-only-types-and-initializer_list"># </a>move-only types and
initializer_list</h4>
<p>std::initializer_list with “uniform initialization” was introduced
together with move semantics in C++11. However, surprisingly,
initializer_list does not support move-only types like std::unique_ptr.
This does not compile:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> vs<span class="op">{</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>    <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">2</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb76-3"><a href="#cb76-3"></a>    <span class="op">};</span></span></code></pre></div>
<p>The fix could be the use of temporary array in this case:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> temp<span class="op">[]{</span></span>
<span id="cb77-2"><a href="#cb77-2"></a>    <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">2</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb77-3"><a href="#cb77-3"></a>    <span class="op">};</span></span>
<span id="cb77-4"><a href="#cb77-4"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> vs<span class="op">{</span></span>
<span id="cb77-5"><a href="#cb77-5"></a>    <span class="bu">std::</span>make_move_iterator<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>temp<span class="op">)),</span></span>
<span id="cb77-6"><a href="#cb77-6"></a>    <span class="bu">std::</span>make_move_iterator<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span>temp<span class="op">))</span></span>
<span id="cb77-7"><a href="#cb77-7"></a>    <span class="op">};</span></span></code></pre></div>
<h4 data-number="55"
id="uniform-initialization-is-not-uniform-use-parentheses-vs"><span
class="header-section-number">55</span> <a
href="#uniform-initialization-is-not-uniform-use-parentheses-vs">#
</a>uniform initialization is not uniform, use parentheses
(<code>()</code> vs <code>{}</code>)</h4>
<p>C++ initialization is famously complex. C++11 “uniform
initialization” with braces <code>{}</code> (list-initialization) is
famously non-uniform, see:</p>
<ul>
<li><a
href="https://medium.com/@barryrevzin/uniform-initialization-isnt-82533d3b9c11">Uniform
initialization isn’t</a>;</li>
<li><a
href="https://ianyepan.github.io/posts/cpp-uniform-initialization/">C++
Uniform Initialization - Benefits &amp; Pitfalls</a>;</li>
<li><a
href="https://quuxplusone.github.io/blog/2019/02/18/knightmare-of-initialization/">The
Knightmare of Initialization in C++</a>;</li>
<li>~300 pages book, <a
href="https://www.amazon.com/Initialization-Story-Through-Options-Related/dp/B0BW38DDBK">C++
Initialization Story</a>.</li>
<li><a
href="https://accu.org/journals/overload/25/139/brand_2379/">Initialization
in C++ is Bonkers</a></li>
</ul>
<p>Sometimes also called as <a
href="https://www.reddit.com/r/cpp/comments/as8pu1/comment/egslsok/">unicorn
initialization</a>; see also <a
href="https://x.com/timur_audio/status/1004017362381795329">Forrest Gump
C++ initialization</a>.</p>
<p>The best is to fall back to <code>()</code> with C++ 20 <a
href="https://wg21.link/p0960">Allow initializing aggregates from a
parenthesized list of values</a>:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1"></a><span class="kw">struct</span> A</span>
<span id="cb78-2"><a href="#cb78-2"></a><span class="op">{</span></span>
<span id="cb78-3"><a href="#cb78-3"></a>    <span class="dt">int</span> v1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-4"><a href="#cb78-4"></a>    <span class="dt">int</span> v2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb78-5"><a href="#cb78-5"></a><span class="op">};</span></span>
<span id="cb78-6"><a href="#cb78-6"></a></span>
<span id="cb78-7"><a href="#cb78-7"></a>A v<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span> <span class="co">// fine, C++20</span></span></code></pre></div>
<p>but also see <a
href="https://quuxplusone.github.io/blog/2022/06/03/aggregate-parens-init-considered-kinda-bad/">C++20’s
parenthesized aggregate initialization has some downsides</a>.</p>
<h4 data-number="56" id="move-only-lambda-and-stdfunction"><span
class="header-section-number">56</span> <a
href="#move-only-lambda-and-stdfunction"># </a>move-only lambda and
std::function</h4>
<p><code>std::function</code> was introduced together with move
semantics in C++11. However, surprisingly, std::function does not
support move-only lambda/function objects. This does not compile:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb79-1"><a href="#cb79-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">()&gt;</span> f<span class="op">{[</span>x <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">11</span><span class="op">)]()</span> <span class="op">{}};</span></span></code></pre></div>
<p>That’s one of the reasons C++23 <a
href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function">std::move_only_function</a>
was introduced.</p>
<h4 data-number="57" id="stdfunction-issues"><span
class="header-section-number">57</span> <a href="#stdfunction-issues">#
</a>std::function issues</h4>
<p>From <a href="https://wg21.link/n4159">std::functionand
Beyond</a>:</p>
<ul>
<li>Const-correctness and data races</li>
<li>Non-copyable function objects</li>
<li>Non-lvalue-callable function objects</li>
</ul>
<p>See also:</p>
<ul>
<li><a href="https://wg21.link/p2548">copyable_function</a> - C++26</li>
<li><a href="https://wg21.link/P0288">move_only_function</a> -
C++23</li>
<li><a href="https://wg21.link/P0792">function_ref</a> - C++26</li>
</ul>
<h4 data-number="58" id="non-trivial-types-in-union"><span
class="header-section-number">58</span> <a
href="#non-trivial-types-in-union"># </a>non-trivial types in union</h4>
<p>Since C++11, you can manually control lifetime of user-defined types.
See <a href="https://en.cppreference.com/w/cpp/language/union">Union
declaration</a> for more precise definition:</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb80-1"><a href="#cb80-1"></a><span class="kw">using</span> String <span class="op">=</span> <span class="bu">std::</span>string<span class="op">;</span> <span class="co">// non-trivial type</span></span>
<span id="cb80-2"><a href="#cb80-2"></a><span class="kw">union</span> MyUnion</span>
<span id="cb80-3"><a href="#cb80-3"></a><span class="op">{</span></span>
<span id="cb80-4"><a href="#cb80-4"></a>    String s0<span class="op">;</span></span>
<span id="cb80-5"><a href="#cb80-5"></a>    String s1<span class="op">;</span></span>
<span id="cb80-6"><a href="#cb80-6"></a>    MyUnion<span class="op">()</span> <span class="op">{</span> <span class="kw">new</span><span class="op">(&amp;</span>s0<span class="op">)</span> String<span class="op">(</span><span class="st">&quot;aa&quot;</span><span class="op">);</span> <span class="op">}</span> <span class="co">// activate s0</span></span>
<span id="cb80-7"><a href="#cb80-7"></a>    <span class="op">~</span>MyUnion<span class="op">()</span> <span class="op">{</span> <span class="op">}</span> <span class="co">// does not know what to destruct</span></span>
<span id="cb80-8"><a href="#cb80-8"></a><span class="op">};</span></span>
<span id="cb80-9"><a href="#cb80-9"></a></span>
<span id="cb80-10"><a href="#cb80-10"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb80-11"><a href="#cb80-11"></a><span class="op">{</span></span>
<span id="cb80-12"><a href="#cb80-12"></a>    MyUnion u<span class="op">;</span></span>
<span id="cb80-13"><a href="#cb80-13"></a>    u<span class="op">.</span>s0<span class="op">.~</span>String<span class="op">();</span> <span class="co">// free active member</span></span>
<span id="cb80-14"><a href="#cb80-14"></a>    <span class="kw">new</span><span class="op">(&amp;</span>u<span class="op">.</span>s1<span class="op">)</span> String<span class="op">(</span><span class="st">&quot;bb&quot;</span><span class="op">);</span> <span class="co">// construct s1</span></span>
<span id="cb80-15"><a href="#cb80-15"></a>    <span class="co">// ...</span></span>
<span id="cb80-16"><a href="#cb80-16"></a>    u<span class="op">.</span>s1<span class="op">.~</span>String<span class="op">();</span> <span class="co">// clean-up</span></span>
<span id="cb80-17"><a href="#cb80-17"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="59"
id="lambda-with-access-to-const-and-global-variables"><span
class="header-section-number">59</span> <a
href="#lambda-with-access-to-const-and-global-variables"># </a>lambda
with access to const and global variables</h4>
<p>You can omit capture of const/global data in a simple cases:</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb81-1"><a href="#cb81-1"></a><span class="dt">int</span> MyGlobal <span class="op">=</span> <span class="dv">98</span><span class="op">;</span></span>
<span id="cb81-2"><a href="#cb81-2"></a></span>
<span id="cb81-3"><a href="#cb81-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb81-4"><a href="#cb81-4"></a><span class="op">{</span></span>
<span id="cb81-5"><a href="#cb81-5"></a>    <span class="at">const</span> <span class="dt">int</span> MyConst <span class="op">=</span> <span class="dv">65</span><span class="op">;</span></span>
<span id="cb81-6"><a href="#cb81-6"></a></span>
<span id="cb81-7"><a href="#cb81-7"></a>    <span class="kw">auto</span> lambda0 <span class="op">=</span> <span class="op">[]()</span> <span class="op">{</span> <span class="cf">return</span> MyGlobal<span class="op">;</span> <span class="op">};</span> <span class="co">// ok</span></span>
<span id="cb81-8"><a href="#cb81-8"></a>    <span class="kw">auto</span> lambda1 <span class="op">=</span> <span class="op">[]()</span> <span class="op">{</span> <span class="cf">return</span> MyConst<span class="op">;</span> <span class="op">};</span>  <span class="co">// ok</span></span>
<span id="cb81-9"><a href="#cb81-9"></a><span class="op">}</span></span></code></pre></div>
<p>However, if const is odr-used (e.g., pointer is taken or reference-to
is formed), it needs to be captured:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb82-1"><a href="#cb82-1"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">*);</span></span>
<span id="cb82-2"><a href="#cb82-2"></a><span class="dt">void</span> Bar<span class="op">(</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;);</span></span>
<span id="cb82-3"><a href="#cb82-3"></a></span>
<span id="cb82-4"><a href="#cb82-4"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb82-5"><a href="#cb82-5"></a><span class="op">{</span></span>
<span id="cb82-6"><a href="#cb82-6"></a>    <span class="at">const</span> <span class="dt">int</span> MyConst <span class="op">=</span> <span class="dv">65</span><span class="op">;</span></span>
<span id="cb82-7"><a href="#cb82-7"></a>    <span class="kw">auto</span> lambda0 <span class="op">=</span> <span class="op">[]()</span> <span class="op">{</span> Foo<span class="op">(&amp;</span>MyConst<span class="op">);</span> <span class="op">};</span> <span class="co">// error</span></span>
<span id="cb82-8"><a href="#cb82-8"></a>    <span class="kw">auto</span> lambda0 <span class="op">=</span> <span class="op">[]()</span> <span class="op">{</span> Bar<span class="op">(</span>MyConst<span class="op">);</span> <span class="op">};</span>  <span class="co">// error</span></span>
<span id="cb82-9"><a href="#cb82-9"></a><span class="op">}</span></span></code></pre></div>
<p>See “implicit”/“odr-usable” in <a
href="https://en.cppreference.com/w/cpp/language/lambda">cppreference</a>.</p>
<h4 data-number="60" id="stdvariant-overload-pattern"><span
class="header-section-number">60</span> <a
href="#stdvariant-overload-pattern"># </a>std::variant overload
pattern</h4>
<p>See <a
href="https://www.cppstories.com/2019/02/2lines3featuresoverload.html/">2
Lines Of Code and 3 C++17 Features - The overload Pattern</a>.</p>
<p>C++17 version:</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb83-1"><a href="#cb83-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> overload <span class="op">:</span> Ts<span class="op">...</span> <span class="op">{</span> <span class="kw">using</span> Ts<span class="op">::</span><span class="kw">operator</span><span class="op">()...;</span> <span class="op">};</span></span>
<span id="cb83-2"><a href="#cb83-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> overload<span class="op">(</span>Ts<span class="op">...)</span> <span class="op">-&gt;</span> overload<span class="op">&lt;</span>Ts<span class="op">...&gt;;</span></span>
<span id="cb83-3"><a href="#cb83-3"></a></span>
<span id="cb83-4"><a href="#cb83-4"></a><span class="bu">std::</span>variant<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">float</span><span class="op">&gt;</span> vv<span class="op">{</span><span class="dv">67</span><span class="op">};</span></span>
<span id="cb83-5"><a href="#cb83-5"></a><span class="bu">std::</span>visit<span class="op">(</span>overload</span>
<span id="cb83-6"><a href="#cb83-6"></a>    <span class="op">{</span></span>
<span id="cb83-7"><a href="#cb83-7"></a>      <span class="op">[](</span><span class="at">const</span> <span class="dt">int</span><span class="op">&amp;</span> i<span class="op">)</span>   <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;int: &quot;</span> <span class="op">&lt;&lt;</span> i<span class="op">;</span> <span class="op">},</span></span>
<span id="cb83-8"><a href="#cb83-8"></a>      <span class="op">[](</span><span class="at">const</span> <span class="dt">float</span><span class="op">&amp;</span> f<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;float: &quot;</span> <span class="op">&lt;&lt;</span> f<span class="op">;</span> <span class="op">}</span></span>
<span id="cb83-9"><a href="#cb83-9"></a>    <span class="op">},</span></span>
<span id="cb83-10"><a href="#cb83-10"></a>    vv<span class="op">);</span></span></code></pre></div>
<p>C++20 version:</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb84-1"><a href="#cb84-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span> <span class="kw">struct</span> overload <span class="op">:</span> Ts<span class="op">...</span> <span class="op">{</span> <span class="kw">using</span> Ts<span class="op">::</span><span class="kw">operator</span><span class="op">()...;</span> <span class="op">};</span></span></code></pre></div>
<p>C++23 version (see <a
href="https://andreasfertig.blog/2023/07/visiting-a-stdvariant-safely/">Visiting
a std::variant safely</a>):</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb85-1"><a href="#cb85-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb85-2"><a href="#cb85-2"></a><span class="kw">struct</span> overload <span class="op">:</span> Ts<span class="op">...</span></span>
<span id="cb85-3"><a href="#cb85-3"></a><span class="op">{</span></span>
<span id="cb85-4"><a href="#cb85-4"></a>  <span class="kw">using</span> Ts<span class="op">::</span><span class="kw">operator</span><span class="op">()...;</span></span>
<span id="cb85-5"><a href="#cb85-5"></a></span>
<span id="cb85-6"><a href="#cb85-6"></a>  <span class="co">// Prevent implicit type conversions</span></span>
<span id="cb85-7"><a href="#cb85-7"></a>  <span class="kw">consteval</span> <span class="dt">void</span> <span class="kw">operator</span><span class="op">()(</span><span class="kw">auto</span><span class="op">)</span> <span class="at">const</span></span>
<span id="cb85-8"><a href="#cb85-8"></a>  <span class="op">{</span></span>
<span id="cb85-9"><a href="#cb85-9"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">false</span><span class="op">,</span> <span class="st">&quot;Unsupported type&quot;</span><span class="op">);</span></span>
<span id="cb85-10"><a href="#cb85-10"></a>  <span class="op">}</span></span>
<span id="cb85-11"><a href="#cb85-11"></a><span class="op">};</span></span></code></pre></div>
<h4 data-number="61"
id="unique_ptr-to-incomplete-type-and-class-destructor"><span
class="header-section-number">61</span> <a
href="#unique_ptr-to-incomplete-type-and-class-destructor">#
</a>unique_ptr to incomplete type and class destructor</h4>
<p>See <a
href="https://andreasfertig.blog/2023/12/when-an-empty-destructor-is-required/">When
an empty destructor is required</a> and <a
href="https://andreasfertig.blog/2024/10/smart-pointers-and-the-pointer-to-implementation-idiom/">Smart
pointers and the pointer to implementation idiom</a>.</p>
<p>In short, this does not compile:</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb86-1"><a href="#cb86-1"></a><span class="co">// apple.h</span></span>
<span id="cb86-2"><a href="#cb86-2"></a><span class="kw">class</span> Orange<span class="op">;</span></span>
<span id="cb86-3"><a href="#cb86-3"></a><span class="kw">class</span> Apple <span class="op">{</span></span>
<span id="cb86-4"><a href="#cb86-4"></a>  <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Orange<span class="op">&gt;</span> orange<span class="op">{};</span></span>
<span id="cb86-5"><a href="#cb86-5"></a><span class="op">};</span></span>
<span id="cb86-6"><a href="#cb86-6"></a></span>
<span id="cb86-7"><a href="#cb86-7"></a><span class="co">// use (error)</span></span>
<span id="cb86-8"><a href="#cb86-8"></a>Apple a<span class="op">{};</span></span></code></pre></div>
<p>since compiler-generated destructor is placed in the apple.h and
tries to invoke <code>Orange</code> destructor. Deleting incomplete type
is UB.</p>
<p>The fix is to move destructor definition to .cpp file:</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb87-1"><a href="#cb87-1"></a><span class="co">// apple.h</span></span>
<span id="cb87-2"><a href="#cb87-2"></a><span class="kw">class</span> Orange<span class="op">;</span></span>
<span id="cb87-3"><a href="#cb87-3"></a><span class="kw">class</span> Apple <span class="op">{</span></span>
<span id="cb87-4"><a href="#cb87-4"></a>  <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>Orange<span class="op">&gt;</span> orange<span class="op">{};</span></span>
<span id="cb87-5"><a href="#cb87-5"></a>  <span class="op">~</span>Apple<span class="op">();</span></span>
<span id="cb87-6"><a href="#cb87-6"></a><span class="op">};</span></span>
<span id="cb87-7"><a href="#cb87-7"></a></span>
<span id="cb87-8"><a href="#cb87-8"></a><span class="co">// apple.cpp</span></span>
<span id="cb87-9"><a href="#cb87-9"></a>Apple<span class="op">::</span>Apple<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb87-10"><a href="#cb87-10"></a></span>
<span id="cb87-11"><a href="#cb87-11"></a><span class="co">// use (fine)</span></span>
<span id="cb87-12"><a href="#cb87-12"></a>Apple a<span class="op">{};</span></span></code></pre></div>
<h4 data-number="62" id="the-use-of-shared_ptrconst-t"><span
class="header-section-number">62</span> <a
href="#the-use-of-shared_ptrconst-t"># </a>the use of
<code>shared_ptr&lt;const T&gt;</code></h4>
<ul>
<li><a href="https://youtu.be/_BpMYeUFXv8?si=t1XrdB4wjzdGksYd">Sean
Parent: Value Semantics and Concepts-based Polymorphism</a></li>
<li><a href="https://stackoverflow.com/a/18803611">Shared pointer to an
immutable type has value semantics</a></li>
<li><a
href="https://github.com/stlab/libraries/blob/1cd251b49cac434ca519af17da32c4969ee9d3d5/stlab/copy_on_write.hpp">copy_on_write.hpp</a>
from STLab.</li>
</ul>
<p><mark>TBD</mark>: code sample</p>
<h4 data-number="63" id="string_view-issues"><span
class="header-section-number">63</span> <a href="#string_view-issues">#
</a>string_view issues</h4>
<p>See <a
href="https://ciura.ro/presentations/2018/Conferences/Enough%20string_view%20to%20hang%20ourselves%20-%20Victor%20Ciura%20-%20CppCon%202018.pdf">Enough
string_view to hang ourselves</a>.</p>
<p><mark>TBD</mark>: code sample</p>
<h4 data-number="64"
id="user-provided-constructor-and-garbage-initialization"><span
class="header-section-number">64</span> <a
href="#user-provided-constructor-and-garbage-initialization">#
</a>user-provided constructor and garbage initialization</h4>
<p>See <a href="https://consteval.ca/2024/07/03/initialization/">I Have
No Constructor, and I Must Initialize</a>:</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb88-1"><a href="#cb88-1"></a><span class="kw">struct</span> T <span class="op">{</span></span>
<span id="cb88-2"><a href="#cb88-2"></a>    <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb88-3"><a href="#cb88-3"></a>    T<span class="op">();</span></span>
<span id="cb88-4"><a href="#cb88-4"></a><span class="op">};</span></span>
<span id="cb88-5"><a href="#cb88-5"></a>T<span class="op">::</span>T<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb88-6"><a href="#cb88-6"></a></span>
<span id="cb88-7"><a href="#cb88-7"></a>T t<span class="op">{};</span></span>
<span id="cb88-8"><a href="#cb88-8"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> t<span class="op">.</span>x <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span></code></pre></div>
<blockquote>
<p>You’d expect the printed result to be 0, right? You poor thing.
Alas—it will be garbage.</p>
</blockquote>
<h4 data-number="65"
id="beaware-of-stdstring_view-like-key-with-stdmeow_map"><span
class="header-section-number">65</span> <a
href="#beaware-of-stdstring_view-like-key-with-stdmeow_map">#
</a>beaware of std::string_view-like key with std::meow_map</h4>
<p>See, for instance, <a
href="https://olafurw.com/2022-12-03-a-view-of-a-map/">std::string_view
and std::map</a>. std::meow_map has invariant and does not allow easily
modify keys, making value_type to be
<code>std::pair&lt;const Key, T&gt;</code>. Modifying it implicitly is
UB:</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb89-1"><a href="#cb89-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb89-2"><a href="#cb89-2"></a><span class="op">{</span></span>
<span id="cb89-3"><a href="#cb89-3"></a>    <span class="bu">std::</span>string s1 <span class="op">=</span> <span class="st">&quot;wwwwwwwwwwwwwwwwwwwww&quot;</span><span class="op">;</span></span>
<span id="cb89-4"><a href="#cb89-4"></a>    <span class="bu">std::</span>string s2 <span class="op">=</span> <span class="st">&quot;bbbbbbbbbbbbbbbbbbbbb&quot;</span><span class="op">;</span></span>
<span id="cb89-5"><a href="#cb89-5"></a>    <span class="bu">std::</span>map<span class="op">&lt;</span><span class="bu">std::</span>string_view<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> m<span class="op">;</span></span>
<span id="cb89-6"><a href="#cb89-6"></a>    m<span class="op">[</span>s1<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb89-7"><a href="#cb89-7"></a>    m<span class="op">[</span>s2<span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb89-8"><a href="#cb89-8"></a>    s1 <span class="op">=</span> <span class="st">&quot;xx&quot;</span><span class="op">;</span> <span class="co">// what&#39;s the state of map?</span></span>
<span id="cb89-9"><a href="#cb89-9"></a><span class="op">}</span></span></code></pre></div>
<p>This is also the reason std::owner_less/owner_hash/owner_equal exist.
See <a href="https://wg21.link/P1901">Enabling the Use of weak_ptr as
Keys in Unordered Associative Containers</a>.</p>
<h4 data-number="66" id="stdpiecewise_construct"><span
class="header-section-number">66</span> <a
href="#stdpiecewise_construct">#
</a><code>std::piecewise_construct</code></h4>
<p>See also <a
href="https://devblogs.microsoft.com/oldnewthing/20220428-00/?p=106540">What’s
up with std::piecewise_construct and std::forward_as_tuple?</a>.</p>
<p>In case pair-like type has to:</p>
<ol type="1">
<li>construct types with multi-parameter constructor and/or</li>
<li>create non-copyable non-movable types in-place and/or</li>
<li>avoid having intermediate moves</li>
</ol>
<div class="sourceCode" id="cb90"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb90-1"><a href="#cb90-1"></a><span class="kw">struct</span> MyIds</span>
<span id="cb90-2"><a href="#cb90-2"></a><span class="op">{</span></span>
<span id="cb90-3"><a href="#cb90-3"></a>    MyIds<span class="op">(</span><span class="dt">int</span> v1<span class="op">,</span> <span class="dt">int</span> v2<span class="op">);</span></span>
<span id="cb90-4"><a href="#cb90-4"></a><span class="op">};</span></span>
<span id="cb90-5"><a href="#cb90-5"></a></span>
<span id="cb90-6"><a href="#cb90-6"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyIds<span class="op">&gt;</span> p1<span class="op">{</span><span class="dv">1</span><span class="op">,</span> MyIds<span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">}};</span> <span class="co">// unneeded move</span></span></code></pre></div>
<p>To foward a set of arguments to a sigle constructor, then:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb91-1"><a href="#cb91-1"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyIds<span class="op">&gt;</span> p2<span class="op">{</span><span class="bu">std::</span>piecewise_construct <span class="co">// for tag-dispatch</span></span>
<span id="cb91-2"><a href="#cb91-2"></a>    <span class="op">,</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">)</span> <span class="co">// first value</span></span>
<span id="cb91-3"><a href="#cb91-3"></a>    <span class="op">,</span> <span class="bu">std::</span>tuple<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">)</span> <span class="co">// second value</span></span>
<span id="cb91-4"><a href="#cb91-4"></a>    <span class="op">};</span></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="co">// OR</span></span>
<span id="cb91-6"><a href="#cb91-6"></a><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyIds<span class="op">&gt;</span> p3<span class="op">{</span><span class="bu">std::</span>piecewise_construct <span class="co">// for tag-dispatch</span></span>
<span id="cb91-7"><a href="#cb91-7"></a>    <span class="op">,</span> <span class="bu">std::</span>forward_as_tuple<span class="op">(</span><span class="dv">1</span><span class="op">)</span> <span class="co">// first value, from std::tuple&lt;int&amp;&amp;&gt;</span></span>
<span id="cb91-8"><a href="#cb91-8"></a>    <span class="op">,</span> <span class="bu">std::</span>forward_as_tuple<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">)</span> <span class="co">// second value, from std::tuple&lt;int&amp;&amp;, int&amp;&amp;&gt;</span></span>
<span id="cb91-9"><a href="#cb91-9"></a>    <span class="op">};</span></span></code></pre></div>
<p>This applies to std::meow_map, see <a
href="https://en.cppreference.com/w/cpp/container/map/emplace">emplace</a>:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb92-1"><a href="#cb92-1"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyIds<span class="op">&gt;</span> my_map<span class="op">;</span></span>
<span id="cb92-2"><a href="#cb92-2"></a><span class="kw">auto</span> <span class="op">[</span>_<span class="op">,</span> inserted<span class="op">]</span> <span class="op">=</span> my_map<span class="op">.</span>emplace<span class="op">(</span><span class="bu">std::</span>piecewise_construct</span>
<span id="cb92-3"><a href="#cb92-3"></a>    <span class="op">,</span> <span class="bu">std::</span>forward_as_tuple<span class="op">(</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb92-4"><a href="#cb92-4"></a>    <span class="op">,</span> <span class="bu">std::</span>forward_as_tuple<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">));</span></span></code></pre></div>
<h4 data-number="67"
id="mapkey-creates-default-constructed-value-first"><span
class="header-section-number">67</span> <a
href="#mapkey-creates-default-constructed-value-first">#
</a><code>map[key]</code> creates default-constructed value first</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/container/map/operator_at">map::operator[]</a>
which looks like this (simplifiyed) and returns <code>T&amp;</code>
ALWAYS:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb93-1"><a href="#cb93-1"></a>T<span class="op">&amp;</span> map<span class="op">::</span><span class="kw">operator</span><span class="op">[](</span>Key key<span class="op">);</span></span></code></pre></div>
<p>If <code>key</code> does not exist, no exception is thrown, instead
default-constructed value <code>T</code> is inserted:</p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb94-1"><a href="#cb94-1"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;</span> my_map<span class="op">;</span></span>
<span id="cb94-2"><a href="#cb94-2"></a>my_map<span class="op">[</span><span class="dv">1</span><span class="op">];</span> <span class="co">// key 1 = empty string, inserted anyway</span></span>
<span id="cb94-3"><a href="#cb94-3"></a>my_map<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;xxx&quot;</span><span class="op">;</span> <span class="co">// key 2 = empty string inserted,</span></span>
<span id="cb94-4"><a href="#cb94-4"></a>                   <span class="co">// empty string re-assigned next</span></span></code></pre></div>
<p>See also “default constructor must do no work” and “const map[key]
does not compile”.</p>
<h4 data-number="68" id="const-mapkey-does-not-compile-use-.find"><span
class="header-section-number">68</span> <a
href="#const-mapkey-does-not-compile-use-.find"># </a>const
<code>map[key]</code> does not compile, use <code>.find()</code></h4>
<p>See “map[key] creates default-constructed value first”. Because
<code>map::operator[]</code> is:</p>
<div class="sourceCode" id="cb95"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb95-1"><a href="#cb95-1"></a>T<span class="op">&amp;</span> map<span class="op">::</span><span class="kw">operator</span><span class="op">[](</span>Key key<span class="op">);</span></span></code></pre></div>
<p>you can’t use it for const map lookup, since operator at needs to
insert default value in case key does not exist:</p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb96-1"><a href="#cb96-1"></a><span class="dt">void</span> MyProcess<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;&amp;</span> kv<span class="op">)</span></span>
<span id="cb96-2"><a href="#cb96-2"></a><span class="op">{</span></span>
<span id="cb96-3"><a href="#cb96-3"></a>    <span class="at">const</span> <span class="bu">std::</span>string<span class="op">&amp;</span> my_value <span class="op">=</span> kv<span class="op">[</span><span class="dv">42</span><span class="op">];</span> <span class="co">// does not compile</span></span>
<span id="cb96-4"><a href="#cb96-4"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="69"
id="if-not-map.findx-then-mapx-is-an-antipattern"><span
class="header-section-number">69</span> <a
href="#if-not-map.findx-then-mapx-is-an-antipattern">#
</a><code>if not map.find(x) then map[x]</code> is an antipattern</h4>
<p>In case you need to do extra work only if key does not exist, having
code like this:</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb97-1"><a href="#cb97-1"></a><span class="dt">void</span> MyProcess<span class="op">(</span><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;&amp;</span> my_data<span class="op">)</span></span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="op">{</span></span>
<span id="cb97-3"><a href="#cb97-3"></a>    <span class="kw">auto</span> it <span class="op">=</span> my_data<span class="op">.</span>find<span class="op">(</span><span class="dv">56</span><span class="op">);</span>   <span class="co">// lookup #1</span></span>
<span id="cb97-4"><a href="#cb97-4"></a>    <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> my_data<span class="op">.</span>end<span class="op">())</span></span>
<span id="cb97-5"><a href="#cb97-5"></a>    <span class="op">{</span></span>
<span id="cb97-6"><a href="#cb97-6"></a>        my_data<span class="op">[</span><span class="dv">56</span><span class="op">]</span> <span class="op">=</span> <span class="st">&quot;data 56&quot;</span><span class="op">;</span>  <span class="co">// lookup #2 then</span></span>
<span id="cb97-7"><a href="#cb97-7"></a>                                  <span class="co">// default construct &amp; assign std::string</span></span>
<span id="cb97-8"><a href="#cb97-8"></a>    <span class="op">}</span></span>
<span id="cb97-9"><a href="#cb97-9"></a><span class="op">}</span></span></code></pre></div>
<p>Instead, insert or emplace key-value first:</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb98-1"><a href="#cb98-1"></a><span class="dt">void</span> MyProcess<span class="op">(</span><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">&gt;&amp;</span> my_data<span class="op">)</span></span>
<span id="cb98-2"><a href="#cb98-2"></a><span class="op">{</span></span>
<span id="cb98-3"><a href="#cb98-3"></a>    <span class="kw">auto</span> <span class="op">[</span>it<span class="op">,</span> inserted<span class="op">]</span> <span class="op">=</span> my_map<span class="op">.</span>insert<span class="op">(</span><span class="dv">56</span><span class="op">,</span> <span class="bu">std::</span>string<span class="op">());</span></span>
<span id="cb98-4"><a href="#cb98-4"></a>    <span class="cf">if</span> <span class="op">(!</span>inserted<span class="op">)</span></span>
<span id="cb98-5"><a href="#cb98-5"></a>    <span class="op">{</span></span>
<span id="cb98-6"><a href="#cb98-6"></a>        it<span class="op">-&gt;</span>value <span class="op">=</span> <span class="st">&quot;data 56&quot;</span><span class="op">;</span></span>
<span id="cb98-7"><a href="#cb98-7"></a>    <span class="op">}</span></span>
<span id="cb98-8"><a href="#cb98-8"></a><span class="op">}</span></span></code></pre></div>
<p>(You can use emplace to avoid default-constructing std::string).</p>
<h4 data-number="70" id="meyers-singleton"><span
class="header-section-number">70</span> <a href="#meyers-singleton">#
</a>Meyer’s singleton</h4>
<p>Relies on static local variables. Points to consider:</p>
<ul>
<li>lazy, on-first-access initialization</li>
<li>magic static</li>
</ul>
<div class="sourceCode" id="cb99"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb99-1"><a href="#cb99-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb99-2"><a href="#cb99-2"></a><span class="op">{</span></span>
<span id="cb99-3"><a href="#cb99-3"></a>    <span class="at">static</span> MyClass<span class="op">&amp;</span> GetInstance<span class="op">()</span></span>
<span id="cb99-4"><a href="#cb99-4"></a>    <span class="op">{</span></span>
<span id="cb99-5"><a href="#cb99-5"></a>        <span class="at">static</span> MyClass instance<span class="op">;</span></span>
<span id="cb99-6"><a href="#cb99-6"></a>        <span class="cf">return</span> instance<span class="op">;</span></span>
<span id="cb99-7"><a href="#cb99-7"></a>    <span class="op">}</span></span>
<span id="cb99-8"><a href="#cb99-8"></a><span class="op">};</span></span></code></pre></div>
<p>See also <a
href="https://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++
and the Perils of Double-Checked Locking</a>.</p>
<h4 data-number="71" id="magic-static"><span
class="header-section-number">71</span> <a href="#magic-static">#
</a>magic static</h4>
<p>From <a
href="https://learn.microsoft.com/en-us/cpp/cpp/storage-classes-cpp?view=msvc-170#static">Storage
classes/static</a>:</p>
<blockquote>
<p>Starting in C++11, a static local variable initialization is
guaranteed to be thread-safe. This feature is sometimes called magic
statics. However, in a multithreaded application all subsequent
assignments must be synchronized […]</p>
</blockquote>
<div class="sourceCode" id="cb100"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb100-1"><a href="#cb100-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb100-2"><a href="#cb100-2"></a><span class="op">{</span></span>
<span id="cb100-3"><a href="#cb100-3"></a>    <span class="at">static</span> MyClass<span class="op">&amp;</span> GetInstance<span class="op">()</span></span>
<span id="cb100-4"><a href="#cb100-4"></a>    <span class="op">{</span></span>
<span id="cb100-5"><a href="#cb100-5"></a>        <span class="at">static</span> MyClass instance<span class="op">;</span> <span class="co">// magic static</span></span>
<span id="cb100-6"><a href="#cb100-6"></a>        <span class="cf">return</span> instance<span class="op">;</span></span>
<span id="cb100-7"><a href="#cb100-7"></a>    <span class="op">}</span></span>
<span id="cb100-8"><a href="#cb100-8"></a><span class="op">};</span></span></code></pre></div>
<p>Note, that:</p>
<blockquote>
<p>If control enters the declaration concurrently while the variable is
being initialized, the concurrent execution shall wait for completion of
the initialization</p>
</blockquote>
<p>See also <a
href="https://preshing.com/20130930/double-checked-locking-is-fixed-in-cpp11/">Double-Checked
Locking is Fixed In C++11</a>, meaning that you may pay for each call to
GetInstance:</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode numberSource asm numberLines"><code class="sourceCode fasm"><span id="cb101-1"><a href="#cb101-1"></a>// MyClass<span class="op">&amp;</span> v1 <span class="op">=</span> MyClass<span class="op">::</span>GetInstance<span class="op">()</span><span class="co">;</span></span>
<span id="cb101-2"><a href="#cb101-2"></a>// MyClass<span class="op">&amp;</span> v2 <span class="op">=</span> MyClass<span class="op">::</span>GetInstance<span class="op">()</span><span class="co">; // may need to check guard/initialization anyway</span></span>
<span id="cb101-3"><a href="#cb101-3"></a>    <span class="bu">movzx</span>   <span class="kw">eax</span><span class="op">,</span> <span class="dt">BYTE</span> <span class="dt">PTR</span> guard variable for MyClass<span class="op">::</span>GetInstance<span class="op">()::</span>instance<span class="op">[</span>rip<span class="op">]</span></span>
<span id="cb101-4"><a href="#cb101-4"></a>    <span class="bu">test</span>    <span class="kw">al</span><span class="op">,</span> <span class="kw">al</span></span>
<span id="cb101-5"><a href="#cb101-5"></a>    <span class="cf">je</span>      <span class="op">.</span>L15</span>
<span id="cb101-6"><a href="#cb101-6"></a>    <span class="bu">mov</span>     <span class="kw">eax</span><span class="op">,</span> OFFSET FLAT<span class="op">:</span>MyClass<span class="op">::</span>GetInstance<span class="op">()::</span>instance</span>
<span id="cb101-7"><a href="#cb101-7"></a>    <span class="cf">ret</span></span></code></pre></div>
<h4 data-number="72" id="stdminx-y-thanks-to-windows.h"><span
class="header-section-number">72</span> <a
href="#stdminx-y-thanks-to-windows.h"># </a>(std::min)(x, y) thanks to
Windows.h</h4>
<p>A trick to avoid macro invocation.</p>
<p>You see code like this?</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb102-1"><a href="#cb102-1"></a><span class="dt">int</span> my_min <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>min<span class="op">)(</span>x1<span class="op">,</span> x2<span class="op">);</span></span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="dt">int</span> my_max <span class="op">=</span> <span class="op">(</span><span class="bu">std::</span>max<span class="op">)(</span>y1<span class="op">,</span> y2<span class="op">);</span></span></code></pre></div>
<p>and wonder why anyone would put extra parentheses? Thanks to
Windows.h we may have min and max available as MACROS, hence:</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb103-1"><a href="#cb103-1"></a><span class="pp">#include </span><span class="im">&lt;Windows.h&gt;</span></span>
<span id="cb103-2"><a href="#cb103-2"></a></span>
<span id="cb103-3"><a href="#cb103-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb103-4"><a href="#cb103-4"></a><span class="op">{</span></span>
<span id="cb103-5"><a href="#cb103-5"></a>    <span class="dt">int</span> v <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>x<span class="op">,</span> y<span class="op">);</span> <span class="co">// error, tries to expand min macro</span></span>
<span id="cb103-6"><a href="#cb103-6"></a><span class="op">}</span></span></code></pre></div>
<p>does not work. Extra parentheses around function name prevent macro
invocation. Other workarounds include:</p>
<div class="sourceCode" id="cb104"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb104-1"><a href="#cb104-1"></a><span class="dt">int</span> my_max <span class="op">=</span> <span class="bu">std::</span>max<span class="op">&lt;&gt;(</span>x<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb104-2"><a href="#cb104-2"></a><span class="dt">int</span> my_min <span class="op">=</span> <span class="bu">std::</span>min<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>x<span class="op">,</span> y<span class="op">);</span></span></code></pre></div>
<p>If you conrol build system, you may enforce <a
href="https://devblogs.microsoft.com/oldnewthing/20091130-00/?p=15863">WIN32_LEAN_AND_MEAN</a>,
NOMINMAX and heard about <a
href="http://web.archive.org/web/20121219084749/http://support.microsoft.com/kb/166474">VC_EXTRALEAN</a>.</p>
<h4 data-number="73" id="v-double-negation"><span
class="header-section-number">73</span> <a href="#v-double-negation">#
</a>!!v double-negation</h4>
<p>It’s a trick to convert to bool.</p>
<p>Lets have a look at MSVC <code>assert</code> implementation:</p>
<div class="sourceCode" id="cb105"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb105-1"><a href="#cb105-1"></a><span class="pp">#define assert</span><span class="op">(</span>expression<span class="op">)</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)(</span><span class="pp">    </span><span class="op">\</span></span>
<span id="cb105-2"><a href="#cb105-2"></a><span class="pp">        </span><span class="op">(!!(</span>expression<span class="op">))</span><span class="pp"> </span><span class="op">||</span><span class="pp">           </span><span class="op">\</span></span>
<span id="cb105-3"><a href="#cb105-3"></a><span class="pp">        </span><span class="op">(</span>_wassert<span class="op">(...,</span><span class="pp"> </span><span class="dv">0</span><span class="op">))</span></span></code></pre></div>
<p><code>expression</code> comes from client/user code and may be of ANY
type, <code>int</code>, <code>const char*</code>, anything. !! is used
to silence any warning since || expects bool. First ! actually converts
to bool, second ! reverts value to original one.</p>
<p>Same happens in code like this:</p>
<div class="sourceCode" id="cb106"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb106-1"><a href="#cb106-1"></a><span class="cf">if</span> <span class="op">(!!</span>my_data<span class="op">.</span>get<span class="op">(</span><span class="st">&quot;anything&quot;</span><span class="op">))</span> <span class="op">{</span> <span class="co">/**/</span> <span class="op">}</span></span></code></pre></div>
<p>Why not <code>static_cast&lt;bool&gt;(x)</code>? MSVC may warn you
about <code>(bool)a</code>, <code>bool(a)</code> and
<code>static_cast&lt;bool&gt;(a)</code>. See also <a
href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Contextual_conversions">contextually
converted to bool</a>.</p>
<h4 data-number="74" id="sizeof-v-and-sizeofv"><span
class="header-section-number">74</span> <a
href="#sizeof-v-and-sizeofv"># </a><code>sizeof v</code> and
<code>sizeof(v)</code></h4>
<p>Turns out, for expression sizeof does not requre parentheses:</p>
<div class="sourceCode" id="cb107"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb107-1"><a href="#cb107-1"></a><span class="dt">int</span> v <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb107-2"><a href="#cb107-2"></a><span class="at">const</span> <span class="dt">unsigned</span> size <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>v<span class="op">);</span> <span class="co">// compiles</span></span>
<span id="cb107-3"><a href="#cb107-3"></a><span class="at">const</span> <span class="dt">unsigned</span> size <span class="op">=</span> <span class="kw">sizeof</span> v<span class="op">;</span>  <span class="co">// same as above</span></span></code></pre></div>
<p>where <code>sizeof(Type)</code> requires parentheses for a type. See
<a href="https://en.cppreference.com/w/cpp/language/sizeof">sizeof
operator</a>.</p>
<h4 data-number="75" id="six-dots-ts......"><span
class="header-section-number">75</span> <a href="#six-dots-ts......">#
</a>six dots <code>Ts......</code></h4>
<p>See <a href="https://lbrandy.com/blog/2013/02/c11s-six-dots/">C++11’s
six dots</a>:</p>
<div class="sourceCode" id="cb108"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb108-1"><a href="#cb108-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb108-2"><a href="#cb108-2"></a><span class="dt">void</span> MyFoo<span class="op">(</span>Ts<span class="op">......)</span></span>
<span id="cb108-3"><a href="#cb108-3"></a><span class="op">{</span></span>
<span id="cb108-4"><a href="#cb108-4"></a><span class="op">}</span></span></code></pre></div>
<p>is valid C++, where <code>Ts...</code> is “a function with a variable
number of arguments” and the next 3 dots <code>...</code> is “a variadic
function from C, varargs”; all because comma is optional. From the
acticle above:</p>
<div class="sourceCode" id="cb109"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb109-1"><a href="#cb109-1"></a><span class="co">// These are all equivalent.</span></span>
<span id="cb109-2"><a href="#cb109-2"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span> <span class="dt">void</span> foo1<span class="op">(</span>Args<span class="op">......);</span></span>
<span id="cb109-3"><a href="#cb109-3"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span> <span class="dt">void</span> foo2<span class="op">(</span>Args<span class="op">...</span> <span class="op">...);</span></span>
<span id="cb109-4"><a href="#cb109-4"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span> <span class="dt">void</span> foo3<span class="op">(</span>Args<span class="op">...,</span> <span class="op">...);</span></span></code></pre></div>
<h4 data-number="76" id="assertx-message"><span
class="header-section-number">76</span> <a href="#assertx-message">#
</a><code>assert(x &amp;&amp; "message")</code></h4>
<p>Used to print “message” when assert fails. Compare the output of:</p>
<div class="sourceCode" id="cb110"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb110-1"><a href="#cb110-1"></a>    <span class="dt">bool</span> x <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb110-2"><a href="#cb110-2"></a>    <span class="ot">assert</span><span class="op">(</span>x<span class="op">);</span></span>
<span id="cb110-3"><a href="#cb110-3"></a><span class="co">// example.cpp:2: int main(): Assertion `x&#39; failed.</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb111"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb111-1"><a href="#cb111-1"></a>    <span class="dt">bool</span> x <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb111-2"><a href="#cb111-2"></a>    <span class="ot">assert</span><span class="op">(</span>x <span class="op">&amp;&amp;</span> <span class="st">&quot;message&quot;</span><span class="op">);</span></span>
<span id="cb111-3"><a href="#cb111-3"></a><span class="co">// example.cpp:2: int main(): Assertion `x &amp;&amp; &quot;message&quot;&#39; failed.</span></span></code></pre></div>
<p>This works since “message” is implicitly converted to
<code>const char*</code> which then is converted to bool and is always
true. Because of that next variations exist to always fail, but with a
message:</p>
<div class="sourceCode" id="cb112"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb112-1"><a href="#cb112-1"></a><span class="ot">assert</span><span class="op">(</span><span class="kw">false</span> <span class="op">&amp;&amp;</span> <span class="st">&quot;message&quot;</span><span class="op">);</span> <span class="co">// fail always, print &quot;message&quot;</span></span>
<span id="cb112-2"><a href="#cb112-2"></a><span class="ot">assert</span><span class="op">(!</span><span class="st">&quot;message&quot;</span><span class="op">);</span>         <span class="co">// same</span></span></code></pre></div>
<h4 data-number="77"
id="assert.h-and-ndebug-with-no-include-guard"><span
class="header-section-number">77</span> <a
href="#assert.h-and-ndebug-with-no-include-guard">#
</a><code>&lt;assert.h&gt;</code> and NDEBUG with no include guard</h4>
<p><code>&lt;assert.h&gt;</code> and <code>&lt;cassert&gt;</code> are
special in the sense that there is no header include guard, <strong>by
design</strong> - see, for instance, MSVC implementation:</p>
<div class="sourceCode" id="cb113"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb113-1"><a href="#cb113-1"></a><span class="co">// &lt;cassert&gt;</span></span>
<span id="cb113-2"><a href="#cb113-2"></a><span class="co">// </span><span class="al">NOTE</span><span class="co">: no include guard</span></span>
<span id="cb113-3"><a href="#cb113-3"></a><span class="pp">#include </span><span class="im">&lt;yvals_core.h&gt;</span></span>
<span id="cb113-4"><a href="#cb113-4"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span></code></pre></div>
<p>This is so you can ON and OFF <code>NDEBUG</code> whenever you want
and include <code>&lt;assert.h&gt;</code> to either get working
<code>assert()</code> or a no-op in a different parts of the program.
Consider:</p>
<div class="sourceCode" id="cb114"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb114-1"><a href="#cb114-1"></a><span class="co">// impl.cpp</span></span>
<span id="cb114-2"><a href="#cb114-2"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb114-3"><a href="#cb114-3"></a><span class="dt">void</span> MyFoo<span class="op">()</span></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="op">{</span></span>
<span id="cb114-5"><a href="#cb114-5"></a>    <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span> <span class="co">// may or may not trigger `assert()`;</span></span>
<span id="cb114-6"><a href="#cb114-6"></a>                   <span class="co">// depends on compilation options</span></span>
<span id="cb114-7"><a href="#cb114-7"></a><span class="op">}</span></span>
<span id="cb114-8"><a href="#cb114-8"></a></span>
<span id="cb114-9"><a href="#cb114-9"></a><span class="pp">#if defined(NDEBUG)</span></span>
<span id="cb114-10"><a href="#cb114-10"></a><span class="pp">#  undef NDEBUG</span></span>
<span id="cb114-11"><a href="#cb114-11"></a><span class="pp">#endif</span></span>
<span id="cb114-12"><a href="#cb114-12"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span><span class="pp"> </span><span class="co">// include 2nd time, assert is ENABLED</span></span>
<span id="cb114-13"><a href="#cb114-13"></a><span class="dt">void</span> MyBar<span class="op">()</span></span>
<span id="cb114-14"><a href="#cb114-14"></a><span class="op">{</span></span>
<span id="cb114-15"><a href="#cb114-15"></a>    <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span> <span class="co">// invokes std::abort(), always</span></span>
<span id="cb114-16"><a href="#cb114-16"></a><span class="op">}</span></span></code></pre></div>
<p>Usually useful for one-file tools to fail fast even in Release:</p>
<div class="sourceCode" id="cb115"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb115-1"><a href="#cb115-1"></a><span class="co">// main.cpp</span></span>
<span id="cb115-2"><a href="#cb115-2"></a><span class="pp">#include </span><span class="im">&quot;my_api.h&quot;</span></span>
<span id="cb115-3"><a href="#cb115-3"></a><span class="pp">#include </span><span class="im">&lt;Windows.h&gt;</span></span>
<span id="cb115-4"><a href="#cb115-4"></a></span>
<span id="cb115-5"><a href="#cb115-5"></a><span class="pp">#if defined(NDEBUG)</span></span>
<span id="cb115-6"><a href="#cb115-6"></a><span class="pp">#  undef NDEBUG</span></span>
<span id="cb115-7"><a href="#cb115-7"></a><span class="pp">#endif</span></span>
<span id="cb115-8"><a href="#cb115-8"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span><span class="pp"> </span><span class="co">// enable assert in Release also</span></span>
<span id="cb115-9"><a href="#cb115-9"></a></span>
<span id="cb115-10"><a href="#cb115-10"></a><span class="dt">int</span> main<span class="op">(</span><span class="dt">int</span> argc<span class="op">,</span> <span class="dt">char</span><span class="op">*</span> argv<span class="op">[])</span></span>
<span id="cb115-11"><a href="#cb115-11"></a><span class="op">{</span></span>
<span id="cb115-12"><a href="#cb115-12"></a>    <span class="ot">assert</span><span class="op">(</span>argc <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> <span class="st">&quot;Expected single &lt;file_name&gt; argument passed&quot;</span><span class="op">);</span></span>
<span id="cb115-13"><a href="#cb115-13"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name <span class="op">=</span> argv<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb115-14"><a href="#cb115-14"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="78"
id="universal-reference-vs-forwarding-reference"><span
class="header-section-number">78</span> <a
href="#universal-reference-vs-forwarding-reference"># </a>universal
reference vs forwarding reference</h4>
<p>The same thing:</p>
<div class="sourceCode" id="cb116"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb116-1"><a href="#cb116-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb116-2"><a href="#cb116-2"></a><span class="dt">void</span> MyFoo<span class="op">(</span>T<span class="op">&amp;&amp;);</span>       <span class="co">// T&amp;&amp; is a forwarding reference</span></span></code></pre></div>
<p>From this <a href="https://stackoverflow.com/a/39552345">SO
answer</a>:</p>
<blockquote>
<p>Universal reference was a term Scott Meyers coined […] At the time
the C++ standard didn’t have a special term for this, which was an
oversight in C++11 and makes it hard to teach. This oversight was
remedied by N4164 […]</p>
</blockquote>
<p>See <a
href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal
References in C++11</a> and <a
href="https://wg21.link/n4164">n4164/Forwarding References</a>.</p>
<h4 data-number="79"
id="force-constexpr-to-evaluate-at-compile-time"><span
class="header-section-number">79</span> <a
href="#force-constexpr-to-evaluate-at-compile-time"># </a>force
constexpr to evaluate at compile time</h4>
<p>Even if arguments of constexpr function are known at compile time,
it’s not guarantee that its going to be evaluated at compile time. To
force constexpr run at compile time, need to use it in a context where
compile time value is expected, such as template argument or constexpr
variable:</p>
<div class="sourceCode" id="cb117"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb117-1"><a href="#cb117-1"></a><span class="kw">constexpr</span> <span class="dt">int</span> MyHash<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> str<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">9</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb117-2"><a href="#cb117-2"></a></span>
<span id="cb117-3"><a href="#cb117-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">int</span> N<span class="op">&gt;</span></span>
<span id="cb117-4"><a href="#cb117-4"></a><span class="kw">struct</span> ForceCompileTime</span>
<span id="cb117-5"><a href="#cb117-5"></a><span class="op">{</span></span>
<span id="cb117-6"><a href="#cb117-6"></a>    <span class="at">static</span> <span class="dt">int</span> Get<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> N<span class="op">;</span> <span class="op">}</span></span>
<span id="cb117-7"><a href="#cb117-7"></a><span class="op">};</span></span>
<span id="cb117-8"><a href="#cb117-8"></a></span>
<span id="cb117-9"><a href="#cb117-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb117-10"><a href="#cb117-10"></a><span class="op">{</span></span>
<span id="cb117-11"><a href="#cb117-11"></a>    <span class="dt">int</span> v1 <span class="op">=</span> MyHash<span class="op">(</span><span class="st">&quot;v1&quot;</span><span class="op">);</span>                          <span class="co">// may run at run-time</span></span>
<span id="cb117-12"><a href="#cb117-12"></a>    <span class="kw">constexpr</span> <span class="dt">int</span> v2 <span class="op">=</span> MyHash<span class="op">(</span><span class="st">&quot;v2&quot;</span><span class="op">);</span>                <span class="co">// compile-time</span></span>
<span id="cb117-13"><a href="#cb117-13"></a>    <span class="dt">int</span> v3 <span class="op">=</span> ForceCompileTime<span class="op">&lt;</span>MyHash<span class="op">(</span><span class="st">&quot;v3&quot;</span><span class="op">)&gt;::</span>Get<span class="op">();</span> <span class="co">// compile-time</span></span>
<span id="cb117-14"><a href="#cb117-14"></a><span class="op">}</span></span></code></pre></div>
<p>See also Epic’s Unreal Engine version: UE_FORCE_CONSTEVAL, where
variable template is used instead.</p>
<h4 data-number="80" id="variadic-template-with-default-argument"><span
class="header-section-number">80</span> <a
href="#variadic-template-with-default-argument"># </a>variadic template
with default argument</h4>
<p>See <a href="https://cor3ntin.github.io/posts/variadic/">Non-terminal
variadic template parameters</a>. Specifically, arguments deduction does
not work in cases like this:</p>
<div class="sourceCode" id="cb118"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb118-1"><a href="#cb118-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb118-2"><a href="#cb118-2"></a><span class="dt">void</span> Foo<span class="op">(</span>Args<span class="op">...,</span> <span class="dt">int</span> default_v <span class="op">=</span> <span class="dv">10</span><span class="op">)</span> <span class="op">{</span> <span class="op">}</span></span>
<span id="cb118-3"><a href="#cb118-3"></a></span>
<span id="cb118-4"><a href="#cb118-4"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb118-5"><a href="#cb118-5"></a><span class="op">{</span></span>
<span id="cb118-6"><a href="#cb118-6"></a>    Foo<span class="op">(</span><span class="fl">0.1</span><span class="bu">f</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">);</span> <span class="co">// does not compile</span></span>
<span id="cb118-7"><a href="#cb118-7"></a><span class="op">}</span></span></code></pre></div>
<p>You can, however, specify all Args… explicitly, so this works:</p>
<div class="sourceCode" id="cb119"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb119-1"><a href="#cb119-1"></a>Foo<span class="op">&lt;</span><span class="dt">float</span><span class="op">,</span> <span class="dt">char</span><span class="op">&gt;(</span><span class="fl">0.1</span><span class="bu">f</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">);</span> <span class="co">// default_v = 10</span></span></code></pre></div>
<p>Usually, this is solved case by case. For instance, to emulate this
kind of API:</p>
<div class="sourceCode" id="cb120"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb120-1"><a href="#cb120-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb120-2"><a href="#cb120-2"></a><span class="dt">void</span> WaitAll<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">,</span> milliseconds timeout <span class="op">=</span> milliseconds<span class="op">::</span>max<span class="op">());</span></span></code></pre></div>
<p>where Args… could be handles/async requests we want to wait with
optional timeout. To mimic it, we can do something like this:</p>
<div class="sourceCode" id="cb121"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb121-1"><a href="#cb121-1"></a><span class="pp">#include </span><span class="im">&lt;chrono&gt;</span></span>
<span id="cb121-2"><a href="#cb121-2"></a><span class="pp">#include </span><span class="im">&lt;type_traits&gt;</span></span>
<span id="cb121-3"><a href="#cb121-3"></a></span>
<span id="cb121-4"><a href="#cb121-4"></a><span class="kw">using</span> <span class="bu">std::</span>chrono::milliseconds<span class="op">;</span></span>
<span id="cb121-5"><a href="#cb121-5"></a></span>
<span id="cb121-6"><a href="#cb121-6"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb121-7"><a href="#cb121-7"></a><span class="dt">void</span> WaitAll_Impl<span class="op">(</span>milliseconds timeout<span class="op">,</span> Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span></span>
<span id="cb121-8"><a href="#cb121-8"></a><span class="op">{</span></span>
<span id="cb121-9"><a href="#cb121-9"></a>    <span class="bu">std::</span>puts<span class="op">(</span>timeout <span class="op">==</span> milliseconds<span class="op">::</span>max<span class="op">()</span> <span class="op">?</span> <span class="st">&quot;no timeout&quot;</span> <span class="op">:</span> <span class="st">&quot;with timeout&quot;</span><span class="op">);</span></span>
<span id="cb121-10"><a href="#cb121-10"></a><span class="op">}</span></span>
<span id="cb121-11"><a href="#cb121-11"></a></span>
<span id="cb121-12"><a href="#cb121-12"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb121-13"><a href="#cb121-13"></a><span class="dt">void</span> WaitAll<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span></span>
<span id="cb121-14"><a href="#cb121-14"></a><span class="op">{</span></span>
<span id="cb121-15"><a href="#cb121-15"></a>    <span class="kw">using</span> LastT <span class="op">=</span> <span class="bu">std::</span>remove_cvref_t<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">((</span>args<span class="op">,</span> <span class="op">...))&gt;;</span></span>
<span id="cb121-16"><a href="#cb121-16"></a>    <span class="cf">if</span> <span class="kw">constexpr</span> <span class="op">(</span><span class="bu">std::</span>is_same_v<span class="op">&lt;</span>LastT<span class="op">,</span> milliseconds<span class="op">&gt;)</span></span>
<span id="cb121-17"><a href="#cb121-17"></a>    <span class="op">{</span></span>
<span id="cb121-18"><a href="#cb121-18"></a>        <span class="at">const</span> milliseconds timeout <span class="op">=</span> <span class="op">(</span>args<span class="op">,</span> <span class="op">...);</span> <span class="co">// get last argument</span></span>
<span id="cb121-19"><a href="#cb121-19"></a>        <span class="cf">return</span> WaitAll_Impl<span class="op">(</span>timeout<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)...);</span></span>
<span id="cb121-20"><a href="#cb121-20"></a>    <span class="op">}</span></span>
<span id="cb121-21"><a href="#cb121-21"></a>    <span class="cf">else</span></span>
<span id="cb121-22"><a href="#cb121-22"></a>    <span class="op">{</span></span>
<span id="cb121-23"><a href="#cb121-23"></a>        <span class="at">const</span> milliseconds timeout <span class="op">=</span> milliseconds<span class="op">::</span>max<span class="op">();</span> <span class="co">// default timeout</span></span>
<span id="cb121-24"><a href="#cb121-24"></a>        <span class="cf">return</span> WaitAll_Impl<span class="op">(</span>timeout<span class="op">,</span> <span class="bu">std::</span>forward<span class="op">&lt;</span>Args<span class="op">&gt;(</span>args<span class="op">)...);</span></span>
<span id="cb121-25"><a href="#cb121-25"></a>    <span class="op">}</span></span>
<span id="cb121-26"><a href="#cb121-26"></a><span class="op">}</span></span>
<span id="cb121-27"><a href="#cb121-27"></a></span>
<span id="cb121-28"><a href="#cb121-28"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb121-29"><a href="#cb121-29"></a><span class="op">{</span></span>
<span id="cb121-30"><a href="#cb121-30"></a>    WaitAll<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> milliseconds<span class="op">{</span><span class="dv">25</span><span class="op">});</span> <span class="co">// with timeout</span></span>
<span id="cb121-31"><a href="#cb121-31"></a>    WaitAll<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span>                   <span class="co">// no timeout, use default</span></span>
<span id="cb121-32"><a href="#cb121-32"></a><span class="op">}</span></span></code></pre></div>
<p>To see what <code>(args, ...)</code> does, check <a
href="https://www.foonathan.net/2020/05/fold-tricks/">Nifty Fold
Expression Tricks</a>. See also similar issues with
<code>source_location::current()</code>.</p>
<h4 data-number="81"
id="variadic-template-with-default-stdsource_locationcurrent"><span
class="header-section-number">81</span> <a
href="#variadic-template-with-default-stdsource_locationcurrent">#
</a>variadic template with default std::source_location::current()</h4>
<p>Something like this does not work (see <a
href="https://stackoverflow.com/q/57547273/2451677">this SO</a>):</p>
<div class="sourceCode" id="cb122"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb122-1"><a href="#cb122-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb122-2"><a href="#cb122-2"></a><span class="dt">void</span> debug<span class="op">(</span>Args<span class="op">&amp;&amp;...</span> args<span class="op">,</span></span>
<span id="cb122-3"><a href="#cb122-3"></a>           <span class="at">const</span> <span class="bu">std::</span>source_location<span class="op">&amp;</span> loc <span class="op">=</span> <span class="bu">std::</span>source_location::current<span class="op">());</span></span></code></pre></div>
<p>Introducing type with implicit constructor is the trick:</p>
<div class="sourceCode" id="cb123"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb123-1"><a href="#cb123-1"></a><span class="pp">#include </span><span class="im">&lt;source_location&gt;</span></span>
<span id="cb123-2"><a href="#cb123-2"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb123-3"><a href="#cb123-3"></a></span>
<span id="cb123-4"><a href="#cb123-4"></a><span class="kw">struct</span> FormatWithLocation <span class="op">{</span></span>
<span id="cb123-5"><a href="#cb123-5"></a>  <span class="at">const</span> <span class="dt">char</span><span class="op">*</span> fmt<span class="op">;</span></span>
<span id="cb123-6"><a href="#cb123-6"></a>  <span class="bu">std::</span>source_location loc<span class="op">;</span></span>
<span id="cb123-7"><a href="#cb123-7"></a></span>
<span id="cb123-8"><a href="#cb123-8"></a>  FormatWithLocation<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> <span class="va">fmt_</span><span class="op">,</span></span>
<span id="cb123-9"><a href="#cb123-9"></a>                     <span class="at">const</span> <span class="bu">std::</span>source_location<span class="op">&amp;</span> <span class="va">loc_</span> <span class="op">=</span> <span class="bu">std::</span>source_location::current<span class="op">())</span></span>
<span id="cb123-10"><a href="#cb123-10"></a>      <span class="op">:</span> fmt<span class="op">(</span><span class="va">fmt_</span><span class="op">),</span> loc<span class="op">(</span><span class="va">loc_</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb123-11"><a href="#cb123-11"></a><span class="op">};</span></span>
<span id="cb123-12"><a href="#cb123-12"></a></span>
<span id="cb123-13"><a href="#cb123-13"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Args<span class="op">&gt;</span></span>
<span id="cb123-14"><a href="#cb123-14"></a><span class="dt">void</span> debug<span class="op">(</span>FormatWithLocation fmt<span class="op">,</span> Args<span class="op">&amp;&amp;...</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb123-15"><a href="#cb123-15"></a>  printf<span class="op">(</span><span class="st">&quot;[</span><span class="sc">%s</span><span class="st">:</span><span class="sc">%d</span><span class="st">] &quot;</span><span class="op">,</span> fmt<span class="op">.</span>loc<span class="op">.</span>file_name<span class="op">(),</span> fmt<span class="op">.</span>loc<span class="op">.</span>line<span class="op">());</span></span>
<span id="cb123-16"><a href="#cb123-16"></a>  printf<span class="op">(</span>fmt<span class="op">.</span>fmt<span class="op">,</span> args<span class="op">...);</span></span>
<span id="cb123-17"><a href="#cb123-17"></a><span class="op">}</span></span>
<span id="cb123-18"><a href="#cb123-18"></a></span>
<span id="cb123-19"><a href="#cb123-19"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span> debug<span class="op">(</span><span class="st">&quot;hello </span><span class="sc">%s</span><span class="st"> </span><span class="sc">%s</span><span class="st">&quot;</span><span class="op">,</span> <span class="st">&quot;world&quot;</span><span class="op">,</span> <span class="st">&quot;around&quot;</span><span class="op">);</span> <span class="op">}</span></span></code></pre></div>
<p>See also <a
href="https://cor3ntin.github.io/posts/variadic/">Non-terminal variadic
template parameters</a>.</p>
<h4 data-number="82"
id="variadic-template-with-default-argument-and-deduction-guide"><span
class="header-section-number">82</span> <a
href="#variadic-template-with-default-argument-and-deduction-guide">#
</a>variadic template with default argument and deduction guide</h4>
<p>See <a href="https://stackoverflow.com/q/57547273/2451677">this
SO</a>:</p>
<div class="sourceCode" id="cb124"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb124-1"><a href="#cb124-1"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb124-2"><a href="#cb124-2"></a><span class="kw">struct</span> debug</span>
<span id="cb124-3"><a href="#cb124-3"></a><span class="op">{</span>    </span>
<span id="cb124-4"><a href="#cb124-4"></a>    debug<span class="op">(</span>Ts<span class="op">&amp;&amp;...</span> ts</span>
<span id="cb124-5"><a href="#cb124-5"></a>        <span class="op">,</span> <span class="at">const</span> <span class="bu">std::</span>source_location<span class="op">&amp;</span> loc <span class="op">=</span> <span class="bu">std::</span>source_location::current<span class="op">());</span></span>
<span id="cb124-6"><a href="#cb124-6"></a><span class="op">};</span></span>
<span id="cb124-7"><a href="#cb124-7"></a></span>
<span id="cb124-8"><a href="#cb124-8"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span><span class="op">...</span> Ts<span class="op">&gt;</span></span>
<span id="cb124-9"><a href="#cb124-9"></a>debug<span class="op">(</span>Ts<span class="op">&amp;&amp;...)</span> <span class="op">-&gt;</span> debug<span class="op">&lt;</span>Ts<span class="op">...&gt;;</span></span>
<span id="cb124-10"><a href="#cb124-10"></a></span>
<span id="cb124-11"><a href="#cb124-11"></a><span class="co">// debug(5, &#39;A&#39;, 3.14f, &quot;foo&quot;); // works</span></span></code></pre></div>
<p>See also <a
href="https://cor3ntin.github.io/posts/variadic/">Non-terminal variadic
template parameters</a> and “variadic template with default argument”
section.</p>
<h4 data-number="83"
id="debug-print-type-at-compile-time-with-error"><span
class="header-section-number">83</span> <a
href="#debug-print-type-at-compile-time-with-error"># </a>debug: print
type at compile time with error</h4>
<p>Sometimes it’s useful to know the type of a variable deep inside
templates:</p>
<div class="sourceCode" id="cb125"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb125-1"><a href="#cb125-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span> <span class="kw">struct</span> Show<span class="op">;</span></span>
<span id="cb125-2"><a href="#cb125-2"></a></span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="dt">void</span> Foo<span class="op">(</span>T<span class="op">&amp;&amp;</span> v<span class="op">)</span></span>
<span id="cb125-5"><a href="#cb125-5"></a><span class="op">{</span></span>
<span id="cb125-6"><a href="#cb125-6"></a>    Show<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span>v<span class="op">)&gt;{};</span></span>
<span id="cb125-7"><a href="#cb125-7"></a><span class="op">}</span></span>
<span id="cb125-8"><a href="#cb125-8"></a></span>
<span id="cb125-9"><a href="#cb125-9"></a>Foo<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span></code></pre></div>
<p><code>Show</code> is intentionally incomplete. Compiler will print
the error message like this:</p>
<pre><code>error: invalid use of incomplete type &#39;struct Show&lt;int&amp;&amp;&gt;&#39;
       Show&lt;decltype(v)&gt;{};
       ^~~~</code></pre>
<p>and you can see that <code>v</code> has type
<code>int&amp;&amp;</code> there.</p>
<p>See also <a
href="https://cukic.co/2019/02/19/tmp-testing-and-debugging-templates">Template
meta-programming: Some testing and debugging tricks</a>.</p>
<h4 data-number="84" id="debug-useful-custom-assert"><span
class="header-section-number">84</span> <a
href="#debug-useful-custom-assert"># </a>debug: useful custom
assert</h4>
<p>When custom version of assert is needed, it’s useful to inject
<code>__debugbreak</code> right at assert definition so you can get
breakpoint hit exactly at the location of the assert fail. In short:</p>
<div class="sourceCode" id="cb127"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb127-1"><a href="#cb127-1"></a><span class="pp">#define KK_ABORT</span><span class="op">(</span>KK_FMT<span class="op">,</span><span class="pp"> </span><span class="op">...)</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)</span><span class="pp">                              </span><span class="op">\</span></span>
<span id="cb127-2"><a href="#cb127-2"></a><span class="pp">    </span><span class="op">(::</span>log_abort<span class="op">(</span><span class="ot">__FILE__</span><span class="op">,</span><span class="pp"> </span><span class="ot">__LINE__</span><span class="op">,</span><span class="pp"> </span>KK_FMT<span class="op">,</span><span class="pp"> </span><span class="op">##</span><span class="ot">__VA_ARGS__</span><span class="op">),</span><span class="pp">      </span><span class="op">\</span></span>
<span id="cb127-3"><a href="#cb127-3"></a><span class="pp">        </span>__debugbreak<span class="op">(),</span><span class="pp">                                           </span><span class="op">\</span></span>
<span id="cb127-4"><a href="#cb127-4"></a><span class="pp">        </span><span class="bu">std::</span>quick_exit<span class="op">(-</span><span class="dv">1</span><span class="op">))</span></span>
<span id="cb127-5"><a href="#cb127-5"></a></span>
<span id="cb127-6"><a href="#cb127-6"></a><span class="pp">#define KK_VERIFY</span><span class="op">(</span>KK_EXPRESSION<span class="op">)</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)</span><span class="pp">                           </span><span class="op">\</span></span>
<span id="cb127-7"><a href="#cb127-7"></a><span class="pp">    </span><span class="op">(!!(</span>KK_EXPRESSION<span class="op">)</span><span class="pp"> </span><span class="op">||</span><span class="pp">                                         </span><span class="op">\</span></span>
<span id="cb127-8"><a href="#cb127-8"></a><span class="pp">        </span><span class="op">(</span>KK_ABORT<span class="op">(</span><span class="st">&quot;Verify failed: </span><span class="sc">{}</span><span class="st">.&quot;</span><span class="op">,</span><span class="pp"> </span><span class="op">#</span>KK_EXPRESSION<span class="op">),</span><span class="pp"> </span><span class="kw">false</span><span class="op">))</span></span></code></pre></div>
<p><code>__debugbreak()</code> is for the cases when you are under
debugger and <code>std::quick_exit()</code> is for the case when you are
not.</p>
<p>Bonus question: why operator comma is used in
<code>(KK_ABORT(...), false)</code>?</p>
<h4 data-number="85" id="stdmove-does-not-move"><span
class="header-section-number">85</span> <a
href="#stdmove-does-not-move"># </a>std::move does not move</h4>
<p><code>std::move(object)</code> does not “move” on its own. So</p>
<div class="sourceCode" id="cb128"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb128-1"><a href="#cb128-1"></a><span class="bu">std::</span>string s<span class="op">;</span></span>
<span id="cb128-2"><a href="#cb128-2"></a><span class="bu">std::</span>move<span class="op">(</span>s<span class="op">);</span> <span class="co">// no-op</span></span></code></pre></div>
<p>Similarly, you can move into function that accepts rvalue refence. If
function implementation does not actually modify/move argument - initial
move is a no-op:</p>
<div class="sourceCode" id="cb129"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb129-1"><a href="#cb129-1"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="bu">std::</span>string<span class="op">&amp;&amp;</span> str<span class="op">)</span> <span class="co">// rvalue reference</span></span>
<span id="cb129-2"><a href="#cb129-2"></a><span class="op">{</span></span>
<span id="cb129-3"><a href="#cb129-3"></a>    <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;not using str&quot;</span><span class="op">);</span></span>
<span id="cb129-4"><a href="#cb129-4"></a><span class="op">}</span></span>
<span id="cb129-5"><a href="#cb129-5"></a></span>
<span id="cb129-6"><a href="#cb129-6"></a><span class="bu">std::</span>string str <span class="op">=</span> <span class="op">...</span></span>
<span id="cb129-7"><a href="#cb129-7"></a>Foo<span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span>str<span class="op">));</span> <span class="co">// no-op</span></span>
<span id="cb129-8"><a href="#cb129-8"></a><span class="co">// str is unchanged, can be used freely,</span></span>
<span id="cb129-9"><a href="#cb129-9"></a><span class="co">// but only because you **know** exact implementation of `Foo`</span></span></code></pre></div>
<p>Same, if class has only copy constructor, copy assignment and no move
constructor/ move assignment, the code is no-op:</p>
<div class="sourceCode" id="cb130"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb130-1"><a href="#cb130-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb130-2"><a href="#cb130-2"></a><span class="op">{</span></span>
<span id="cb130-3"><a href="#cb130-3"></a>    MyClass<span class="op">(</span><span class="at">const</span> MyClass<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span> <span class="co">/**/</span> <span class="op">}</span></span>
<span id="cb130-4"><a href="#cb130-4"></a>    MyClass<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> MyClass<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span> <span class="co">/**/</span> <span class="op">}</span></span>
<span id="cb130-5"><a href="#cb130-5"></a><span class="op">};</span></span>
<span id="cb130-6"><a href="#cb130-6"></a></span>
<span id="cb130-7"><a href="#cb130-7"></a>MyClass object<span class="op">;</span></span>
<span id="cb130-8"><a href="#cb130-8"></a>MyClass copy <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>object<span class="op">);</span> <span class="co">// no-op or rathe copy constructor is invoked</span></span>
<span id="cb130-9"><a href="#cb130-9"></a><span class="co">// object is unchaged, can be used freely</span></span></code></pre></div>
<p>Same, if class has move constructor/move assignmed that actually does
not use/or modify argument, it is no-op again:</p>
<div class="sourceCode" id="cb131"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb131-1"><a href="#cb131-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb131-2"><a href="#cb131-2"></a><span class="op">{</span></span>
<span id="cb131-3"><a href="#cb131-3"></a>    MyClass<span class="op">(</span>MyClass<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;not using rhs actually&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb131-4"><a href="#cb131-4"></a>    MyClass<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> MyClass<span class="op">&amp;</span> rhs<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;same&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb131-5"><a href="#cb131-5"></a><span class="op">};</span></span>
<span id="cb131-6"><a href="#cb131-6"></a></span>
<span id="cb131-7"><a href="#cb131-7"></a>MyClass object<span class="op">;</span></span>
<span id="cb131-8"><a href="#cb131-8"></a>MyClass o2 <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>object<span class="op">);</span> <span class="co">// no-op, even tho move constructor was invoked</span></span>
<span id="cb131-9"><a href="#cb131-9"></a><span class="co">// object is unchaged, can be used freely</span></span></code></pre></div>
<p>So in short std::move is a cast to rvalue that is used
<strong>only</strong> for overload resolution; only to select move
constructor instead of copy constructor if both present, etc.</p>
<p>See <a
href="https://web.archive.org/web/20230604062855/http://thbecker.net/articles/rvalue_references/section_01.html">C++
Rvalue References Explained</a> archive.</p>
<h4 data-number="86" id="no-destructive-move"><span
class="header-section-number">86</span> <a href="#no-destructive-move">#
</a>no destructive move</h4>
<p>After std::move object still alive and invokes destructor.</p>
<p><mark>TODO</mark></p>
<h4 data-number="87" id="stdmove-on-return"><span
class="header-section-number">87</span> <a href="#stdmove-on-return">#
</a>std::move on return</h4>
<p>See <a
href="https://devblogs.microsoft.com/oldnewthing/20231124-00/?p=109059">On
harmful overuse of std::move</a>.</p>
<p><mark>TODO</mark></p>
<h4 data-number="88" id="enum-struct"><span
class="header-section-number">88</span> <a href="#enum-struct">#
</a>enum struct</h4>
<p>Does below compile?</p>
<div class="sourceCode" id="cb132"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb132-1"><a href="#cb132-1"></a><span class="kw">enum</span> <span class="kw">struct</span> MyEnum</span>
<span id="cb132-2"><a href="#cb132-2"></a><span class="op">{</span></span>
<span id="cb132-3"><a href="#cb132-3"></a>    V0 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb132-4"><a href="#cb132-4"></a>    V1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb132-5"><a href="#cb132-5"></a><span class="op">}</span></span></code></pre></div>
<p>Yes. Exactly the same as <code>enum class MyEnum</code>.</p>
<h4 data-number="89" id="using-enum-declaration"><span
class="header-section-number">89</span> <a
href="#using-enum-declaration"># </a>using enum declaration</h4>
<p><a href="https://en.cppreference.com/w/cpp/language/enum">This works
(C++20)</a>:</p>
<div class="sourceCode" id="cb133"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb133-1"><a href="#cb133-1"></a><span class="pp">#include </span><span class="im">&lt;cstio&gt;</span></span>
<span id="cb133-2"><a href="#cb133-2"></a></span>
<span id="cb133-3"><a href="#cb133-3"></a><span class="kw">enum</span> <span class="kw">class</span> MyEnum</span>
<span id="cb133-4"><a href="#cb133-4"></a><span class="op">{</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>    MyValue0 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb133-6"><a href="#cb133-6"></a>    MyValue1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span></span>
<span id="cb133-7"><a href="#cb133-7"></a>    MyValue2 <span class="op">=</span> <span class="dv">2</span><span class="op">,</span></span>
<span id="cb133-8"><a href="#cb133-8"></a><span class="op">};</span></span>
<span id="cb133-9"><a href="#cb133-9"></a></span>
<span id="cb133-10"><a href="#cb133-10"></a><span class="dt">void</span> MyProcess<span class="op">(</span>MyEnum v<span class="op">)</span></span>
<span id="cb133-11"><a href="#cb133-11"></a><span class="op">{</span></span>
<span id="cb133-12"><a href="#cb133-12"></a>    <span class="kw">using</span> <span class="kw">enum</span> MyEnum<span class="op">;</span></span>
<span id="cb133-13"><a href="#cb133-13"></a>    <span class="cf">switch</span> <span class="op">(</span>v<span class="op">)</span></span>
<span id="cb133-14"><a href="#cb133-14"></a>    <span class="op">{</span></span>
<span id="cb133-15"><a href="#cb133-15"></a>        <span class="cf">case</span> MyValue0<span class="op">:</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;got MyValue0&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb133-16"><a href="#cb133-16"></a>        <span class="cf">case</span> MyValue1<span class="op">:</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;got MyValue1&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb133-17"><a href="#cb133-17"></a>        <span class="cf">case</span> MyValue2<span class="op">:</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;got MyValue2&quot;</span><span class="op">);</span> <span class="cf">break</span><span class="op">;</span></span>
<span id="cb133-18"><a href="#cb133-18"></a>    <span class="op">}</span></span>
<span id="cb133-19"><a href="#cb133-19"></a>    <span class="co">// Note: no need to fully-qualify MyEnum::MyValue0.</span></span>
<span id="cb133-20"><a href="#cb133-20"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="90" id="using-declaration-vs-using-directive"><span
class="header-section-number">90</span> <a
href="#using-declaration-vs-using-directive"># </a>using declaration vs
using directive</h4>
<p>See <a
href="https://learn.microsoft.com/en-us/cpp/cpp/using-declaration?view=msvc-170">using
declaration</a> and <a
href="https://learn.microsoft.com/en-us/cpp/cpp/using-declaration?view=msvc-170">using
directives</a>.</p>
<div class="sourceCode" id="cb134"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb134-1"><a href="#cb134-1"></a><span class="kw">namespace</span> MyNamespace</span>
<span id="cb134-2"><a href="#cb134-2"></a><span class="op">{</span></span>
<span id="cb134-3"><a href="#cb134-3"></a>    <span class="dt">void</span> Foo<span class="op">();</span></span>
<span id="cb134-4"><a href="#cb134-4"></a>    <span class="dt">void</span> Bar<span class="op">();</span></span>
<span id="cb134-5"><a href="#cb134-5"></a><span class="op">}</span></span>
<span id="cb134-6"><a href="#cb134-6"></a></span>
<span id="cb134-7"><a href="#cb134-7"></a><span class="kw">using</span> MyNamespace<span class="op">::</span>Bar<span class="op">;</span> <span class="co">// using declaration</span></span>
<span id="cb134-8"><a href="#cb134-8"></a>Bar<span class="op">();</span></span>
<span id="cb134-9"><a href="#cb134-9"></a><span class="kw">using</span> <span class="kw">namespace</span> MyNamespace<span class="op">;</span> <span class="co">// using directive</span></span>
<span id="cb134-10"><a href="#cb134-10"></a>Foo<span class="op">();</span></span></code></pre></div>
<p>One brings single name; another brings whole namespace.</p>
<h4 data-number="91" id="dynamic_castt-and-dynamic_castt"><span
class="header-section-number">91</span> <a
href="#dynamic_castt-and-dynamic_castt">#
</a><code>dynamic_cast&lt;T*&gt;</code> and
<code>dynamic_cast&lt;T&amp;&gt;</code></h4>
<p>One returns nullptr on fail, the other one throws <a
href="https://en.cppreference.com/w/cpp/types/bad_cast">std::bad_cast</a>:</p>
<div class="sourceCode" id="cb135"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb135-1"><a href="#cb135-1"></a><span class="kw">struct</span> Base</span>
<span id="cb135-2"><a href="#cb135-2"></a><span class="op">{</span></span>
<span id="cb135-3"><a href="#cb135-3"></a>    <span class="kw">virtual</span> <span class="op">~</span>Base<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb135-4"><a href="#cb135-4"></a><span class="op">};</span></span>
<span id="cb135-5"><a href="#cb135-5"></a><span class="kw">struct</span> Derived <span class="op">:</span> Base <span class="op">{};</span></span>
<span id="cb135-6"><a href="#cb135-6"></a></span>
<span id="cb135-7"><a href="#cb135-7"></a><span class="dt">void</span> Handle<span class="op">(</span>Base<span class="op">*</span> base<span class="op">)</span></span>
<span id="cb135-8"><a href="#cb135-8"></a><span class="op">{</span></span>
<span id="cb135-9"><a href="#cb135-9"></a>    Derived<span class="op">*</span> d_ptr <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived<span class="op">*&gt;(</span>base<span class="op">);</span></span>
<span id="cb135-10"><a href="#cb135-10"></a>    <span class="ot">assert</span><span class="op">(</span>d_ptr<span class="op">);</span> <span class="co">// null on fail</span></span>
<span id="cb135-11"><a href="#cb135-11"></a></span>
<span id="cb135-12"><a href="#cb135-12"></a>    <span class="cf">try</span></span>
<span id="cb135-13"><a href="#cb135-13"></a>    <span class="op">{</span></span>
<span id="cb135-14"><a href="#cb135-14"></a>        Derived<span class="op">&amp;</span> d_ref <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span>Derived<span class="op">&amp;&gt;(*</span>base<span class="op">);</span></span>
<span id="cb135-15"><a href="#cb135-15"></a>    <span class="op">}</span></span>
<span id="cb135-16"><a href="#cb135-16"></a>    <span class="cf">catch</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>bad_cast<span class="op">&amp;)</span></span>
<span id="cb135-17"><a href="#cb135-17"></a>    <span class="op">{</span></span>
<span id="cb135-18"><a href="#cb135-18"></a>        <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span> <span class="co">// exception of fail</span></span>
<span id="cb135-19"><a href="#cb135-19"></a>    <span class="op">}</span></span>
<span id="cb135-20"><a href="#cb135-20"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="92" id="dynamic_castconst-t-adds-const"><span
class="header-section-number">92</span> <a
href="#dynamic_castconst-t-adds-const">#
</a><code>dynamic_cast&lt;const T*&gt;</code> adds const</h4>
<div class="sourceCode" id="cb136"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb136-1"><a href="#cb136-1"></a><span class="kw">struct</span> V <span class="op">{};</span></span>
<span id="cb136-2"><a href="#cb136-2"></a></span>
<span id="cb136-3"><a href="#cb136-3"></a><span class="dt">void</span> Handle<span class="op">(</span>V<span class="op">*</span> v<span class="op">)</span></span>
<span id="cb136-4"><a href="#cb136-4"></a><span class="op">{</span></span>
<span id="cb136-5"><a href="#cb136-5"></a>    <span class="at">const</span> V<span class="op">*</span> v1 <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="at">const</span> V<span class="op">*&gt;(</span>v<span class="op">);</span></span>
<span id="cb136-6"><a href="#cb136-6"></a>    <span class="at">const</span> V<span class="op">*</span> v2 <span class="op">=</span> <span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> V<span class="op">*&gt;(</span>v<span class="op">);</span></span>
<span id="cb136-7"><a href="#cb136-7"></a>    <span class="at">const</span> V<span class="op">*</span> v3 <span class="op">=</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="at">const</span> V<span class="op">*&gt;(</span>v<span class="op">);</span></span>
<span id="cb136-8"><a href="#cb136-8"></a><span class="op">}</span></span></code></pre></div>
<p>Usually, it’s said that dynamic_cast needs to be appliyed to
polymorphic type, note V in this case is not a polymorphic type (but
still a class type). See also
<code>dynamic_cast&lt;void*&gt;</code>.</p>
<p>Notice, const_cast&lt;const V*&gt; can also be used to
<strong>add</strong> const, not only remove it.</p>
<h4 data-number="93" id="conout-conin-for-allocconsole"><span
class="header-section-number">93</span> <a
href="#conout-conin-for-allocconsole"># </a><code>CONOUT$</code>,
<code>CONIN$</code> for <code>::AllocConsole()</code></h4>
<p>See <a
href="https://learn.microsoft.com/en-us/windows/console/console-handles">Console
Handles</a>. In case you do ::AllocConsole(), you may want to
reinitialize C and C++ stdio:</p>
<div class="sourceCode" id="cb137"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb137-1"><a href="#cb137-1"></a><span class="co">// /SUBSYSTEM:WINDOWS or Not Set.</span></span>
<span id="cb137-2"><a href="#cb137-2"></a><span class="dt">int</span> WINAPI wWinMain<span class="op">(</span>HINSTANCE<span class="op">,</span> HINSTANCE<span class="op">,</span> PWSTR<span class="op">,</span> <span class="dt">int</span><span class="op">)</span></span>
<span id="cb137-3"><a href="#cb137-3"></a><span class="op">{</span></span>
<span id="cb137-4"><a href="#cb137-4"></a>    KK_VERIFY<span class="op">(::</span>AllocConsole<span class="op">());</span></span>
<span id="cb137-5"><a href="#cb137-5"></a>    <span class="dt">FILE</span><span class="op">*</span> unused <span class="op">=</span> <span class="kw">nullptr</span><span class="op">;</span></span>
<span id="cb137-6"><a href="#cb137-6"></a>    KK_VERIFY<span class="op">(</span><span class="dv">0</span> <span class="op">==</span> freopen_s<span class="op">(&amp;</span>unused<span class="op">,</span> <span class="st">&quot;CONOUT$&quot;</span><span class="op">,</span> <span class="st">&quot;w&quot;</span><span class="op">,</span> stdout<span class="op">));</span></span>
<span id="cb137-7"><a href="#cb137-7"></a>    KK_VERIFY<span class="op">(</span><span class="dv">0</span> <span class="op">==</span> freopen_s<span class="op">(&amp;</span>unused<span class="op">,</span> <span class="st">&quot;CONOUT$&quot;</span><span class="op">,</span> <span class="st">&quot;w&quot;</span><span class="op">,</span> stderr<span class="op">));</span></span>
<span id="cb137-8"><a href="#cb137-8"></a>    KK_VERIFY<span class="op">(</span><span class="dv">0</span> <span class="op">==</span> freopen_s<span class="op">(&amp;</span>unused<span class="op">,</span> <span class="st">&quot;CONIN$&quot;</span><span class="op">,</span> <span class="st">&quot;r&quot;</span><span class="op">,</span> stdin<span class="op">));</span></span>
<span id="cb137-9"><a href="#cb137-9"></a>    <span class="bu">std::</span>cout<span class="op">.</span>clear<span class="op">();</span> <span class="co">// to reset badbit/failbit</span></span>
<span id="cb137-10"><a href="#cb137-10"></a>    <span class="bu">std::</span>clog<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb137-11"><a href="#cb137-11"></a>    <span class="bu">std::</span>cerr<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb137-12"><a href="#cb137-12"></a>    <span class="bu">std::</span>cin<span class="op">.</span>clear<span class="op">();</span></span>
<span id="cb137-13"><a href="#cb137-13"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb137-14"><a href="#cb137-14"></a><span class="op">}</span></span></code></pre></div>
<p>See <a href="https://stackoverflow.com/a/57241985/2451677">this
SO</a> for std::wcout and friends reinitilization.</p>
<h4 data-number="94" id="rdbuf-to-read-whole-file"><span
class="header-section-number">94</span> <a
href="#rdbuf-to-read-whole-file"># </a>rdbuf to read whole file</h4>
<p>In case you just need a file content as std::string:</p>
<div class="sourceCode" id="cb138"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb138-1"><a href="#cb138-1"></a><span class="bu">std::</span>string ReadFileAsString<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_path<span class="op">)</span></span>
<span id="cb138-2"><a href="#cb138-2"></a><span class="op">{</span></span>
<span id="cb138-3"><a href="#cb138-3"></a>    <span class="bu">std::</span>ifstream file<span class="op">{</span>file_path<span class="op">};</span></span>
<span id="cb138-4"><a href="#cb138-4"></a>    KK_VERIFY<span class="op">(</span>file<span class="op">);</span></span>
<span id="cb138-5"><a href="#cb138-5"></a>    <span class="bu">std::</span>ostringstream ss<span class="op">;</span></span>
<span id="cb138-6"><a href="#cb138-6"></a>    ss <span class="op">&lt;&lt;</span> file<span class="op">.</span>rdbuf<span class="op">();</span></span>
<span id="cb138-7"><a href="#cb138-7"></a>    KK_VERIFY<span class="op">(</span>ss<span class="op">);</span></span>
<span id="cb138-8"><a href="#cb138-8"></a>    <span class="bu">std::</span>string content <span class="op">=</span> <span class="bu">std::</span>move<span class="op">(</span>ss<span class="op">).</span>str<span class="op">();</span></span>
<span id="cb138-9"><a href="#cb138-9"></a>    <span class="cf">return</span> content<span class="op">;</span></span>
<span id="cb138-10"><a href="#cb138-10"></a><span class="op">}</span></span></code></pre></div>
<p>Is it “fast” enough?</p>
<h4 data-number="95" id="rdbuf-to-redirect"><span
class="header-section-number">95</span> <a href="#rdbuf-to-redirect">#
</a>rdbuf to redirect</h4>
<p>See also <a
href="https://en.cppreference.com/w/cpp/io/basic_ios/rdbuf">rdbuf</a>:</p>
<div class="sourceCode" id="cb139"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb139-1"><a href="#cb139-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb139-2"><a href="#cb139-2"></a><span class="op">{</span></span>
<span id="cb139-3"><a href="#cb139-3"></a>    <span class="bu">std::</span>ifstream in<span class="op">(</span><span class="st">&quot;in.txt&quot;</span><span class="op">);</span></span>
<span id="cb139-4"><a href="#cb139-4"></a>    KK_VERIFY<span class="op">(</span>in<span class="op">);</span></span>
<span id="cb139-5"><a href="#cb139-5"></a>    <span class="bu">std::</span>streambuf<span class="op">*</span> old_cin <span class="op">=</span> <span class="bu">std::</span>cin<span class="op">.</span>rdbuf<span class="op">(</span>in<span class="op">.</span>rdbuf<span class="op">());</span> <span class="co">// redirect std::cin to in.txt</span></span>
<span id="cb139-6"><a href="#cb139-6"></a>    KK_VERIFY<span class="op">(</span>old_cin<span class="op">);</span></span>
<span id="cb139-7"><a href="#cb139-7"></a></span>
<span id="cb139-8"><a href="#cb139-8"></a>    <span class="bu">std::</span>ofstream out<span class="op">(</span><span class="st">&quot;out.txt&quot;</span><span class="op">);</span></span>
<span id="cb139-9"><a href="#cb139-9"></a>    KK_VERIFY<span class="op">(</span>out<span class="op">);</span></span>
<span id="cb139-10"><a href="#cb139-10"></a>    <span class="bu">std::</span>streambuf<span class="op">*</span> old_cout <span class="op">=</span> <span class="bu">std::</span>cout<span class="op">.</span>rdbuf<span class="op">(</span>out<span class="op">.</span>rdbuf<span class="op">());</span> <span class="co">// redirect std::cout to out.txt</span></span>
<span id="cb139-11"><a href="#cb139-11"></a>    KK_VERIFY<span class="op">(</span>old_cout<span class="op">);</span></span>
<span id="cb139-12"><a href="#cb139-12"></a></span>
<span id="cb139-13"><a href="#cb139-13"></a>    <span class="co">// read/write</span></span>
<span id="cb139-14"><a href="#cb139-14"></a>    <span class="bu">std::</span>string word<span class="op">;</span></span>
<span id="cb139-15"><a href="#cb139-15"></a>    <span class="bu">std::</span>cin <span class="op">&gt;&gt;</span> word<span class="op">;</span></span>
<span id="cb139-16"><a href="#cb139-16"></a>    <span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> word<span class="op">;</span></span>
<span id="cb139-17"><a href="#cb139-17"></a></span>
<span id="cb139-18"><a href="#cb139-18"></a>    <span class="bu">std::</span>cin<span class="op">.</span>rdbuf<span class="op">(</span>old_cin<span class="op">);</span> <span class="co">// rollback</span></span>
<span id="cb139-19"><a href="#cb139-19"></a>    <span class="bu">std::</span>cout<span class="op">.</span>rdbuf<span class="op">(</span>old_cout<span class="op">);</span></span>
<span id="cb139-20"><a href="#cb139-20"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="96"
id="compile-error-on-missing-switch-enum-case"><span
class="header-section-number">96</span> <a
href="#compile-error-on-missing-switch-enum-case"># </a>compile error on
missing switch enum case</h4>
<p>When adding new enum value to existing enum what places need to be
updated?</p>
<div class="sourceCode" id="cb140"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb140-1"><a href="#cb140-1"></a><span class="co">//      MSVC: /we4062</span></span>
<span id="cb140-2"><a href="#cb140-2"></a><span class="co">// Clang/GCC: -Werror=switch-enum</span></span>
<span id="cb140-3"><a href="#cb140-3"></a></span>
<span id="cb140-4"><a href="#cb140-4"></a><span class="kw">enum</span> <span class="kw">class</span> MyEnum <span class="op">{</span> E1<span class="op">,</span> E2<span class="op">,</span> E3<span class="op">,</span> <span class="op">};</span></span>
<span id="cb140-5"><a href="#cb140-5"></a></span>
<span id="cb140-6"><a href="#cb140-6"></a><span class="dt">int</span> MyProcess<span class="op">(</span>MyEnum v<span class="op">)</span></span>
<span id="cb140-7"><a href="#cb140-7"></a><span class="op">{</span></span>
<span id="cb140-8"><a href="#cb140-8"></a>    <span class="cf">switch</span> <span class="op">(</span>v<span class="op">)</span></span>
<span id="cb140-9"><a href="#cb140-9"></a>    <span class="op">{</span></span>
<span id="cb140-10"><a href="#cb140-10"></a>    <span class="cf">case</span> MyEnum<span class="op">::</span>E1<span class="op">:</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb140-11"><a href="#cb140-11"></a>    <span class="cf">case</span> MyEnum<span class="op">::</span>E2<span class="op">:</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb140-12"><a href="#cb140-12"></a>    <span class="co">// note: missing case MyEnum::E3    &lt;-----</span></span>
<span id="cb140-13"><a href="#cb140-13"></a>    <span class="co">// note: default must not be present</span></span>
<span id="cb140-14"><a href="#cb140-14"></a>    <span class="op">}</span></span>
<span id="cb140-15"><a href="#cb140-15"></a><span class="op">}</span></span></code></pre></div>
<p>MSVC has <a
href="https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4062?view=msvc-170">Compiler
Warning C4062</a> to detect the issue. To make this warning as error,
use <code>/we4062</code> which shows:</p>
<pre><code>error C4062: enumerator &#39;E3&#39; in switch of enum &#39;MyEnum&#39; is not handled
note: see declaration of &#39;MyEnum&#39;</code></pre>
<p>For Clang/GCC, it’s <a
href="https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html"><code>-Wswitch-enum</code></a>
(note, <code>-Wswitch</code> exists) in a combination with
<code>-Werror</code> OR <code>-Werror=switch-enum</code> to error out
only switch case, similar to what MSVC’s /we4062 does:</p>
<pre><code>error: enumeration value &#39;E3&#39; not handled in switch [-Werror=switch-enum]</code></pre>
<p>See also this <a
href="https://stackoverflow.com/a/63161421/2451677">SO</a>.</p>
<p>Note, usual practice of having <code>COUNT</code> or <code>MAX</code>
enum value - complicates the matter and forces you to handle undesired
case. With C++17, the usual code for handling all cases looks next:</p>
<div class="sourceCode" id="cb143"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb143-1"><a href="#cb143-1"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb143-2"><a href="#cb143-2"></a></span>
<span id="cb143-3"><a href="#cb143-3"></a><span class="kw">enum</span> <span class="kw">class</span> MyEnum <span class="op">{</span> E1<span class="op">,</span> E2<span class="op">,</span> MAX <span class="op">};</span></span>
<span id="cb143-4"><a href="#cb143-4"></a></span>
<span id="cb143-5"><a href="#cb143-5"></a><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> MyProcess<span class="op">(</span>MyEnum e<span class="op">)</span></span>
<span id="cb143-6"><a href="#cb143-6"></a><span class="op">{</span></span>
<span id="cb143-7"><a href="#cb143-7"></a>    <span class="cf">switch</span> <span class="op">(</span>e<span class="op">)</span></span>
<span id="cb143-8"><a href="#cb143-8"></a>    <span class="op">{</span></span>
<span id="cb143-9"><a href="#cb143-9"></a>        <span class="cf">case</span> MyEnum<span class="op">::</span>E1<span class="op">:</span> <span class="cf">return</span> <span class="st">&quot;E1&quot;</span><span class="op">;</span></span>
<span id="cb143-10"><a href="#cb143-10"></a>        <span class="cf">case</span> MyEnum<span class="op">::</span>E2<span class="op">:</span> <span class="cf">return</span> <span class="st">&quot;E2&quot;</span><span class="op">;</span></span>
<span id="cb143-11"><a href="#cb143-11"></a>        <span class="cf">case</span> MyEnum<span class="op">::</span>MAX<span class="op">:</span> <span class="bu">std::</span>unreachable<span class="op">();</span></span>
<span id="cb143-12"><a href="#cb143-12"></a>    <span class="op">}</span></span>
<span id="cb143-13"><a href="#cb143-13"></a>    <span class="bu">std::</span>unreachable<span class="op">();</span></span>
<span id="cb143-14"><a href="#cb143-14"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="97"
id="use-compiler-to-write-down-pointer-to-member-syntax"><span
class="header-section-number">97</span> <a
href="#use-compiler-to-write-down-pointer-to-member-syntax"># </a>use
compiler to write down pointer-to-member syntax</h4>
<p>Just use a wrong type first, see what compiler says, copy the correct
type from the error:</p>
<div class="sourceCode" id="cb144"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb144-1"><a href="#cb144-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb144-2"><a href="#cb144-2"></a><span class="op">{</span></span>
<span id="cb144-3"><a href="#cb144-3"></a>    <span class="dt">int</span> my_data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb144-4"><a href="#cb144-4"></a><span class="op">};</span></span>
<span id="cb144-5"><a href="#cb144-5"></a></span>
<span id="cb144-6"><a href="#cb144-6"></a><span class="dt">int</span> ptr <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>my_data<span class="op">;</span></span></code></pre></div>
<p>All 3 compilers say:</p>
<div class="sourceCode" id="cb145"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb145-1"><a href="#cb145-1"></a>Clang: error: cannot initialize a variable of type &#39;int&#39; with an rvalue of type &#39;int MyClass::*&#39;</span>
<span id="cb145-2"><a href="#cb145-2"></a>GCC  : error: cannot convert &#39;int MyClass::*&#39; to &#39;int&#39; in initialization</span>
<span id="cb145-3"><a href="#cb145-3"></a>MSVC : error C2440: &#39;initializing&#39;: cannot convert from &#39;int MyClass::* &#39; to &#39;int&#39;</span></code></pre></div>
<p>So ptr should be:</p>
<div class="sourceCode" id="cb146"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb146-1"><a href="#cb146-1"></a><span class="dt">int</span> MyClass<span class="op">::*</span>ptr <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>my_data<span class="op">;</span></span>
<span id="cb146-2"><a href="#cb146-2"></a><span class="co">// OR</span></span>
<span id="cb146-3"><a href="#cb146-3"></a><span class="kw">using</span> MyIntMember <span class="op">=</span> <span class="dt">int</span> MyClass<span class="op">::*;</span></span>
<span id="cb146-4"><a href="#cb146-4"></a>MyIntMember ptr <span class="op">=</span> <span class="op">&amp;</span>MyClass<span class="op">::</span>my_data<span class="op">;</span></span></code></pre></div>
<p>Same works for member function pointers, etc.</p>
<h4 data-number="98"
id="all-enum-cases-are-handled-but-its-still-possible-to-fall-out-of-switch"><span
class="header-section-number">98</span> <a
href="#all-enum-cases-are-handled-but-its-still-possible-to-fall-out-of-switch">#
</a>all enum cases are handled, but it’s still possible to fall out of
switch</h4>
<p><a href="https://en.cppreference.com/w/cpp/language/enum">With
C++17</a>, for instance, it’s possible to initialize enum with integer
that does not match any named enum value:</p>
<div class="sourceCode" id="cb147"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb147-1"><a href="#cb147-1"></a><span class="kw">enum</span> byte <span class="op">:</span> <span class="dt">unsigned</span> <span class="dt">char</span> <span class="op">{};</span></span>
<span id="cb147-2"><a href="#cb147-2"></a>byte b<span class="op">{</span><span class="dv">42</span><span class="op">};</span> <span class="co">// OK as of C++17</span></span>
<span id="cb147-3"><a href="#cb147-3"></a></span>
<span id="cb147-4"><a href="#cb147-4"></a><span class="kw">enum</span> <span class="kw">class</span> MyEnum <span class="op">{</span> E1<span class="op">,</span> E2<span class="op">,</span> <span class="op">};</span></span>
<span id="cb147-5"><a href="#cb147-5"></a>MyEnum e<span class="op">{</span><span class="dv">76</span><span class="op">};</span> <span class="co">// OK</span></span></code></pre></div>
<p>meaning that even with all handled cases, it’s possible to fall out
of switch case:</p>
<div class="sourceCode" id="cb148"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb148-1"><a href="#cb148-1"></a><span class="kw">enum</span> <span class="kw">class</span> MyEnum <span class="op">{</span> E1<span class="op">,</span> E2<span class="op">,</span> <span class="op">};</span></span>
<span id="cb148-2"><a href="#cb148-2"></a></span>
<span id="cb148-3"><a href="#cb148-3"></a><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> MyProcess<span class="op">(</span>MyEnum e<span class="op">)</span></span>
<span id="cb148-4"><a href="#cb148-4"></a><span class="op">{</span></span>
<span id="cb148-5"><a href="#cb148-5"></a>    <span class="cf">switch</span> <span class="op">(</span>e<span class="op">)</span></span>
<span id="cb148-6"><a href="#cb148-6"></a>    <span class="op">{</span></span>
<span id="cb148-7"><a href="#cb148-7"></a>        <span class="cf">case</span> MyEnum<span class="op">::</span>E1<span class="op">:</span> <span class="cf">return</span> <span class="st">&quot;E1&quot;</span><span class="op">;</span></span>
<span id="cb148-8"><a href="#cb148-8"></a>        <span class="cf">case</span> MyEnum<span class="op">::</span>E2<span class="op">:</span> <span class="cf">return</span> <span class="st">&quot;E2&quot;</span><span class="op">;</span></span>
<span id="cb148-9"><a href="#cb148-9"></a>    <span class="op">}</span></span>
<span id="cb148-10"><a href="#cb148-10"></a>    <span class="co">// perfectly fine to land there,</span></span>
<span id="cb148-11"><a href="#cb148-11"></a>    <span class="co">// even when compiled with -Werror=switch-enum</span></span>
<span id="cb148-12"><a href="#cb148-12"></a>    <span class="cf">return</span> <span class="st">&quot;&lt;unknown&gt;&quot;</span><span class="op">;</span> <span class="co">// OR std::unreachable()</span></span>
<span id="cb148-13"><a href="#cb148-13"></a><span class="op">}</span></span>
<span id="cb148-14"><a href="#cb148-14"></a></span>
<span id="cb148-15"><a href="#cb148-15"></a>MyProcess<span class="op">(</span>MyEnum<span class="op">{</span><span class="dv">78</span><span class="op">});</span> <span class="co">// perfectly fine</span></span></code></pre></div>
<h4 data-number="99" id="on_scope_exit"><span
class="header-section-number">99</span> <a href="#on_scope_exit">#
</a>ON_SCOPE_EXIT</h4>
<p>See <a
href="https://gist.github.com/maddouri/e22288fe973e107abf5bb775df84779d"
class="uri">https://gist.github.com/maddouri/e22288fe973e107abf5bb775df84779d</a>:</p>
<p><mark>TBD</mark></p>
<pre><code>{
    FILE* f = fopen(&quot;file.txt&quot;, &quot;r&quot;);
    ON_SCOPE_EXIT { fclose(f); }
    // ...    
}</code></pre>
<h4 data-number="100"
id="float-to-double-and-integer-promotions-variadic-function"><span
class="header-section-number">100</span> <a
href="#float-to-double-and-integer-promotions-variadic-function">#
</a>float to double and integer promotions (variadic function)</h4>
<p>For C-style variadic function, each argument of integer type
undergoes integer promotion, and each argument of type float is
implicitly converted to the type double. See <a
href="https://en.cppreference.com/w/c/language/conversion">Implicit
conversions</a>:</p>
<div class="sourceCode" id="cb150"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb150-1"><a href="#cb150-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span><span class="pp">          </span></span>
<span id="cb150-2"><a href="#cb150-2"></a><span class="pp">#include </span><span class="im">&lt;stdarg.h&gt;</span></span>
<span id="cb150-3"><a href="#cb150-3"></a></span>
<span id="cb150-4"><a href="#cb150-4"></a><span class="dt">void</span> MyFoo<span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb150-5"><a href="#cb150-5"></a><span class="op">{</span>   </span>
<span id="cb150-6"><a href="#cb150-6"></a>    <span class="dt">va_list</span> args<span class="op">;</span></span>
<span id="cb150-7"><a href="#cb150-7"></a>    va_start<span class="op">(</span>args<span class="op">,</span> start<span class="op">);</span></span>
<span id="cb150-8"><a href="#cb150-8"></a>    <span class="at">const</span> <span class="dt">double</span> v1 <span class="op">=</span> va_arg<span class="op">(</span>args<span class="op">,</span> <span class="dt">double</span><span class="op">);</span></span>
<span id="cb150-9"><a href="#cb150-9"></a>    <span class="at">const</span> <span class="dt">int</span> v2 <span class="op">=</span> va_arg<span class="op">(</span>args<span class="op">,</span> <span class="dt">int</span><span class="op">);</span></span>
<span id="cb150-10"><a href="#cb150-10"></a>    printf<span class="op">(</span><span class="st">&quot;va_args: </span><span class="sc">%f</span><span class="st">, </span><span class="sc">%i\n</span><span class="st">&quot;</span><span class="op">,</span> v1<span class="op">,</span> v2<span class="op">);</span>    </span>
<span id="cb150-11"><a href="#cb150-11"></a>    va_end<span class="op">(</span>args<span class="op">);</span></span>
<span id="cb150-12"><a href="#cb150-12"></a><span class="op">}</span></span>
<span id="cb150-13"><a href="#cb150-13"></a></span>
<span id="cb150-14"><a href="#cb150-14"></a>MyFoo<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fl">3.3</span><span class="bu">f</span><span class="op">,</span> <span class="ch">&#39;c&#39;</span><span class="op">);</span></span>
<span id="cb150-15"><a href="#cb150-15"></a><span class="co">// va_args: 3.300000, 99</span></span></code></pre></div>
<p><code>3.3f</code> of type float is conveted to double;
<code>'c'</code>, which is char is converted to int so this is why
<code>va_arg(args, double)</code> is used to query <code>v1</code>.
Note, that <code>va_arg(args, float)</code> will at least trigger a
warning:</p>
<div class="sourceCode" id="cb151"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb151-1"><a href="#cb151-1"></a>&gt; warning: second argument to &#39;va_arg&#39; is of promotable type &#39;float&#39;;</span>
<span id="cb151-2"><a href="#cb151-2"></a>&gt; this va_arg has undefined behavior because arguments will</span>
<span id="cb151-3"><a href="#cb151-3"></a>&gt; be promoted to &#39;double&#39; [-Wvarargs]</span></code></pre></div>
<h4 data-number="101"
id="surrogate-call-functions-conversion-operator"><span
class="header-section-number">101</span> <a
href="#surrogate-call-functions-conversion-operator"># </a>surrogate
call functions (/ conversion operator)</h4>
<p>From <a
href="https://timsong-cpp.github.io/cppwp/over.call.object">std/over.call.object</a>:</p>
<div class="sourceCode" id="cb152"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb152-1"><a href="#cb152-1"></a><span class="dt">int</span> f1<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb152-2"><a href="#cb152-2"></a><span class="dt">char</span> f2<span class="op">(</span><span class="dt">float</span><span class="op">);</span></span>
<span id="cb152-3"><a href="#cb152-3"></a></span>
<span id="cb152-4"><a href="#cb152-4"></a><span class="kw">typedef</span> <span class="dt">int</span> <span class="op">(*</span>fp1<span class="op">)(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb152-5"><a href="#cb152-5"></a><span class="kw">typedef</span> <span class="dt">char</span> <span class="op">(*</span>fp2<span class="op">)(</span><span class="dt">float</span><span class="op">);</span></span>
<span id="cb152-6"><a href="#cb152-6"></a></span>
<span id="cb152-7"><a href="#cb152-7"></a><span class="kw">struct</span> A <span class="op">{</span></span>
<span id="cb152-8"><a href="#cb152-8"></a>  <span class="kw">operator</span> fp1<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> f1<span class="op">;</span> <span class="op">}</span></span>
<span id="cb152-9"><a href="#cb152-9"></a>  <span class="kw">operator</span> fp2<span class="op">()</span> <span class="op">{</span> <span class="cf">return</span> f2<span class="op">;</span> <span class="op">}</span></span>
<span id="cb152-10"><a href="#cb152-10"></a><span class="op">}</span> a<span class="op">;</span></span>
<span id="cb152-11"><a href="#cb152-11"></a></span>
<span id="cb152-12"><a href="#cb152-12"></a><span class="dt">int</span> i <span class="op">=</span> a<span class="op">(</span><span class="dv">1</span><span class="op">);</span>       <span class="co">// calls f1 via pointer</span></span>
<span id="cb152-13"><a href="#cb152-13"></a>                    <span class="co">// returned from conversion function</span></span>
<span id="cb152-14"><a href="#cb152-14"></a><span class="dt">char</span> c <span class="op">=</span> a<span class="op">(</span><span class="fl">0.5</span><span class="bu">f</span><span class="op">);</span>   <span class="co">// calls f2</span></span></code></pre></div>
<h4 data-number="102"
id="array_size-function-returning-reference-to-an-array"><span
class="header-section-number">102</span> <a
href="#array_size-function-returning-reference-to-an-array">#
</a>ARRAY_SIZE / function returning reference to an array</h4>
<p>To get size/length/count of c-style static array pre-C++17 constexpr
std::size(), next ARRAY_SIZE macro is used:</p>
<div class="sourceCode" id="cb153"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb153-1"><a href="#cb153-1"></a><span class="co">// no definition needed</span></span>
<span id="cb153-2"><a href="#cb153-2"></a><span class="kw">template</span> <span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="dt">unsigned</span> N<span class="op">&gt;</span></span>
<span id="cb153-3"><a href="#cb153-3"></a><span class="dt">char</span> <span class="op">(&amp;</span>ArraySizeHelper<span class="op">(</span>T <span class="op">(&amp;</span>array<span class="op">)[</span>N<span class="op">]))[</span>N<span class="op">];</span></span>
<span id="cb153-4"><a href="#cb153-4"></a></span>
<span id="cb153-5"><a href="#cb153-5"></a><span class="pp">#define ARRAY_SIZE</span><span class="op">(</span>array<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb153-6"><a href="#cb153-6"></a><span class="pp">    </span><span class="op">(</span><span class="kw">sizeof</span><span class="op">(</span>ArraySizeHelper<span class="op">(</span>array<span class="op">)))</span></span>
<span id="cb153-7"><a href="#cb153-7"></a></span>
<span id="cb153-8"><a href="#cb153-8"></a><span class="dt">int</span> data<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb153-9"><a href="#cb153-9"></a><span class="dt">int</span> copy<span class="op">[</span>ARRAY_SIZE<span class="op">(</span>data<span class="op">)];</span> <span class="co">// ARRAY_SIZE(data) = 4, known at compile time</span></span></code></pre></div>
<p>Compared to “usual” <code>((sizeof(a) / sizeof(*(a)))</code>
definition, ARRAY_SIZE does not allow some missuses (like passing
pointers). See <a
href="https://codereview.chromium.org/501323002/patch/1/10009">old
chromium changelist</a>. Epic’s Unreal Engine has exactly the same
UE_ARRAY_COUNT macro.</p>
<p>Note, with C++17, std::size() should be used instead.</p>
<p>Note, also, how ArraySizeHelper is a function that accepts reference
to array of size N (known at compile time) and returns reference to
array of size N.</p>
<h4 data-number="103" id="infinite-function-pointer-dereference"><span
class="header-section-number">103</span> <a
href="#infinite-function-pointer-dereference"># </a>infinite function
pointer dereference</h4>
<div class="sourceCode" id="cb154"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb154-1"><a href="#cb154-1"></a><span class="dt">void</span> f<span class="op">()</span> <span class="op">{}</span></span>
<span id="cb154-2"><a href="#cb154-2"></a><span class="dt">void</span> <span class="op">(*</span>fp1<span class="op">)()</span> <span class="op">=</span> f<span class="op">;</span></span>
<span id="cb154-3"><a href="#cb154-3"></a><span class="dt">void</span> <span class="op">(*</span>fp2<span class="op">)()</span> <span class="op">=</span> <span class="op">************</span>f<span class="op">;</span> <span class="co">// same as above</span></span></code></pre></div>
<ul>
<li><code>*f</code> has type of reference-to-function:
<code>void (&amp;)()</code></li>
<li><code>f</code> has type of just function-type:
<code>void()</code></li>
<li><code>&amp;f</code> has type of pointer-to-function:
<code>void (*)()</code></li>
</ul>
<p>Function (name), reference-to-function decay to function pointer
implicitly as soon as possible. <code>*f</code> forms a
reference-to-function, but then immediately decayed to
pointer-to-function which then gets converted back to reference
<code>**f</code> and so on.</p>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/pointer">Pointers to
functions</a>, <a
href="https://en.cppreference.com/w/cpp/language/implicit_conversion">Function-to-pointer
conversion</a> and <a
href="https://en.cppreference.com/w/cpp/language/function">Function
declaration</a>.</p>
<h4 data-number="104"
id="historical-schwarz-counter-nifty-counter-static-initialization"><span
class="header-section-number">104</span> <a
href="#historical-schwarz-counter-nifty-counter-static-initialization">#
</a>(historical?) Schwarz Counter / Nifty Counter (static
initialization)</h4>
<p>In the context of <a
href="https://en.cppreference.com/w/cpp/language/siof">Static
Initialization Order Fiasco</a> where global objects constructors from
different ~.cpp files (translation units) are invoked in unspecified
order, Schwarz Counter helps to be sure global object is initialized
before the first use:</p>
<div class="sourceCode" id="cb155"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb155-1"><a href="#cb155-1"></a><span class="co">// my_object.h</span></span>
<span id="cb155-2"><a href="#cb155-2"></a><span class="kw">struct</span> MyObject <span class="op">{</span></span>
<span id="cb155-3"><a href="#cb155-3"></a>  <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb155-4"><a href="#cb155-4"></a>  MyObject<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> src<span class="op">,</span> <span class="dt">int</span> v<span class="op">);</span></span>
<span id="cb155-5"><a href="#cb155-5"></a><span class="op">};</span></span>
<span id="cb155-6"><a href="#cb155-6"></a></span>
<span id="cb155-7"><a href="#cb155-7"></a><span class="at">extern</span> MyObject<span class="op">&amp;</span> o1<span class="op">;</span></span>
<span id="cb155-8"><a href="#cb155-8"></a></span>
<span id="cb155-9"><a href="#cb155-9"></a><span class="kw">struct</span> MyInit <span class="op">{</span></span>
<span id="cb155-10"><a href="#cb155-10"></a>  MyInit<span class="op">();</span></span>
<span id="cb155-11"><a href="#cb155-11"></a>  <span class="op">~</span>MyInit<span class="op">();</span></span>
<span id="cb155-12"><a href="#cb155-12"></a><span class="op">};</span></span>
<span id="cb155-13"><a href="#cb155-13"></a></span>
<span id="cb155-14"><a href="#cb155-14"></a><span class="co">// </span><span class="al">NOTE</span><span class="co">: static in the header - each transtlation unit will get its own copy of my_init.</span></span>
<span id="cb155-15"><a href="#cb155-15"></a><span class="at">static</span> MyInit my_init<span class="op">;</span></span>
<span id="cb155-16"><a href="#cb155-16"></a></span>
<span id="cb155-17"><a href="#cb155-17"></a><span class="co">// o1.cpp</span></span>
<span id="cb155-18"><a href="#cb155-18"></a><span class="pp">#include </span><span class="im">&quot;my_object.h&quot;</span></span>
<span id="cb155-19"><a href="#cb155-19"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb155-20"><a href="#cb155-20"></a></span>
<span id="cb155-21"><a href="#cb155-21"></a><span class="at">static</span> <span class="dt">int</span> counter <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb155-22"><a href="#cb155-22"></a><span class="at">static</span> <span class="kw">alignas</span><span class="op">(</span>MyObject<span class="op">)</span> <span class="dt">char</span> data<span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span>MyObject<span class="op">)];</span></span>
<span id="cb155-23"><a href="#cb155-23"></a><span class="co">// reference to not-yet-initialized memory</span></span>
<span id="cb155-24"><a href="#cb155-24"></a>MyObject<span class="op">&amp;</span> o1 <span class="op">=</span> <span class="kw">reinterpret_cast</span><span class="op">&lt;</span>MyObject<span class="op">&amp;&gt;(</span>data<span class="op">);</span></span>
<span id="cb155-25"><a href="#cb155-25"></a></span>
<span id="cb155-26"><a href="#cb155-26"></a>MyInit<span class="op">::</span>MyInit<span class="op">()</span> <span class="op">{</span></span>
<span id="cb155-27"><a href="#cb155-27"></a>  <span class="cf">if</span> <span class="op">(</span>counter<span class="op">++</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-28"><a href="#cb155-28"></a>    <span class="co">// first initialization</span></span>
<span id="cb155-29"><a href="#cb155-29"></a>    <span class="kw">new</span> <span class="op">(</span>data<span class="op">)</span> MyObject<span class="op">{</span><span class="st">&quot;o1&quot;</span><span class="op">,</span> <span class="dv">865</span><span class="op">};</span></span>
<span id="cb155-30"><a href="#cb155-30"></a>  <span class="op">}</span></span>
<span id="cb155-31"><a href="#cb155-31"></a><span class="op">}</span></span>
<span id="cb155-32"><a href="#cb155-32"></a></span>
<span id="cb155-33"><a href="#cb155-33"></a>MyInit2<span class="op">::~</span>MyInit2<span class="op">()</span> <span class="op">{</span></span>
<span id="cb155-34"><a href="#cb155-34"></a>  <span class="cf">if</span> <span class="op">(--</span>counter <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb155-35"><a href="#cb155-35"></a>    o1<span class="op">.~</span>MyObject<span class="op">();</span></span>
<span id="cb155-36"><a href="#cb155-36"></a>  <span class="op">}</span></span>
<span id="cb155-37"><a href="#cb155-37"></a><span class="op">}</span></span>
<span id="cb155-38"><a href="#cb155-38"></a></span>
<span id="cb155-39"><a href="#cb155-39"></a><span class="co">// main.cpp</span></span>
<span id="cb155-40"><a href="#cb155-40"></a><span class="pp">#include </span><span class="im">&quot;my_object.h&quot;</span><span class="pp"> </span><span class="co">// </span><span class="al">NOTE</span><span class="co">: must be included before the use</span></span>
<span id="cb155-41"><a href="#cb155-41"></a><span class="co">// use o1 anywhere in any global. OK</span></span></code></pre></div>
<p>Note on unspecified order: it’s usually .obj files link order.
Consider MyObject class, where 2 objects are defined in o1.cpp and
o2.cpp files:</p>
<div class="sourceCode" id="cb156"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb156-1"><a href="#cb156-1"></a>// cl o1.cpp o2.cpp main.cpp &amp;&amp; o1.exe</span>
<span id="cb156-2"><a href="#cb156-2"></a>[o1 %0xa0ae40]</span>
<span id="cb156-3"><a href="#cb156-3"></a>[o2 %0xa0ae54]</span>
<span id="cb156-4"><a href="#cb156-4"></a></span>
<span id="cb156-5"><a href="#cb156-5"></a>// cl o2.cpp o1.cpp main.cpp &amp;&amp; o2.exe</span>
<span id="cb156-6"><a href="#cb156-6"></a>[o2 %0xa0ae40]</span>
<span id="cb156-7"><a href="#cb156-7"></a>[o1 %0xa0ae54]</span></code></pre></div>
<p>o1 is initialized first, then comes o2, when linking o1.cpp, o2.cpp.
Swapping link options to o2.cpp, o1.cpp changes the order
(interestingly, memory locations stay the same).</p>
<p>See <a
href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Nifty_Counter">More
C++ Idioms/Nifty Counter</a>.</p>
<p>Note: MSVC STL (and others?) does not use the idiom (relies on
runtime linked first? <mark>TBD</mark>).</p>
<p>Note: may not work in case of precompiled headers use, see <a
href="https://developercommunity.visualstudio.com/t/Schwarz-counter-vs-precompiled-header/1256884">bug
report</a>.</p>
<h4 data-number="105"
id="emulate-concept-passing-as-template-argument"><span
class="header-section-number">105</span> <a
href="#emulate-concept-passing-as-template-argument"># </a>emulate
concept passing as template argument</h4>
<p>From <a
href="https://x.com/krisjusiak/status/1622679895514963970">Kris
Jusiak</a>, <a href="https://t.co/BKRhl1hD9e">godbolt</a>:</p>
<div class="sourceCode" id="cb157"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb157-1"><a href="#cb157-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">class</span> T<span class="op">&gt;</span></span>
<span id="cb157-2"><a href="#cb157-2"></a><span class="kw">concept</span> Fooable <span class="op">=</span> <span class="kw">requires</span><span class="op">(</span>T t<span class="op">)</span> <span class="op">{</span> t<span class="op">.</span>foo<span class="op">;</span> <span class="op">};</span></span>
<span id="cb157-3"><a href="#cb157-3"></a></span>
<span id="cb157-4"><a href="#cb157-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">auto</span> Concept<span class="op">&gt;</span></span>
<span id="cb157-5"><a href="#cb157-5"></a><span class="kw">struct</span> foo <span class="op">{</span></span>
<span id="cb157-6"><a href="#cb157-6"></a>  <span class="kw">auto</span> fn<span class="op">(</span><span class="kw">auto</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb157-7"><a href="#cb157-7"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="kw">requires</span> <span class="op">{</span> Concept<span class="op">(</span>t<span class="op">);</span> <span class="op">});</span></span>
<span id="cb157-8"><a href="#cb157-8"></a>  <span class="op">}</span></span>
<span id="cb157-9"><a href="#cb157-9"></a><span class="op">};</span></span>
<span id="cb157-10"><a href="#cb157-10"></a></span>
<span id="cb157-11"><a href="#cb157-11"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb157-12"><a href="#cb157-12"></a>  <span class="kw">struct</span> Foo <span class="op">{</span></span>
<span id="cb157-13"><a href="#cb157-13"></a>    <span class="dt">int</span> foo<span class="op">{};</span></span>
<span id="cb157-14"><a href="#cb157-14"></a>  <span class="op">};</span></span>
<span id="cb157-15"><a href="#cb157-15"></a>  <span class="kw">struct</span> Bar <span class="op">{};</span></span>
<span id="cb157-16"><a href="#cb157-16"></a>  </span>
<span id="cb157-17"><a href="#cb157-17"></a>  foo<span class="op">&lt;[](</span>Fooable <span class="kw">auto</span><span class="op">){}&gt;</span> f<span class="op">{};</span> <span class="co">// </span><span class="al">NOTE</span><span class="co">: here</span></span>
<span id="cb157-18"><a href="#cb157-18"></a>  f<span class="op">.</span>fn<span class="op">(</span>Foo<span class="op">{});</span></span>
<span id="cb157-19"><a href="#cb157-19"></a>  f<span class="op">.</span>fn<span class="op">(</span>Bar<span class="op">{});</span> <span class="co">// static_assert, contrained not satisfied</span></span>
<span id="cb157-20"><a href="#cb157-20"></a><span class="op">}</span></span></code></pre></div>
</body>
</html>
