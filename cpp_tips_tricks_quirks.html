<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>C++ tips, tricks and quirks.</title>
  <style>
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
    /* CSS for syntax highlighting */
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        background-color: #ffffff;
        color: #a0a0a0;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
    div.sourceCode
      { color: #1f1c1b; background-color: #ffffff; }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span { color: #1f1c1b; } /* Normal */
    code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
    code span.an { color: #ca60ca; } /* Annotation */
    code span.at { color: #0057ae; } /* Attribute */
    code span.bn { color: #b08000; } /* BaseN */
    code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
    code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #924c9d; } /* Char */
    code span.cn { color: #aa5500; } /* Constant */
    code span.co { color: #898887; } /* Comment */
    code span.cv { color: #0095ff; } /* CommentVar */
    code span.do { color: #607880; } /* Documentation */
    code span.dt { color: #0057ae; } /* DataType */
    code span.dv { color: #b08000; } /* DecVal */
    code span.er { color: #bf0303; text-decoration: underline; } /* Error */
    code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
    code span.fl { color: #b08000; } /* Float */
    code span.fu { color: #644a9b; } /* Function */
    code span.im { color: #ff5500; } /* Import */
    code span.in { color: #b08000; } /* Information */
    code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
    code span.op { color: #1f1c1b; } /* Operator */
    code span.ot { color: #006e28; } /* Other */
    code span.pp { color: #006e28; } /* Preprocessor */
    code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
    code span.sc { color: #3daee9; } /* SpecialChar */
    code span.ss { color: #ff5500; } /* SpecialString */
    code span.st { color: #bf0303; } /* String */
    code span.va { color: #0057ae; } /* Variable */
    code span.vs { color: #bf0303; } /* VerbatimString */
    code span.wa { color: #bf0303; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">C++ tips, tricks and quirks.</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#pitfall-of-for-const-pairk-v-kv-my_map"
id="toc-pitfall-of-for-const-pairk-v-kv-my_map"><span
class="toc-section-number">1</span> pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></a></li>
<li><a href="#declare-function-with-typedefusing"
id="toc-declare-function-with-typedefusing"><span
class="toc-section-number">2</span> declare function with
typedef/using</a></li>
<li><a href="#protectedprivate-virtual-functions-override"
id="toc-protectedprivate-virtual-functions-override"><span
class="toc-section-number">3</span> protected/private virtual functions
override</a></li>
<li><a href="#function-try-block" id="toc-function-try-block"><span
class="toc-section-number">4</span> function try block</a></li>
<li><a href="#omiting-public-when-deriving"
id="toc-omiting-public-when-deriving"><span
class="toc-section-number">5</span> omiting <code>public</code> when
deriving</a></li>
<li><a href="#void0-to-force-for-macros"
id="toc-void0-to-force-for-macros"><span
class="toc-section-number">6</span> <code>(void)0</code> to force
<code>;</code> for macros</a></li>
<li><a href="#call-a-method-of-a-template-base-class"
id="toc-call-a-method-of-a-template-base-class"><span
class="toc-section-number">7</span> call a method of a template base
class</a></li>
<li><a href="#default-on-implementation"
id="toc-default-on-implementation"><span
class="toc-section-number">8</span> <code>= default</code> on
implementation</a></li>
<li><a href="#delete-for-free-functions"
id="toc-delete-for-free-functions"><span
class="toc-section-number">9</span> <code>= delete</code> for free
functions</a></li>
<li><a href="#line-and-file-renaming"
id="toc-line-and-file-renaming"><span
class="toc-section-number">10</span> <code>#line</code> and file
renaming</a></li>
<li><a href="#meyers-cons_cast" id="toc-meyers-cons_cast"><span
class="toc-section-number">11</span> Meyers cons_cast</a></li>
<li><a href="#missing-std-and-why-it-still-compiles-adl"
id="toc-missing-std-and-why-it-still-compiles-adl"><span
class="toc-section-number">12</span> missing <code>std::</code> and why
it still compiles (ADL)</a></li>
<li><a href="#why-stl-is-using-stdmove-everywhere"
id="toc-why-stl-is-using-stdmove-everywhere"><span
class="toc-section-number">13</span> why STL is using
<code>::std::move</code> everywhere?</a></li>
<li><a href="#stdshared_ptr-aliasing-constructor"
id="toc-stdshared_ptr-aliasing-constructor"><span
class="toc-section-number">14</span> <code>std::shared_ptr</code>
aliasing constructor</a></li>
<li><a href="#dynamic_castvoid-to-get-most-derived-object"
id="toc-dynamic_castvoid-to-get-most-derived-object"><span
class="toc-section-number">15</span>
<code>dynamic_cast&lt;void*&gt;</code> to get most-derived
object</a></li>
<li><a href="#stdshared_ptrbase-with-no-virtual-destructor"
id="toc-stdshared_ptrbase-with-no-virtual-destructor"><span
class="toc-section-number">16</span>
<code>std::shared_ptr&lt;base&gt;</code> with no virtual
destructor</a></li>
<li><a href="#stateful-metaprogramming"
id="toc-stateful-metaprogramming"><span
class="toc-section-number">17</span> stateful metaprogramming</a></li>
<li><a href="#access-private-members"
id="toc-access-private-members"><span
class="toc-section-number">18</span> access private members</a></li>
<li><a href="#extern-templates" id="toc-extern-templates"><span
class="toc-section-number">19</span> extern templates</a></li>
<li><a href="#templates-in-.cpp-file"
id="toc-templates-in-.cpp-file"><span
class="toc-section-number">20</span> templates in .cpp file</a></li>
<li><a href="#double-template-syntax"
id="toc-double-template-syntax"><span
class="toc-section-number">21</span> double-template syntax</a></li>
<li><a href="#when-type-t-is-bitcopyable"
id="toc-when-type-t-is-bitcopyable"><span
class="toc-section-number">22</span> when type T is
bitcopyable?</a></li>
<li><a href="#pseudo-destructors-int"
id="toc-pseudo-destructors-int"><span
class="toc-section-number">23</span> pseudo destructors (~int)</a></li>
<li><a href="#manually-invoke-constructor"
id="toc-manually-invoke-constructor"><span
class="toc-section-number">24</span> manually invoke
constructor</a></li>
<li><a href="#injected-class-name" id="toc-injected-class-name"><span
class="toc-section-number">25</span> injected-class-name</a></li>
<li><a href="#invoke-base-virtual-function-directly"
id="toc-invoke-base-virtual-function-directly"><span
class="toc-section-number">26</span> invoke base virtual function
directly</a></li>
<li><a href="#perfect-construct-with-factory-function"
id="toc-perfect-construct-with-factory-function"><span
class="toc-section-number">27</span> perfect construct with factory
function</a></li>
<li><a href="#disable-template-argument-deduction"
id="toc-disable-template-argument-deduction"><span
class="toc-section-number">28</span> disable template argument
deduction</a></li>
<li><a href="#priority_tag-for-tag-dispatch"
id="toc-priority_tag-for-tag-dispatch"><span
class="toc-section-number">29</span> priority_tag for tag
dispatch</a></li>
<li><a href="#new-auto10" id="toc-new-auto10"><span
class="toc-section-number">30</span> new auto(10)</a></li>
<li><a href="#stdforward-use-in-stdfunction-like-case"
id="toc-stdforward-use-in-stdfunction-like-case"><span
class="toc-section-number">31</span> <code>std::forward</code> use in
std::function-like case</a></li>
<li><a href="#virtual-functions-default-arguments"
id="toc-virtual-functions-default-arguments"><span
class="toc-section-number">32</span> virtual functions default
arguments</a></li>
<li><a href="#virtual-functions-overloads"
id="toc-virtual-functions-overloads"><span
class="toc-section-number">33</span> virtual functions
overloads</a></li>
<li><a href="#change-base-class-member-access-rights"
id="toc-change-base-class-member-access-rights"><span
class="toc-section-number">34</span> change base class member access
rights</a></li>
<li><a href="#use-default-constructor-for-state-reset"
id="toc-use-default-constructor-for-state-reset"><span
class="toc-section-number">35</span> use default constructor for state
reset</a></li>
<li><a href="#default-constructor-is-a-must-for-modern-c"
id="toc-default-constructor-is-a-must-for-modern-c"><span
class="toc-section-number">36</span> default constructor is a must for
modern C++</a></li>
<li><a href="#default-constructor-must-do-no-work"
id="toc-default-constructor-must-do-no-work"><span
class="toc-section-number">37</span> default constructor must do no
work</a></li>
<li><a href="#constructors-should-do-no-work"
id="toc-constructors-should-do-no-work"><span
class="toc-section-number">38</span> constructors should do no
work</a></li>
<li><a href="#stdunique_ptr-with-decltype-lambda"
id="toc-stdunique_ptr-with-decltype-lambda"><span
class="toc-section-number">39</span> <code>std::unique_ptr</code> with
decltype lambda</a></li>
<li><a href="#auto-vs-auto-for-pointers"
id="toc-auto-vs-auto-for-pointers"><span
class="toc-section-number">40</span> <code>auto</code> vs
<code>auto*</code> for pointers</a></li>
<li><a href="#stdtransform-and-lift-passing-overload-set"
id="toc-stdtransform-and-lift-passing-overload-set"><span
class="toc-section-number">41</span> std::transform and LIFT (passing
overload set)</a></li>
<li><a href="#tolower-is-not-an-addressible-function"
id="toc-tolower-is-not-an-addressible-function"><span
class="toc-section-number">42</span> <code>tolower</code> is not an
addressible function</a></li>
<li><a
href="#replace-operator-new-to-track-third-party-code-allocations"
id="toc-replace-operator-new-to-track-third-party-code-allocations"><span
class="toc-section-number">43</span> replace operator new to track
third-party code allocations</a></li>
<li><a href="#stdshared_ptrvoid-exists"
id="toc-stdshared_ptrvoid-exists"><span
class="toc-section-number">44</span>
<code>std::shared_ptr&lt;void&gt;</code> exists</a></li>
<li><a href="#sync_with_stdio-for-stdout-vs-stdcout"
id="toc-sync_with_stdio-for-stdout-vs-stdcout"><span
class="toc-section-number">45</span> sync_with_stdio for stdout vs
std::cout</a></li>
<li><a href="#stdclog-vs-stdcerr" id="toc-stdclog-vs-stdcerr"><span
class="toc-section-number">46</span> std::clog vs std::cerr</a></li>
<li><a href="#capture-less-lambda-can-be-converted-to-c-function"
id="toc-capture-less-lambda-can-be-converted-to-c-function"><span
class="toc-section-number">47</span> capture-less lambda can be
converted to c-function</a></li>
<li><a href="#to-convert-lambda-to-c-function"
id="toc-to-convert-lambda-to-c-function"><span
class="toc-section-number">48</span> <code>+[](){}</code> to convert
lambda to c-function</a></li>
<li><a href="#virtual-operator-int" id="toc-virtual-operator-int"><span
class="toc-section-number">49</span> virtual operator int</a></li>
<li><a href="#placement-new-emplace_back-pre-c11"
id="toc-placement-new-emplace_back-pre-c11"><span
class="toc-section-number">50</span> placement new emplace_back
pre-C++11</a></li>
<li><a href="#operator--recursion-returning-non-pointer-type"
id="toc-operator--recursion-returning-non-pointer-type"><span
class="toc-section-number">51</span> <code>operator-&gt;</code>
recursion (returning non-pointer type)</a></li>
<li><a href="#move-only-types-and-initializer_list"
id="toc-move-only-types-and-initializer_list"><span
class="toc-section-number">52</span> move-only types and
initializer_list</a></li>
<li><a href="#uniform-initialization-is-not-uniform-use-parentheses-vs"
id="toc-uniform-initialization-is-not-uniform-use-parentheses-vs"><span
class="toc-section-number">53</span> uniform initialization is not
uniform, use parentheses (<code>()</code> vs <code>{}</code>)</a></li>
<li><a href="#move-only-lambda-and-stdfunction"
id="toc-move-only-lambda-and-stdfunction"><span
class="toc-section-number">54</span> move-only lambda and
std::function</a></li>
<li><a href="#stdfunction-issues" id="toc-stdfunction-issues"><span
class="toc-section-number">55</span> std::function issues</a></li>
</ul>
</nav>
<p>To generate this .html out of <a
href="https://raw.githubusercontent.com/grishavanika/grishavanika.github.io/refs/heads/master/cpp_tips_tricks_quirks.md">cpp_tips_tricks_quirks.md</a>:</p>
<pre><code>pandoc -s --toc --toc-depth=4
  --number-sections
  --highlight=kate
  -f markdown -t html
  cpp_tips_tricks_quirks.md
  -o cpp_tips_tricks_quirks.html</code></pre>
<p>Inspired by <a href="https://jorenar.com/blog/less-known-c">Lesser
known tricks, quirks and features of C</a>.</p>
<hr />
<p><mark>TODO</mark></p>
<ul>
<li>non-trivial types in union</li>
<li>no capture needed for globals/const for lambda</li>
<li>overload struct for variant visit (inherit from lambda)</li>
<li>map and modifying keys ub</li>
<li>picewise construct</li>
<li>map[x]</li>
<li>mayers singleton</li>
<li>universal references, mayers</li>
<li>https://gist.github.com/fay59/5ccbe684e6e56a7df8815c3486568f01</li>
<li>https://jorenar.com/blog/less-known-c</li>
<li>http://www.danielvik.com/2010/05/c-language-quirks.html</li>
<li>https://codeforces.com/blog/entry/74684</li>
<li>inherit multiple classes from template, with tags</li>
<li>variadic templates default argument emulation</li>
<li>mixing variadic templates and variadic c</li>
<li>type promotion passing custom type/float to variadic c</li>
<li>dynamic cast reference/pointer</li>
<li>https://andreasfertig.blog/2021/07/cpp20-a-neat-trick-with-consteval/</li>
<li>templates sfinae/enable_if/checks/void_t</li>
<li>https://en.cppreference.com/w/cpp/meta</li>
<li>https://landelare.github.io/2023/01/07/cpp-speedrun.html</li>
<li>https://andreasfertig.com/courses/programming-with-cpp11-to-cpp17/</li>
<li>x-macro</li>
<li>https://www.foonathan.net/2020/05/fold-tricks/</li>
<li>rdbuf, read whole file</li>
<li>rdbuf, redirect:
https://stackoverflow.com/questions/10150468/how-to-redirect-cin-and-cout-to-files</li>
<li>allocconsole, reopen</li>
<li>https://chromium.googlesource.com/chromium/src/base/+/master/strings/stringprintf.h</li>
<li>see chromium/base</li>
<li>see boost/base</li>
<li>see abseil</li>
<li>forcing constexpr to be compile time</li>
<li>type id / magic enum (parsing <code>__PRETTY_FUNCTION__</code>)</li>
<li>swap idiom (unqualified call to swap in generic context)</li>
<li>https://en.wikipedia.org/wiki/Barton%E2%80%93Nackman_trick</li>
<li>https://en.wikipedia.org/wiki/Category:C%2B%2B</li>
<li>http://www.gotw.ca/gotw/076.htm</li>
<li>(go thru idioms, shwartz counter,
https://en.m.wikibooks.org/wiki/More_C++_Idioms)</li>
<li>(go thru shortcuts, like immediately invoked lambda)</li>
<li>see also https://github.com/shafik/cpp_blogs quiz questions</li>
<li>(and https://cppquiz.org/)</li>
<li>relocatable and faster then stl container implementations</li>
<li>https://www.foonathan.net/2016/05/final/</li>
<li>https://www.foonathan.net/2020/10/tricks-default-template-argument/</li>
<li>https://www.foonathan.net/2020/10/iife-metaprogramming/#content</li>
<li><code>static_cast&lt;decltype(args)&gt;(args)...</code> -
https://www.foonathan.net/2020/09/move-forward/#content</li>
<li>Howard Hinnant special member function diagram -
https://www.foonathan.net/2019/02/special-member-functions/#content</li>
<li>modern C++ + value semantics = love</li>
<li>cstdio vs stdio.h and puts vs std::puts</li>
<li><a
href="https://en.cppreference.com/w/cpp/language/direct_initialization#Notes">ambiguity
between a variable declaration and a function declaration</a></li>
<li>note <a
href="https://asawicki.info/news_1739_book_review_c_lambda_story">C++
Lambda Story</a></li>
<li>note <a href="https://www.cppmove.com/">C++ Move Semantics</a></li>
<li>note <a
href="https://asawicki.info/news_1766_book_review_c_initialization_story">Book
review: C++ Initialization Story</a></li>
<li>decltype() vs decltype(())</li>
<li>requires vs requires requires</li>
<li>noexcept vs noexcept(noexcept())</li>
<li><code>declval&lt;T&gt;</code> vs
<code>declval&lt;T&amp;&gt;</code></li>
</ul>
<hr />
<h4 data-number="1" id="pitfall-of-for-const-pairk-v-kv-my_map"><span
class="header-section-number">1</span> pitfall of
<code>for (const pair&lt;K, V&gt;&amp; kv : my_map)</code></h4>
<p>Here, <code>kv</code> is a copy instead of const reference since
std::meow_map <code>value_type</code> is
<code>std::pair&lt;const Key, T&gt;</code>, notice <strong>const
Key</strong>.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// wrong</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb2-3"><a href="#cb2-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p><code>pair&lt;std::string, int&gt;</code> is copy-constructed from
<code>pair&lt;const std::string, int&gt;</code> . Proper version:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">// correct</span></span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span><span class="at">const</span> <span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>Note, <a
href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">AAA
style (Almost Always Auto)</a> recommends to go with
<code>const auto&amp;</code> that also solves the problem (sadly, with
the loss of explicitly written types):</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1"></a><span class="co">// correct</span></span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> kv <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb4-3"><a href="#cb4-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>with C++17 structured binding, it’s also:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1"></a><span class="co">// correct</span></span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>key<span class="op">,</span> value<span class="op">]</span> <span class="op">:</span> my_map<span class="op">)</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>    <span class="co">// ...</span></span></code></pre></div>
<p>See <a href="https://www.reddit.com/user/STL/">/u/STL</a> <a
href="https://www.reddit.com/r/cpp/comments/1fhncm2/comment/lndnk8m/">comments</a>.
Note on /u/STL <a
href="https://brevzin.github.io/c++/2023/03/14/prefer-views-meow/">meow</a>.</p>
<h4 data-number="2" id="declare-function-with-typedefusing"><span
class="header-section-number">2</span> declare function with
typedef/using</h4>
<p>Surprisingly, you can declare a function with using declaration:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">using</span> MyFunction <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">);</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">// same as `void Foo(int);`</span></span>
<span id="cb6-4"><a href="#cb6-4"></a>MyFunction Foo<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5"></a></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">// actual definition</span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="op">}</span></span></code></pre></div>
<p>Notice, Foo is <strong>not</strong> a variable, but function
declaration. Running the code above with
<code>clang -Xclang -ast-dump</code>, shows:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode numberSource numberLines"><code class="sourceCode"><span id="cb7-1"><a href="#cb7-1"></a>`-FunctionDecl 0xcc10e50 &lt;line:4:1, col:12&gt; col:12 Foo &#39;MyFunction&#39;:&#39;void (int)&#39;</span>
<span id="cb7-2"><a href="#cb7-2"></a>  `-ParmVarDecl 0xcc10f10 &lt;col:12&gt; col:12 implicit &#39;int&#39;</span></code></pre></div>
<p>Same can be done to declare a method:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="kw">using</span> MyMethod <span class="op">=</span> <span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">char</span><span class="op">);</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="co">// member function declaration</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    MyMethod Bar<span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co">// equivalent too:</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="co">// void Bar(int);</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="op">};</span></span>
<span id="cb8-9"><a href="#cb8-9"></a></span>
<span id="cb8-10"><a href="#cb8-10"></a><span class="co">// actual definition</span></span>
<span id="cb8-11"><a href="#cb8-11"></a><span class="dt">void</span> MyClass<span class="op">::</span>Bar<span class="op">(</span><span class="dt">int</span><span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12"></a><span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13"></a><span class="op">}</span></span></code></pre></div>
<p>Mentioned at least <a
href="https://www.reddit.com/r/C_Programming/comments/2pkwvf/comment/cmxlx0e">there</a>.
See also:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">typedef</span> <span class="dt">double</span> MyFunction<span class="op">(</span><span class="dt">int</span><span class="op">,</span> <span class="dt">double</span><span class="op">,</span> <span class="dt">float</span><span class="op">);</span></span>
<span id="cb9-2"><a href="#cb9-2"></a>MyFunction foo<span class="op">,</span> bar<span class="op">,</span> baz<span class="op">;</span> <span class="co">// functions declarations</span></span></code></pre></div>
<h4 data-number="3"
id="protectedprivate-virtual-functions-override"><span
class="header-section-number">3</span> protected/private virtual
functions override</h4>
<p>Access rights are resolved at compile-time, virtual function target -
at run-time. It’s perfectly fine to move virtual-override to private
section:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">class</span> MyBase</span>
<span id="cb10-2"><a href="#cb10-2"></a><span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="co">// ...</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="op">};</span></span>
<span id="cb10-7"><a href="#cb10-7"></a></span>
<span id="cb10-8"><a href="#cb10-8"></a><span class="kw">class</span> MyDerived <span class="op">:</span> <span class="kw">public</span> MyBase</span>
<span id="cb10-9"><a href="#cb10-9"></a><span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11"></a>    <span class="co">// note: Foo is private now</span></span>
<span id="cb10-12"><a href="#cb10-12"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="kw">override</span> <span class="op">{}</span></span>
<span id="cb10-13"><a href="#cb10-13"></a><span class="op">};</span></span>
<span id="cb10-14"><a href="#cb10-14"></a></span>
<span id="cb10-15"><a href="#cb10-15"></a><span class="dt">void</span> Use<span class="op">(</span><span class="at">const</span> MyBase<span class="op">&amp;</span> base<span class="op">)</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17"></a>    base<span class="op">.</span>Foo<span class="op">(</span><span class="dv">42</span><span class="op">);</span> <span class="co">// calls override, if any</span></span>
<span id="cb10-18"><a href="#cb10-18"></a><span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19"></a></span>
<span id="cb10-20"><a href="#cb10-20"></a>Use<span class="op">(</span>MyDerived<span class="op">{});</span></span></code></pre></div>
<p>It (a) clean-ups derived classes public API/interface (b) explicitly
signals that function is expected to be invoked from within
framework/base class and (c) does not break Liskov substitution
principle.</p>
<p>In heavy OOP frameworks that rely on inheritance (Unreal Engine, as
an example), it makes sense to make virtual-overrides protected instead
of private so derived class could invoke Super:: version in the
implementation.</p>
<h4 data-number="4" id="function-try-block"><span
class="header-section-number">4</span> function try block</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/try#Function_try_block">cppreference</a>.
Specifically, to handle exceptions for constructor initializer:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1"></a><span class="dt">int</span> Bar<span class="op">()</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="cf">throw</span> <span class="dv">42</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="op">}</span></span>
<span id="cb11-5"><a href="#cb11-5"></a></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="kw">struct</span> MyFoo</span>
<span id="cb11-7"><a href="#cb11-7"></a><span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9"></a> </span>
<span id="cb11-10"><a href="#cb11-10"></a>    MyFoo<span class="op">()</span> <span class="cf">try</span> <span class="op">:</span> data<span class="op">(</span>Bar<span class="op">())</span> <span class="op">{}</span></span>
<span id="cb11-11"><a href="#cb11-11"></a>    <span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb11-12"><a href="#cb11-12"></a>    <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13"></a>        <span class="co">// handles the exception</span></span>
<span id="cb11-14"><a href="#cb11-14"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15"></a><span class="op">};</span></span></code></pre></div>
<p>but also works just fine for regular functions to handle arguments
construction exceptions:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1"></a><span class="dt">void</span> Foo<span class="op">(</span><span class="bu">std::</span>string<span class="op">)</span> <span class="cf">try</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3"></a>    <span class="co">// function body</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="cf">catch</span> <span class="op">(...)</span></span>
<span id="cb12-6"><a href="#cb12-6"></a><span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7"></a>    <span class="co">// exception handling for arguments</span></span>
<span id="cb12-8"><a href="#cb12-8"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="5" id="omiting-public-when-deriving"><span
class="header-section-number">5</span> omiting <code>public</code> when
deriving</h4>
<p>Minor, still, see <a
href="https://en.cppreference.com/w/cpp/language/derived_class">cppreference,
access-specifier</a>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1"></a><span class="kw">struct</span> MyBase <span class="op">{};</span></span>
<span id="cb13-2"><a href="#cb13-2"></a><span class="kw">struct</span> MyDerived1 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : public  MyBase</span></span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="kw">class</span>  MyDerived2 <span class="op">:</span> MyBase <span class="op">{};</span> <span class="co">// same as : private MyBase</span></span></code></pre></div>
<h4 data-number="6" id="void0-to-force-for-macros"><span
class="header-section-number">6</span> <code>(void)0</code> to force
<code>;</code> for macros</h4>
<p>To be consistent and force the user of the macro to put
<code>;</code> at the line end:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb14-1"><a href="#cb14-1"></a><span class="pp">#define MY_FOO</span><span class="op">(</span>MY_INPUT<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb14-2"><a href="#cb14-2"></a><span class="pp">    </span><span class="cf">while</span><span class="pp"> </span><span class="op">(</span><span class="kw">true</span><span class="op">)</span><span class="pp"> </span><span class="op">{</span><span class="pp">       </span><span class="op">\</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="pp">        </span>MY_INPUT<span class="op">;</span><span class="pp">        </span><span class="op">\</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="pp">        </span><span class="cf">break</span><span class="op">;</span><span class="pp">           </span><span class="op">\</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="pp">    </span><span class="op">}</span><span class="pp"> </span><span class="op">(</span><span class="dt">void</span><span class="op">)</span><span class="dv">0</span></span>
<span id="cb14-6"><a href="#cb14-6"></a>    <span class="co">// ^^^^^^</span></span>
<span id="cb14-7"><a href="#cb14-7"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;X&quot;</span><span class="op">));</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>MY_FOO<span class="op">(</span>puts<span class="op">(</span><span class="st">&quot;Y&quot;</span><span class="op">));</span></span></code></pre></div>
<h4 data-number="7" id="call-a-method-of-a-template-base-class"><span
class="header-section-number">7</span> call a method of a template base
class</h4>
<p>See also <a
href="https://yunmingzhang.wordpress.com/2019/01/26/accessing-template-base-class-members-in-c/">Accessing
template base class members in C++</a>.</p>
<p>Given standard code like this:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="op">};</span></span></code></pre></div>
<p>we can call <code>Base::Foo()</code> with no issues. However, in case
when we use templates, Foo() can’t be found. The trick is to use
<code>this-&gt;Foo()</code>. Or <code>MyBase&lt;U&gt;::Foo()</code>:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="dt">void</span> Foo<span class="op">();</span> <span class="op">};</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb16-4"><a href="#cb16-4"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase<span class="op">&lt;</span>U<span class="op">&gt;</span></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6"></a>    <span class="dt">void</span> Bar<span class="op">()</span> <span class="op">{</span> <span class="kw">this</span><span class="op">-&gt;</span>Foo<span class="op">();</span> <span class="op">}</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="op">};</span></span></code></pre></div>
<p><code>this-&gt;Foo()</code> becomes <a
href="https://en.cppreference.com/w/cpp/language/dependent_name">type-dependent
expression</a>.</p>
<h4 data-number="8" id="default-on-implementation"><span
class="header-section-number">8</span> <code>= default</code> on
implementation</h4>
<p>You can default special member functions in the .cpp/out of line
definition:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb17-2"><a href="#cb17-2"></a><span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3"></a>    MyClass<span class="op">();</span></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="op">};</span></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="co">// myclass.cpp, for instance:</span></span>
<span id="cb17-6"><a href="#cb17-6"></a>MyClass<span class="op">::</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span></code></pre></div>
<p>Note, this is almost the same as = default in-place, but makes
constructor user-defined. Sometimes it’s not a desired side effect.
However, it’s nice in case you want to change the body of constructor
later or put breakpoint (since you don’t need to change header and
recompile dependencies, only .cpp file).</p>
<p>Another use-case is to move destructor to .cpp file so you don’t
delete incomplete types:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1"></a><span class="kw">struct</span> MyInterface<span class="op">;</span> <span class="co">// forward-declare</span></span>
<span id="cb18-2"><a href="#cb18-2"></a><span class="kw">struct</span> MyClass</span>
<span id="cb18-3"><a href="#cb18-3"></a><span class="op">{</span></span>
<span id="cb18-4"><a href="#cb18-4"></a>    <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span>MyInterface<span class="op">&gt;</span> my_ptr<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5"></a>    <span class="op">~</span>MyClass<span class="op">();</span></span>
<span id="cb18-6"><a href="#cb18-6"></a><span class="op">};</span></span>
<span id="cb18-7"><a href="#cb18-7"></a><span class="co">// myclass.cpp</span></span>
<span id="cb18-8"><a href="#cb18-8"></a><span class="pp">#include </span><span class="im">&quot;MyInterface.h&quot;</span><span class="pp"> </span><span class="co">// include only now</span></span>
<span id="cb18-9"><a href="#cb18-9"></a>MyClass<span class="op">::~</span>MyClass<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="co">// generate a call to my_ptr.~unique_ptr()</span></span></code></pre></div>
<h4 data-number="9" id="delete-for-free-functions"><span
class="header-section-number">9</span> <code>= delete</code> for free
functions</h4>
<p>You can delete unneeded function overload anywhere:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb19-1"><a href="#cb19-1"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">char</span><span class="op">)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb19-2"><a href="#cb19-2"></a><span class="dt">void</span> MyHandle<span class="op">(</span><span class="dt">int</span><span class="op">);</span></span></code></pre></div>
<p><code>MyHandle('x')</code> does not compile now.</p>
<h4 data-number="10" id="line-and-file-renaming"><span
class="header-section-number">10</span> <code>#line</code> and file
renaming</h4>
<p>See <a
href="https://en.cppreference.com/w/c/preprocessor/line">cppreference</a>:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb20-1"><a href="#cb20-1"></a><span class="co">// main.cpp</span></span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="pp">#include </span><span class="im">&lt;assert.h&gt;</span></span>
<span id="cb20-3"><a href="#cb20-3"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb20-4"><a href="#cb20-4"></a><span class="op">{</span></span>
<span id="cb20-5"><a href="#cb20-5"></a><span class="pp">#line 777 &quot;any_filename.x&quot;</span></span>
<span id="cb20-6"><a href="#cb20-6"></a>    <span class="ot">assert</span><span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb20-7"><a href="#cb20-7"></a><span class="op">}</span></span></code></pre></div>
<p>wich outputs:</p>
<blockquote>
<p>output.s: any_filename.x:777: int main(): Assertion
<code>false</code> failed.</p>
</blockquote>
<p>Note: this could break .pdb(s).<br />
Bonus: what happens if you do <code>#line 4294967295</code>?</p>
<h4 data-number="11" id="meyers-cons_cast"><span
class="header-section-number">11</span> Meyers cons_cast</h4>
<p>To not repeat code inside const and non-const function, <a
href="https://stackoverflow.com/a/123995">see SO</a>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">struct</span> MyArray</span>
<span id="cb21-2"><a href="#cb21-2"></a><span class="op">{</span></span>
<span id="cb21-3"><a href="#cb21-3"></a>    <span class="dt">char</span> data<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb21-4"><a href="#cb21-4"></a></span>
<span id="cb21-5"><a href="#cb21-5"></a>    <span class="at">const</span> <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span> <span class="at">const</span></span>
<span id="cb21-6"><a href="#cb21-6"></a>    <span class="op">{</span></span>
<span id="cb21-7"><a href="#cb21-7"></a>        <span class="ot">assert</span><span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb21-8"><a href="#cb21-8"></a>        <span class="cf">return</span> data<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb21-9"><a href="#cb21-9"></a>    <span class="op">}</span></span>
<span id="cb21-10"><a href="#cb21-10"></a>    <span class="dt">char</span><span class="op">&amp;</span> get<span class="op">(</span><span class="dt">unsigned</span> i<span class="op">)</span></span>
<span id="cb21-11"><a href="#cb21-11"></a>    <span class="op">{</span></span>
<span id="cb21-12"><a href="#cb21-12"></a>        <span class="cf">return</span> <span class="kw">const_cast</span><span class="op">&lt;</span><span class="dt">char</span><span class="op">&amp;&gt;(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="at">const</span> MyArray<span class="op">&amp;&gt;(*</span><span class="kw">this</span><span class="op">).</span>get<span class="op">(</span>i<span class="op">));</span></span>
<span id="cb21-13"><a href="#cb21-13"></a>    <span class="op">}</span></span>
<span id="cb21-14"><a href="#cb21-14"></a><span class="op">};</span></span></code></pre></div>
<p>Note: mutable <code>get()</code> is implemented in terms of const
version, not the other way around (which would be UB).</p>
<p>Kind-a outdated with <a
href="https://devblogs.microsoft.com/cppblog/cpp23-deducing-this/">C++23’s
Deducing this</a> or is it? (template, compile time, .h vs .cpp).</p>
<h4 data-number="12"
id="missing-std-and-why-it-still-compiles-adl"><span
class="header-section-number">12</span> missing <code>std::</code> and
why it still compiles (ADL)</h4>
<p>Notice, that code below will compile (most of the time):</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb22-1"><a href="#cb22-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> vs<span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb22-2"><a href="#cb22-2"></a>sort<span class="op">(</span>vs<span class="op">.</span>begin<span class="op">(),</span> vs<span class="op">.</span>end<span class="op">());</span> <span class="co">// note: missing std:: when calling sort()</span></span></code></pre></div>
<p>Since std::vector iterator lives in namespace <code>std::</code> (*),
ADL will be performed to find std::sort and use it. ADL = <a
href="https://en.cppreference.com/w/cpp/language/adl">Argument-dependent
lookup (ADL), also known as Koenig lookup</a>.</p>
<p>(*) Note, iterator could be just raw pointer (<code>int*</code>) and
it’s implementation defined (?) where or not iterator is inside std.
Meaning the code above is not portable (across different implementations
of STL).</p>
<h4 data-number="13" id="why-stl-is-using-stdmove-everywhere"><span
class="header-section-number">13</span> why STL is using
<code>::std::move</code> everywhere?</h4>
<p>Take a look at <a
href="https://github.com/microsoft/STL/blob/faccf0084ed9b8b58df103358174537233b178c7/stl/inc/algorithm#L452-L453">MSVC’s
implementation of the C++ Standard Library</a>:</p>
<div class="sourceCode" id="cb23" data-startFrom="452"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp" style="counter-reset: source-line 451;"><span id="cb23-452"><a href="#cb23-452"></a>_STD _Seek_wrapped<span class="op">(</span>_First<span class="op">,</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>in<span class="op">));</span></span>
<span id="cb23-453"><a href="#cb23-453"></a><span class="cf">return</span> <span class="op">{</span>_STD move<span class="op">(</span>_First<span class="op">),</span> _STD move<span class="op">(</span>_UResult<span class="op">.</span>fun<span class="op">)};</span></span></code></pre></div>
<p>_STD is <code>#define _STD ::std::</code>. Why?</p>
<p>So <code>::std::move</code> is used to <strong>disable</strong> ADL
and make sure implementation of <code>move</code> from namespace
<code>std</code> is choosen. Who knows what user-defined custom type
could bring into the table?</p>
<h4 data-number="14" id="stdshared_ptr-aliasing-constructor"><span
class="header-section-number">14</span> <code>std::shared_ptr</code>
aliasing constructor</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/memory/shared_ptr/shared_ptr">aliasing
constructor</a>:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">struct</span> MyType</span>
<span id="cb24-2"><a href="#cb24-2"></a><span class="op">{</span></span>
<span id="cb24-3"><a href="#cb24-3"></a>    <span class="dt">int</span> data<span class="op">;</span></span>
<span id="cb24-4"><a href="#cb24-4"></a><span class="op">};</span></span>
<span id="cb24-5"><a href="#cb24-5"></a></span>
<span id="cb24-6"><a href="#cb24-6"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyType<span class="op">&gt;</span> v1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyType<span class="op">&gt;();</span></span>
<span id="cb24-7"><a href="#cb24-7"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> v2<span class="op">{</span>v1<span class="op">,</span> <span class="op">&amp;</span>v1<span class="op">-&gt;</span>data<span class="op">};</span></span></code></pre></div>
<p>v2 and v1 now share the same control block. You can also put a
pointer to unrelative data (is there real-life use-case?).</p>
<h4 data-number="15"
id="dynamic_castvoid-to-get-most-derived-object"><span
class="header-section-number">15</span>
<code>dynamic_cast&lt;void*&gt;</code> to get most-derived object</h4>
<p>From anywhere in the hierarhy of polimorphic type, you can restore a
pointer to most-derived instance (i.e., the one created by
<code>new</code> initially):</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb25-1"><a href="#cb25-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="kw">virtual</span> <span class="op">~</span>MyBase<span class="op">()</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span> <span class="op">};</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase <span class="op">{};</span></span>
<span id="cb25-3"><a href="#cb25-3"></a></span>
<span id="cb25-4"><a href="#cb25-4"></a>MyDerived<span class="op">*</span> original_ptr <span class="op">=</span> <span class="kw">new</span> MyDerived<span class="op">{};</span></span>
<span id="cb25-5"><a href="#cb25-5"></a></span>
<span id="cb25-6"><a href="#cb25-6"></a>MyBase<span class="op">*</span> base_ptr <span class="op">=</span> original_ptr<span class="op">;</span></span>
<span id="cb25-7"><a href="#cb25-7"></a><span class="dt">void</span><span class="op">*</span> void_ptr <span class="op">=</span> <span class="kw">dynamic_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>base_ptr<span class="op">);</span></span>
<span id="cb25-8"><a href="#cb25-8"></a></span>
<span id="cb25-9"><a href="#cb25-9"></a><span class="ot">assert</span><span class="op">(</span>void_ptr <span class="op">==</span> original_ptr<span class="op">);</span></span></code></pre></div>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/dynamic_cast">cppreference</a>.
Most-likely useful to interop with C library/external code.</p>
<h4 data-number="16"
id="stdshared_ptrbase-with-no-virtual-destructor"><span
class="header-section-number">16</span>
<code>std::shared_ptr&lt;base&gt;</code> with no virtual destructor</h4>
<p>Usually, if you delete pointer-to-base, destructor needs to be
declared virtual so proper destructor is invoked. Hovewer, for
std::shared_ptr this is not required:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb26-1"><a href="#cb26-1"></a><span class="kw">struct</span> MyBase <span class="op">{</span> <span class="op">~</span>MyBase<span class="op">();</span> <span class="op">};</span> <span class="co">// no virtual!</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb26-3"><a href="#cb26-3"></a><span class="op">{</span></span>
<span id="cb26-4"><a href="#cb26-4"></a>    <span class="op">~</span>MyDerived<span class="op">()</span> <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;~MyDerived()&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="op">};</span></span>
<span id="cb26-6"><a href="#cb26-6"></a></span>
<span id="cb26-7"><a href="#cb26-7"></a><span class="op">{</span></span>
<span id="cb26-8"><a href="#cb26-8"></a>    <span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyBase<span class="op">&gt;</span> ptr <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyDerived<span class="op">&gt;();</span>    </span>
<span id="cb26-9"><a href="#cb26-9"></a><span class="op">}</span> <span class="co">// invokes ~MyDerived()</span></span></code></pre></div>
<p><code>std::shared_ptr&lt;MyBase&gt;</code> holds <code>MyBase*</code>
pointer, but has <a
href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">type-erased</a>
destroy function that remembers the actual type it was created with.</p>
<p>See also <a href="http://www.gotw.ca/gotw/005.htm">GotW #5,
Overriding Virtual Functions</a>:</p>
<blockquote>
<p>Make base class destructors virtual</p>
</blockquote>
<h4 data-number="17" id="stateful-metaprogramming"><span
class="header-section-number">17</span> stateful metaprogramming</h4>
<p>This <a href="https://b.atch.se/posts/constexpr-counter/">works</a>
and a and b have different values:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb27-1"><a href="#cb27-1"></a><span class="dt">int</span> main <span class="op">()</span> <span class="op">{</span></span>
<span id="cb27-2"><a href="#cb27-2"></a>  <span class="kw">constexpr</span> <span class="dt">int</span> a <span class="op">=</span> f<span class="op">();</span></span>
<span id="cb27-3"><a href="#cb27-3"></a>  <span class="kw">constexpr</span> <span class="dt">int</span> b <span class="op">=</span> f<span class="op">();</span></span>
<span id="cb27-4"><a href="#cb27-4"></a></span>
<span id="cb27-5"><a href="#cb27-5"></a>  <span class="kw">static_assert</span><span class="op">(</span>a <span class="op">!=</span> b<span class="op">);</span></span>
<span id="cb27-6"><a href="#cb27-6"></a><span class="op">}</span></span></code></pre></div>
<p>See, for instance, <a
href="https://mc-deltat.github.io/articles/stateful-metaprogramming-cpp20">Revisiting
Stateful Metaprogramming in C++20</a>:</p>
<ul>
<li><a
href="https://b.atch.se/posts/constexpr-counter/">constant-expression
counter</a></li>
<li><a
href="https://b.atch.se/posts/constexpr-meta-container/">compile-time
list</a></li>
<li><a
href="https://b.atch.se/posts/non-constant-constant-expressions/">nonconstant
constant expressions</a></li>
<li><a
href="https://www.open-std.org/jtc1/sc22/wg21/docs/cwg%5Factive.html#2118">stateful
metaprogramming via friend injection</a></li>
<li><a
href="https://www.worldcadaccess.com/blog/2020/05/how-to-hack-c-with-templates-and-friends.html">hack
C++ with templates and friends</a></li>
</ul>
<h4 data-number="18" id="access-private-members"><span
class="header-section-number">18</span> access private members</h4>
<p>See <a href="https://github.com/martong/access_private">this</a> for
more details and explanations. Similar to stateful metaprogramming.</p>
<p>Example <a href="https://github.com/schaumb/access_private_20">from
C++20 version</a>:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb28-1"><a href="#cb28-1"></a><span class="kw">class</span> A <span class="op">{</span></span>
<span id="cb28-2"><a href="#cb28-2"></a>  <span class="dt">int</span> <span class="va">m_i</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb28-3"><a href="#cb28-3"></a>  <span class="dt">int</span> <span class="va">m_f</span><span class="op">(</span><span class="dt">int</span> p<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">14</span> <span class="op">*</span> p<span class="op">;</span> <span class="op">}</span></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="op">};</span></span>
<span id="cb28-5"><a href="#cb28-5"></a></span>
<span id="cb28-6"><a href="#cb28-6"></a><span class="kw">template</span> <span class="kw">struct</span> access_private<span class="op">::</span>access<span class="op">&lt;&amp;</span>A<span class="op">::</span><span class="va">m_i</span><span class="op">&gt;;</span></span>
<span id="cb28-7"><a href="#cb28-7"></a></span>
<span id="cb28-8"><a href="#cb28-8"></a><span class="dt">void</span> foo<span class="op">()</span> <span class="op">{</span></span>
<span id="cb28-9"><a href="#cb28-9"></a>  A a<span class="op">;</span></span>
<span id="cb28-10"><a href="#cb28-10"></a>  <span class="kw">auto</span> <span class="op">&amp;</span>i <span class="op">=</span> access_private<span class="op">::</span>accessor<span class="op">&lt;</span><span class="st">&quot;m_i&quot;</span><span class="op">&gt;(</span>a<span class="op">);</span></span>
<span id="cb28-11"><a href="#cb28-11"></a>  <span class="ot">assert</span><span class="op">(</span>i <span class="op">==</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb28-12"><a href="#cb28-12"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="19" id="extern-templates"><span
class="header-section-number">19</span> extern templates</h4>
<p>See, <a
href="https://isocpp.org/wiki/faq/cpp11-language-templates#extern-templates">this</a>
or <a
href="https://en.cppreference.com/w/cpp/language/class_template">cppreference</a>.</p>
<p>Allows to declare some set of template instantiations and actually
intantiate them in another place. Usually, you extern template in the
header and instantiate in <strong>your own</strong>/library .cpp
file:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb29-1"><a href="#cb29-1"></a><span class="co">// myvector.h</span></span>
<span id="cb29-2"><a href="#cb29-2"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb29-3"><a href="#cb29-3"></a><span class="kw">class</span> MyVector <span class="op">{</span> <span class="co">/**/</span> <span class="op">};</span></span>
<span id="cb29-4"><a href="#cb29-4"></a></span>
<span id="cb29-5"><a href="#cb29-5"></a><span class="co">// declare frequently used instantiations</span></span>
<span id="cb29-6"><a href="#cb29-6"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb29-7"><a href="#cb29-7"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb29-8"><a href="#cb29-8"></a><span class="at">extern</span> <span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;;</span></span>
<span id="cb29-9"><a href="#cb29-9"></a></span>
<span id="cb29-10"><a href="#cb29-10"></a><span class="co">// myvector.cpp</span></span>
<span id="cb29-11"><a href="#cb29-11"></a><span class="pp">#include </span><span class="im">&quot;myvector.h&quot;</span></span>
<span id="cb29-12"><a href="#cb29-12"></a></span>
<span id="cb29-13"><a href="#cb29-13"></a><span class="co">// instantiate frequent cases **once**;</span></span>
<span id="cb29-14"><a href="#cb29-14"></a><span class="co">// client needs to link with myvector.o</span></span>
<span id="cb29-15"><a href="#cb29-15"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;;</span></span>
<span id="cb29-16"><a href="#cb29-16"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">float</span><span class="op">&gt;;</span></span>
<span id="cb29-17"><a href="#cb29-17"></a><span class="kw">template</span> <span class="kw">class</span> MyVector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;;</span></span></code></pre></div>
<p>C++ had also never implemeted C++98 <a
href="https://en.cppreference.com/w/cpp/keyword/export">export
keyword</a> (C++98, nothing to do with <a
href="https://en.cppreference.com/w/cpp/language/modules">modules</a>).</p>
<h4 data-number="20" id="templates-in-.cpp-file"><span
class="header-section-number">20</span> templates in .cpp file</h4>
<p>It’s usually stated that templates could only be defined in header
file. However, you just need to define them anywhere so definition is
visible at the point of use/instantiation.</p>
<p>For intance, this works just fine:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb30-1"><a href="#cb30-1"></a><span class="co">// myclass.h</span></span>
<span id="cb30-2"><a href="#cb30-2"></a><span class="kw">class</span> MyClass</span>
<span id="cb30-3"><a href="#cb30-3"></a><span class="op">{</span></span>
<span id="cb30-4"><a href="#cb30-4"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb30-5"><a href="#cb30-5"></a>    <span class="dt">int</span> Foo<span class="op">();</span></span>
<span id="cb30-6"><a href="#cb30-6"></a></span>
<span id="cb30-7"><a href="#cb30-7"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb30-8"><a href="#cb30-8"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb30-9"><a href="#cb30-9"></a>    <span class="dt">int</span> Bar<span class="op">();</span></span>
<span id="cb30-10"><a href="#cb30-10"></a><span class="op">};</span></span>
<span id="cb30-11"><a href="#cb30-11"></a></span>
<span id="cb30-12"><a href="#cb30-12"></a><span class="co">// myclass.cpp</span></span>
<span id="cb30-13"><a href="#cb30-13"></a><span class="co">// template class, defined in this .cpp file</span></span>
<span id="cb30-14"><a href="#cb30-14"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb30-15"><a href="#cb30-15"></a><span class="kw">struct</span> MyHelper <span class="op">{};</span></span>
<span id="cb30-16"><a href="#cb30-16"></a></span>
<span id="cb30-17"><a href="#cb30-17"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb30-18"><a href="#cb30-18"></a><span class="dt">int</span> MyClass<span class="op">::</span>Bar<span class="op">()</span></span>
<span id="cb30-19"><a href="#cb30-19"></a><span class="op">{</span></span>
<span id="cb30-20"><a href="#cb30-20"></a>    <span class="co">// definition of member-function-template Bar();</span></span>
<span id="cb30-21"><a href="#cb30-21"></a>    <span class="co">// also, the use of MyHelper template above,</span></span>
<span id="cb30-22"><a href="#cb30-22"></a>    <span class="co">// visible only to this transtlation unit</span></span>
<span id="cb30-23"><a href="#cb30-23"></a>    <span class="cf">return</span> <span class="kw">sizeof</span><span class="op">(</span>MyHelper<span class="op">&lt;</span>T<span class="op">&gt;{});</span></span>
<span id="cb30-24"><a href="#cb30-24"></a><span class="op">}</span></span>
<span id="cb30-25"><a href="#cb30-25"></a></span>
<span id="cb30-26"><a href="#cb30-26"></a><span class="dt">int</span> MyClass<span class="op">::</span>Foo<span class="op">()</span></span>
<span id="cb30-27"><a href="#cb30-27"></a><span class="op">{</span></span>
<span id="cb30-28"><a href="#cb30-28"></a>    <span class="co">// use of function template</span></span>
<span id="cb30-29"><a href="#cb30-29"></a>    <span class="cf">return</span> Bar<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;();</span></span>
<span id="cb30-30"><a href="#cb30-30"></a><span class="op">}</span></span></code></pre></div>
<p>See also <a href="#extern-templates">extern templates</a>.</p>
<h4 data-number="21" id="double-template-syntax"><span
class="header-section-number">21</span> double-template syntax</h4>
<p>If you have template class that has template member function and you
want to define such function out-of-class, you need:</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1<span class="op">,</span> <span class="kw">typename</span> T2<span class="op">&gt;</span></span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">class</span> MyClass</span>
<span id="cb31-3"><a href="#cb31-3"></a><span class="op">{</span></span>
<span id="cb31-4"><a href="#cb31-4"></a>    <span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span></span>
<span id="cb31-5"><a href="#cb31-5"></a>    <span class="dt">void</span> Foo<span class="op">(</span>U v<span class="op">);</span></span>
<span id="cb31-6"><a href="#cb31-6"></a><span class="op">};</span></span>
<span id="cb31-7"><a href="#cb31-7"></a></span>
<span id="cb31-8"><a href="#cb31-8"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T1<span class="op">,</span> <span class="kw">typename</span> T2<span class="op">&gt;</span>  <span class="co">// for MyClass</span></span>
<span id="cb31-9"><a href="#cb31-9"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> U<span class="op">&gt;</span>                <span class="co">// for Foo</span></span>
<span id="cb31-10"><a href="#cb31-10"></a><span class="dt">void</span> MyClass<span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">&gt;::</span>Foo<span class="op">(</span>U v<span class="op">)</span> <span class="op">{}</span></span></code></pre></div>
<h4 data-number="22" id="when-type-t-is-bitcopyable"><span
class="header-section-number">22</span> when type T is bitcopyable?</h4>
<p>When implementors do use memcopy/memmove to construct/assign range of
values for some user-defined type T? Use
<code>std::is_trivially_*</code> <a
href="https://en.cppreference.com/w/cpp/meta">type traits</a> to query
the property:</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb32-1"><a href="#cb32-1"></a><span class="kw">struct</span> MyType</span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="op">{</span></span>
<span id="cb32-3"><a href="#cb32-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb32-4"><a href="#cb32-4"></a>    <span class="dt">char</span> str<span class="op">[</span><span class="dv">4</span><span class="op">]{};</span></span>
<span id="cb32-5"><a href="#cb32-5"></a><span class="op">};</span></span>
<span id="cb32-6"><a href="#cb32-6"></a></span>
<span id="cb32-7"><a href="#cb32-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="op">{</span></span>
<span id="cb32-9"><a href="#cb32-9"></a>    MyType v1<span class="op">{</span><span class="dv">42</span><span class="op">};</span></span>
<span id="cb32-10"><a href="#cb32-10"></a>    MyType v2<span class="op">{</span><span class="dv">66</span><span class="op">};</span></span>
<span id="cb32-11"><a href="#cb32-11"></a></span>
<span id="cb32-12"><a href="#cb32-12"></a>    <span class="kw">static_assert</span><span class="op">(</span><span class="bu">std::</span>is_trivially_copy_assignable<span class="op">&lt;</span>MyType<span class="op">&gt;{});</span></span>
<span id="cb32-13"><a href="#cb32-13"></a>    <span class="bu">std::</span>memcpy<span class="op">(&amp;</span>v1<span class="op">,</span> <span class="op">&amp;</span>v2<span class="op">,</span> <span class="kw">sizeof</span><span class="op">(</span>v1<span class="op">));</span> <span class="co">// fine</span></span>
<span id="cb32-14"><a href="#cb32-14"></a>    <span class="ot">assert</span><span class="op">(</span>v1<span class="op">.</span>data <span class="op">==</span> <span class="dv">66</span><span class="op">);</span></span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="op">}</span></span></code></pre></div>
<p>Overall, see also <a
href="https://en.cppreference.com/w/cpp/memory/uninitialized_copy">std::uninitialized_*</a>
memory management and <a
href="https://en.cppreference.com/w/cpp/algorithm/copy">std::copy
algorithm</a> and/or analogs that are already optimized for trivial/pod
types by your standard library implementation for you.</p>
<h4 data-number="23" id="pseudo-destructors-int"><span
class="header-section-number">23</span> pseudo destructors (~int)</h4>
<p>In generic context, it’s possible to invoke the destructor of
int:</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb33-1"><a href="#cb33-1"></a><span class="kw">using</span> MyInt <span class="op">=</span> <span class="dt">int</span><span class="op">;</span></span>
<span id="cb33-2"><a href="#cb33-2"></a>MyInt v <span class="op">=</span> <span class="dv">86</span><span class="op">;</span></span>
<span id="cb33-3"><a href="#cb33-3"></a>v<span class="op">.~</span>MyInt<span class="op">();</span></span></code></pre></div>
<p>which is no-op. See <a
href="https://en.cppreference.com/w/cpp/language/destructor#Notes">destructor</a>
and <a
href="https://en.cppreference.com/w/cpp/language/operator_member_access#Built-in_member_access_operators">built-in
member access operators</a>. Exists so you don’t need to special-case
destructor call in generic/template code.</p>
<h4 data-number="24" id="manually-invoke-constructor"><span
class="header-section-number">24</span> manually invoke constructor</h4>
<p>In the same way you can call destructor manually, you can call
constructor:</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb34-1"><a href="#cb34-1"></a><span class="kw">alignas</span><span class="op">(</span>T<span class="op">)</span> <span class="dt">unsigned</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="kw">sizeof</span><span class="op">(</span>T<span class="op">)];</span></span>
<span id="cb34-2"><a href="#cb34-2"></a>T<span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span><span class="op">(</span><span class="kw">static_cast</span><span class="op">&lt;</span><span class="dt">void</span><span class="op">*&gt;(</span>buffer<span class="op">))</span> T<span class="op">;</span> <span class="co">// call constructor</span></span>
<span id="cb34-3"><a href="#cb34-3"></a>ptr<span class="op">-&gt;~</span>T<span class="op">();</span>                                  <span class="co">// call destructor</span></span></code></pre></div>
<p>which is <a
href="https://en.cppreference.com/w/cpp/lanzguage/new#Placement_new">placement
new</a>.</p>
<p>Note on the use of <code>static_cast&lt;void*&gt;</code> - while not
needed in this example, it’s needed to be done in generic context to
avoid invoking overloaded version of new, if any.</p>
<h4 data-number="25" id="injected-class-name"><span
class="header-section-number">25</span> injected-class-name</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/injected-class-name">cppreference</a>.
In short, every class has its own name inside the class itself. Which
happens to apply recursively. This leads to surprising syntax noone
uses:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb35-1"><a href="#cb35-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb35-2"><a href="#cb35-2"></a><span class="op">{</span></span>
<span id="cb35-3"><a href="#cb35-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>    <span class="dt">void</span> Foo<span class="op">();</span></span>
<span id="cb35-5"><a href="#cb35-5"></a><span class="op">};</span></span>
<span id="cb35-6"><a href="#cb35-6"></a></span>
<span id="cb35-7"><a href="#cb35-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb35-8"><a href="#cb35-8"></a><span class="op">{</span></span>
<span id="cb35-9"><a href="#cb35-9"></a>    MyClass m<span class="op">;</span></span>
<span id="cb35-10"><a href="#cb35-10"></a>    <span class="co">// access m.data</span></span>
<span id="cb35-11"><a href="#cb35-11"></a>    m<span class="op">.</span>MyClass<span class="op">::</span>data <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb35-12"><a href="#cb35-12"></a>    <span class="ot">assert</span><span class="op">(</span>m<span class="op">.</span>data <span class="op">==</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb35-13"><a href="#cb35-13"></a>    <span class="co">// now with recursion</span></span>
<span id="cb35-14"><a href="#cb35-14"></a>    m<span class="op">.</span>MyClass<span class="op">::</span>MyClass<span class="op">::</span>MyClass<span class="op">::</span>data <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb35-15"><a href="#cb35-15"></a>    <span class="ot">assert</span><span class="op">(</span>m<span class="op">.</span>data <span class="op">==</span> <span class="dv">7</span><span class="op">);</span></span>
<span id="cb35-16"><a href="#cb35-16"></a>    <span class="co">// call a member function</span></span>
<span id="cb35-17"><a href="#cb35-17"></a>    MyClass<span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>m<span class="op">;</span></span>
<span id="cb35-18"><a href="#cb35-18"></a>    ptr<span class="op">-&gt;</span>MyClass<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb35-19"><a href="#cb35-19"></a><span class="op">}</span></span></code></pre></div>
<p>For templates, this allows to reference class type without specifying
template arguments.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb36-1"><a href="#cb36-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">,</span> <span class="kw">typename</span> A<span class="op">&gt;</span></span>
<span id="cb36-2"><a href="#cb36-2"></a><span class="kw">struct</span> MyVector</span>
<span id="cb36-3"><a href="#cb36-3"></a><span class="op">{</span></span>
<span id="cb36-4"><a href="#cb36-4"></a>    <span class="co">// same as Self = MyVector&lt;T, A&gt;</span></span>
<span id="cb36-5"><a href="#cb36-5"></a>    <span class="kw">using</span> Self <span class="op">=</span> MyVector<span class="op">;</span></span>
<span id="cb36-6"><a href="#cb36-6"></a><span class="op">};</span></span></code></pre></div>
<h4 data-number="26" id="invoke-base-virtual-function-directly"><span
class="header-section-number">26</span> invoke base virtual function
directly</h4>
<p>Given an instance of derived class, one can skip invoking its own
function override and call parent function directly (see <a
href="#injected-class-name">injected-class-name</a>):</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb37-1"><a href="#cb37-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="op">{</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">()</span></span>
<span id="cb37-4"><a href="#cb37-4"></a>    <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;MyBase&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb37-5"><a href="#cb37-5"></a><span class="op">};</span></span>
<span id="cb37-6"><a href="#cb37-6"></a></span>
<span id="cb37-7"><a href="#cb37-7"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb37-8"><a href="#cb37-8"></a><span class="op">{</span></span>
<span id="cb37-9"><a href="#cb37-9"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">()</span> <span class="kw">override</span></span>
<span id="cb37-10"><a href="#cb37-10"></a>    <span class="op">{</span> <span class="bu">std::</span>puts<span class="op">(</span><span class="st">&quot;MyDerived&quot;</span><span class="op">);</span> <span class="op">}</span></span>
<span id="cb37-11"><a href="#cb37-11"></a><span class="op">};</span></span>
<span id="cb37-12"><a href="#cb37-12"></a></span>
<span id="cb37-13"><a href="#cb37-13"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb37-14"><a href="#cb37-14"></a><span class="op">{</span></span>
<span id="cb37-15"><a href="#cb37-15"></a>    MyDerived derived<span class="op">;</span></span>
<span id="cb37-16"><a href="#cb37-16"></a>    derived<span class="op">.</span>MyBase<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb37-17"><a href="#cb37-17"></a>    MyDerived<span class="op">*</span> ptr <span class="op">=</span> <span class="op">&amp;</span>derived<span class="op">;</span></span>
<span id="cb37-18"><a href="#cb37-18"></a>    ptr<span class="op">-&gt;</span>MyBase<span class="op">::</span>Foo<span class="op">();</span></span>
<span id="cb37-19"><a href="#cb37-19"></a><span class="op">}</span></span></code></pre></div>
<p>This will print <code>MyBase</code> 2 times since we explicitly call
MyBase::Foo().</p>
<h4 data-number="27" id="perfect-construct-with-factory-function"><span
class="header-section-number">27</span> perfect construct with factory
function</h4>
<p>See <code>class rvalue</code> trick discussed <a
href="https://akrzemi1.wordpress.com/2018/05/16/rvalues-redefined/">there</a>;
see same trick discussed in <a
href="https://groups.google.com/a/isocpp.org/g/std-proposals/c/hQ654zTNyiM">guaranteed
copy elision in C++17</a>.</p>
<p>In short, we can return non-copyable/non-movable type from a
function:</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb38-1"><a href="#cb38-1"></a><span class="kw">struct</span> Widget</span>
<span id="cb38-2"><a href="#cb38-2"></a><span class="op">{</span></span>
<span id="cb38-3"><a href="#cb38-3"></a>    <span class="kw">explicit</span> Widget<span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">{}</span></span>
<span id="cb38-4"><a href="#cb38-4"></a>    Widget<span class="op">(</span><span class="at">const</span> Widget<span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb38-5"><a href="#cb38-5"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span><span class="at">const</span> Widget<span class="op">&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb38-6"><a href="#cb38-6"></a>    Widget<span class="op">(</span>Widget<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb38-7"><a href="#cb38-7"></a>    Widget<span class="op">&amp;</span> <span class="kw">operator</span><span class="op">=(</span>Widget<span class="op">&amp;&amp;)</span> <span class="op">=</span> <span class="kw">delete</span><span class="op">;</span></span>
<span id="cb38-8"><a href="#cb38-8"></a><span class="op">};</span></span>
<span id="cb38-9"><a href="#cb38-9"></a></span>
<span id="cb38-10"><a href="#cb38-10"></a>Widget MakeWidget<span class="op">()</span></span>
<span id="cb38-11"><a href="#cb38-11"></a><span class="op">{</span></span>
<span id="cb38-12"><a href="#cb38-12"></a>    <span class="cf">return</span> Widget<span class="op">{</span><span class="dv">68</span><span class="op">};</span> <span class="co">// works</span></span>
<span id="cb38-13"><a href="#cb38-13"></a><span class="op">}</span></span>
<span id="cb38-14"><a href="#cb38-14"></a></span>
<span id="cb38-15"><a href="#cb38-15"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb38-16"><a href="#cb38-16"></a><span class="op">{</span></span>
<span id="cb38-17"><a href="#cb38-17"></a>    Widget w <span class="op">=</span> MakeWidget<span class="op">();</span> <span class="co">// works</span></span>
<span id="cb38-18"><a href="#cb38-18"></a><span class="op">}</span></span></code></pre></div>
<p>However, how to construct, let say
<code>std::optional&lt;Widget&gt;</code>? That does not work:</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb39-1"><a href="#cb39-1"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb39-2"><a href="#cb39-2"></a><span class="op">{</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o1<span class="op">{</span>MakeWidget<span class="op">()};</span> <span class="co">// does not compile</span></span>
<span id="cb39-4"><a href="#cb39-4"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o2<span class="op">;</span></span>
<span id="cb39-5"><a href="#cb39-5"></a>    o2<span class="op">.</span>emplace<span class="op">(</span>MakeWidget<span class="op">());</span> <span class="co">// does not compile</span></span>
<span id="cb39-6"><a href="#cb39-6"></a><span class="op">}</span></span></code></pre></div>
<p>The trick is to use any type that has <a
href="https://en.cppreference.com/w/cpp/language/cast_operator">implicit
conversion operator</a>:</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb40-1"><a href="#cb40-1"></a><span class="kw">struct</span> WidgetFactory</span>
<span id="cb40-2"><a href="#cb40-2"></a><span class="op">{</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>    <span class="kw">operator</span> Widget<span class="op">()</span></span>
<span id="cb40-4"><a href="#cb40-4"></a>    <span class="op">{</span></span>
<span id="cb40-5"><a href="#cb40-5"></a>        <span class="cf">return</span> MakeWidget<span class="op">();</span></span>
<span id="cb40-6"><a href="#cb40-6"></a>    <span class="op">}</span></span>
<span id="cb40-7"><a href="#cb40-7"></a><span class="op">};</span></span>
<span id="cb40-8"><a href="#cb40-8"></a></span>
<span id="cb40-9"><a href="#cb40-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb40-10"><a href="#cb40-10"></a><span class="op">{</span></span>
<span id="cb40-11"><a href="#cb40-11"></a>    <span class="bu">std::</span>optional<span class="op">&lt;</span>Widget<span class="op">&gt;</span> o<span class="op">;</span></span>
<span id="cb40-12"><a href="#cb40-12"></a>    o<span class="op">.</span>emplace<span class="op">(</span>WidgetFactory<span class="op">{});</span> <span class="co">// works</span></span>
<span id="cb40-13"><a href="#cb40-13"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="28" id="disable-template-argument-deduction"><span
class="header-section-number">28</span> disable template argument
deduction</h4>
<p>See, for instance, <a
href="https://devblogs.microsoft.com/oldnewthing/20240607-00/?p=109865">What’s
the deal with std::type_identity?</a> or <a
href="https://artificial-mind.net/blog/2020/09/26/dont-deduce">dont_deduce&lt;T&gt;</a>.
In short, this will not compile:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb41-1"><a href="#cb41-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb41-2"><a href="#cb41-2"></a><span class="dt">void</span> Process<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span>T<span class="op">)&gt;</span> f<span class="op">,</span> T v<span class="op">)</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="op">{</span></span>
<span id="cb41-4"><a href="#cb41-4"></a>    f<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb41-5"><a href="#cb41-5"></a><span class="op">}</span></span>
<span id="cb41-6"><a href="#cb41-6"></a></span>
<span id="cb41-7"><a href="#cb41-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb41-8"><a href="#cb41-8"></a><span class="op">{</span></span>
<span id="cb41-9"><a href="#cb41-9"></a>    Process<span class="op">([](</span><span class="dt">int</span><span class="op">)</span> <span class="op">{},</span> <span class="dv">64</span><span class="op">);</span></span>
<span id="cb41-10"><a href="#cb41-10"></a><span class="op">}</span></span></code></pre></div>
<p>We try to pass a lambda that has unique type X which has nothing to
do with <code>std::function&lt;void (T)&gt;</code>. Compiler does not
know how to deduce T from X.</p>
<p>Here, we want to ask compiler to not deduce anything for parameter
<code>f</code>:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="dt">void</span> Process<span class="op">(</span><span class="bu">std::</span>type_identity_t<span class="op">&lt;</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span>T<span class="op">)&gt;&gt;</span> f<span class="op">,</span> T v<span class="op">)</span></span>
<span id="cb42-3"><a href="#cb42-3"></a><span class="op">{</span></span>
<span id="cb42-4"><a href="#cb42-4"></a>    f<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb42-5"><a href="#cb42-5"></a><span class="op">}</span></span>
<span id="cb42-6"><a href="#cb42-6"></a></span>
<span id="cb42-7"><a href="#cb42-7"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb42-8"><a href="#cb42-8"></a><span class="op">{</span></span>
<span id="cb42-9"><a href="#cb42-9"></a>    Process<span class="op">([](</span><span class="dt">int</span><span class="op">){},</span> <span class="dv">64</span><span class="op">);</span></span>
<span id="cb42-10"><a href="#cb42-10"></a><span class="op">}</span></span></code></pre></div>
<p>T is deduced from 2nd argument, std::function is constructed from a
given lamda as it is.</p>
<h4 data-number="29" id="priority_tag-for-tag-dispatch"><span
class="header-section-number">29</span> priority_tag for tag
dispatch</h4>
<p>From <a
href="https://quuxplusone.github.io/blog/2021/07/09/priority-tag/">priority_tag
for ad-hoc tag dispatch</a> and <a
href="https://youtu.be/ybaE9qlhHvw?t=56m36s">CppCon 2017: Arthur O’Dwyer
“A Soupcon of SFINAE”</a>.</p>
<p>Here, we convert x to string trying first <code>x.stringify()</code>
if that exists, otherwise <code>std::to_string(x)</code> if that works
and finally fallback to ostringstream as a final resort:</p>
<div class="sourceCode" id="cb43"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb43-1"><a href="#cb43-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb43-2"><a href="#cb43-2"></a><span class="pp">#include </span><span class="im">&lt;sstream&gt;</span></span>
<span id="cb43-3"><a href="#cb43-3"></a></span>
<span id="cb43-4"><a href="#cb43-4"></a><span class="kw">template</span><span class="op">&lt;</span><span class="dt">unsigned</span> I<span class="op">&gt;</span> <span class="kw">struct</span> priority_tag <span class="op">:</span> priority_tag<span class="op">&lt;</span>I <span class="op">-</span> <span class="dv">1</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb43-5"><a href="#cb43-5"></a><span class="kw">template</span><span class="op">&lt;&gt;</span> <span class="kw">struct</span> priority_tag<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;</span> <span class="op">{};</span></span>
<span id="cb43-6"><a href="#cb43-6"></a></span>
<span id="cb43-7"><a href="#cb43-7"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb43-8"><a href="#cb43-8"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;)</span></span>
<span id="cb43-9"><a href="#cb43-9"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span>x<span class="op">.</span>stringify<span class="op">())</span></span>
<span id="cb43-10"><a href="#cb43-10"></a><span class="op">{</span></span>
<span id="cb43-11"><a href="#cb43-11"></a>    <span class="cf">return</span> x<span class="op">.</span>stringify<span class="op">();</span></span>
<span id="cb43-12"><a href="#cb43-12"></a><span class="op">}</span></span>
<span id="cb43-13"><a href="#cb43-13"></a></span>
<span id="cb43-14"><a href="#cb43-14"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb43-15"><a href="#cb43-15"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">1</span><span class="op">&gt;)</span></span>
<span id="cb43-16"><a href="#cb43-16"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">))</span></span>
<span id="cb43-17"><a href="#cb43-17"></a><span class="op">{</span></span>
<span id="cb43-18"><a href="#cb43-18"></a>    <span class="cf">return</span> <span class="bu">std::</span>to_string<span class="op">(</span>x<span class="op">);</span></span>
<span id="cb43-19"><a href="#cb43-19"></a><span class="op">}</span></span>
<span id="cb43-20"><a href="#cb43-20"></a></span>
<span id="cb43-21"><a href="#cb43-21"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb43-22"><a href="#cb43-22"></a><span class="kw">auto</span> stringify_impl<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">0</span><span class="op">&gt;)</span></span>
<span id="cb43-23"><a href="#cb43-23"></a>    <span class="op">-&gt;</span> <span class="kw">decltype</span><span class="op">(</span><span class="bu">std::</span>move<span class="op">(</span><span class="bu">std::</span>declval<span class="op">&lt;</span><span class="bu">std::</span>ostream<span class="op">&amp;&gt;()</span> <span class="op">&lt;&lt;</span> x<span class="op">).</span>str<span class="op">())</span></span>
<span id="cb43-24"><a href="#cb43-24"></a><span class="op">{</span></span>
<span id="cb43-25"><a href="#cb43-25"></a>    <span class="bu">std::</span>ostringstream s<span class="op">;</span></span>
<span id="cb43-26"><a href="#cb43-26"></a>    s <span class="op">&lt;&lt;</span> x<span class="op">;</span></span>
<span id="cb43-27"><a href="#cb43-27"></a>    <span class="cf">return</span> <span class="bu">std::</span>move<span class="op">(</span>s<span class="op">).</span>str<span class="op">();</span></span>
<span id="cb43-28"><a href="#cb43-28"></a><span class="op">}</span></span>
<span id="cb43-29"><a href="#cb43-29"></a></span>
<span id="cb43-30"><a href="#cb43-30"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb43-31"><a href="#cb43-31"></a><span class="kw">auto</span> stringify<span class="op">(</span><span class="at">const</span> T<span class="op">&amp;</span> x<span class="op">)</span></span>
<span id="cb43-32"><a href="#cb43-32"></a><span class="op">{</span></span>
<span id="cb43-33"><a href="#cb43-33"></a>    <span class="cf">return</span> stringify_impl<span class="op">(</span>x<span class="op">,</span> priority_tag<span class="op">&lt;</span><span class="dv">2</span><span class="op">&gt;());</span></span>
<span id="cb43-34"><a href="#cb43-34"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="30" id="new-auto10"><span
class="header-section-number">30</span> new auto(10)</h4>
<p>You can leave type dedcution to the compiler when using new:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb44-1"><a href="#cb44-1"></a><span class="kw">auto</span> ptr1 <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// works -&gt; int*</span></span>
<span id="cb44-2"><a href="#cb44-2"></a><span class="dt">int</span><span class="op">*</span> ptr2 <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span> <span class="co">// works</span></span></code></pre></div>
<p>From <a
href="https://en.cppreference.com/w/cpp/language/new">cppreference</a>:</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb45-1"><a href="#cb45-1"></a><span class="dt">double</span><span class="op">*</span> p <span class="op">=</span> <span class="kw">new</span> <span class="dt">double</span><span class="op">[]{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span>  <span class="co">// creates an array of type double[3]</span></span>
<span id="cb45-2"><a href="#cb45-2"></a><span class="kw">auto</span> p <span class="op">=</span> <span class="kw">new</span> <span class="kw">auto</span><span class="op">(</span><span class="ch">&#39;c&#39;</span><span class="op">);</span>             <span class="co">// creates a single object of type char. p is a char*</span></span>
<span id="cb45-3"><a href="#cb45-3"></a><span class="kw">auto</span> q <span class="op">=</span> <span class="kw">new</span> <span class="bu">std::</span>integral <span class="kw">auto</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span> <span class="co">// OK: q is an int*</span></span>
<span id="cb45-4"><a href="#cb45-4"></a><span class="kw">auto</span> r <span class="op">=</span> <span class="kw">new</span> <span class="bu">std::</span>pair<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="kw">true</span><span class="op">);</span>    <span class="co">// OK: r is a std::pair&lt;int, bool&gt;*</span></span></code></pre></div>
<h4 data-number="31" id="stdforward-use-in-stdfunction-like-case"><span
class="header-section-number">31</span> <code>std::forward</code> use in
std::function-like case</h4>
<p>Most of the times, we say that std::forward should be used in the
context of forwarding references that, <em>usually</em>, look like
this:</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb46-1"><a href="#cb46-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> T<span class="op">&gt;</span></span>
<span id="cb46-2"><a href="#cb46-2"></a><span class="dt">void</span> Process<span class="op">(</span>T<span class="op">&amp;&amp;</span> v<span class="op">)</span></span>
<span id="cb46-3"><a href="#cb46-3"></a><span class="op">{</span></span>
<span id="cb46-4"><a href="#cb46-4"></a>    Handle<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>T<span class="op">&gt;(</span>v<span class="op">));</span></span>
<span id="cb46-5"><a href="#cb46-5"></a><span class="op">}</span></span></code></pre></div>
<p>v is <a
href="https://en.cppreference.com/w/cpp/language/reference#Forwarding_references">forwarding
reference</a> specifically because T&amp;&amp; is used and T
<strong>is</strong> template parameter of Process function template.</p>
<p>However, classic example would be std::function call operator()
implementation:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb47-1"><a href="#cb47-1"></a><span class="kw">template</span><span class="op">&lt;</span><span class="kw">typename</span> Ret<span class="op">,</span> <span class="kw">typename</span><span class="op">...</span> Types<span class="op">&gt;</span></span>
<span id="cb47-2"><a href="#cb47-2"></a><span class="kw">class</span> function<span class="op">&lt;</span>Ret <span class="op">(</span>Types<span class="op">...)&gt;</span></span>
<span id="cb47-3"><a href="#cb47-3"></a><span class="op">{</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>    Ret <span class="kw">operator</span><span class="op">()(</span>Types<span class="op">...</span> Args<span class="op">)</span> <span class="at">const</span></span>
<span id="cb47-5"><a href="#cb47-5"></a>    <span class="op">{</span></span>
<span id="cb47-6"><a href="#cb47-6"></a>        <span class="cf">return</span> Do_call<span class="op">(</span><span class="bu">std::</span>forward<span class="op">&lt;</span>Types<span class="op">&gt;(</span>Args<span class="op">)...);</span></span>
<span id="cb47-7"><a href="#cb47-7"></a>    <span class="op">}</span></span>
<span id="cb47-8"><a href="#cb47-8"></a><span class="op">};</span></span>
<span id="cb47-9"><a href="#cb47-9"></a></span>
<span id="cb47-10"><a href="#cb47-10"></a><span class="co">// usage</span></span>
<span id="cb47-11"><a href="#cb47-11"></a>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">(</span><span class="dt">int</span><span class="op">&amp;&amp;,</span> <span class="dt">char</span><span class="op">)&gt;</span> f<span class="op">;</span> <span class="co">// (1)</span></span>
<span id="cb47-12"><a href="#cb47-12"></a>f<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="ch">&#39;x&#39;</span><span class="op">);</span>                     <span class="co">// (2)</span></span></code></pre></div>
<p>where user specifies <code>Types</code> at (1) that has nothing to do
with <code>operator()</code> call at (2) which is not even a function
template now.</p>
<p>If you run <a
href="https://en.cppreference.com/w/cpp/language/reference">reference
collapsing</a> rules over possible <code>Types</code> and
<code>Args</code>, <code>std::forward</code> is just right.</p>
<h4 data-number="32" id="virtual-functions-default-arguments"><span
class="header-section-number">32</span> virtual functions default
arguments</h4>
<p>See <a href="http://www.gotw.ca/gotw/005.htm">GotW #5, Overriding
Virtual Functions</a>:</p>
<blockquote>
<p>Never change the default parameters of overridden inherited
functions</p>
</blockquote>
<p>Going more strict: don’t have virtual functions with default
arguments.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb48-1"><a href="#cb48-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb48-2"><a href="#cb48-2"></a><span class="op">{</span></span>
<span id="cb48-3"><a href="#cb48-3"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">34</span><span class="op">);</span></span>
<span id="cb48-4"><a href="#cb48-4"></a><span class="op">};</span></span>
<span id="cb48-5"><a href="#cb48-5"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb48-6"><a href="#cb48-6"></a><span class="op">{</span></span>
<span id="cb48-7"><a href="#cb48-7"></a>    <span class="kw">virtual</span> <span class="dt">void</span> Foo<span class="op">(</span><span class="dt">int</span> v <span class="op">=</span> <span class="dv">43</span><span class="op">);</span></span>
<span id="cb48-8"><a href="#cb48-8"></a><span class="op">};</span></span>
<span id="cb48-9"><a href="#cb48-9"></a>MyBase<span class="op">*</span> ptr <span class="op">=</span> <span class="kw">new</span> MyDerived<span class="op">;</span></span>
<span id="cb48-10"><a href="#cb48-10"></a>ptr<span class="op">-&gt;</span>Foo<span class="op">();</span> <span class="co">// calls MyDerived::Foo, but with v = 34 from MyBase</span></span></code></pre></div>
<p>default arguments are resolved at compile time, override function
target - at run-time; may lead to confusion.</p>
<h4 data-number="33" id="virtual-functions-overloads"><span
class="header-section-number">33</span> virtual functions overloads</h4>
<p>See <a href="http://www.gotw.ca/gotw/005.htm">GotW #5, Overriding
Virtual Functions</a>:</p>
<blockquote>
<p>When providing a function with the same name as an inherited
function, be sure to bring the inherited functions into scope with a
“using” declaration if you don’t want to hide them</p>
</blockquote>
<p>Going more strict: avoid providing overloads to virtual
functions.<br />
For modern C++: use <a
href="https://en.cppreference.com/w/cpp/language/override">override
specifier</a>.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb49-1"><a href="#cb49-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb49-2"><a href="#cb49-2"></a><span class="op">{</span></span>
<span id="cb49-3"><a href="#cb49-3"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">char</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb49-4"><a href="#cb49-4"></a><span class="op">};</span></span>
<span id="cb49-5"><a href="#cb49-5"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb49-6"><a href="#cb49-6"></a><span class="op">{</span></span>
<span id="cb49-7"><a href="#cb49-7"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb49-8"><a href="#cb49-8"></a><span class="op">};</span></span>
<span id="cb49-9"><a href="#cb49-9"></a></span>
<span id="cb49-10"><a href="#cb49-10"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb49-11"><a href="#cb49-11"></a><span class="op">{</span></span>
<span id="cb49-12"><a href="#cb49-12"></a>    MyDerived derived<span class="op">;</span></span>
<span id="cb49-13"><a href="#cb49-13"></a>    <span class="cf">return</span> derived<span class="op">.</span>Foo<span class="op">(</span><span class="ch">&#39;x&#39;</span><span class="op">);</span></span>
<span id="cb49-14"><a href="#cb49-14"></a><span class="op">}</span></span></code></pre></div>
<p>main is going to return 2 since <code>MyDerived::Foo(int)</code> is
used. To use <code>MyBase::Foo(char)</code>:</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb50-1"><a href="#cb50-1"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="op">{</span></span>
<span id="cb50-3"><a href="#cb50-3"></a>    <span class="kw">using</span> MyBase<span class="op">::</span>Foo<span class="op">;</span> <span class="co">// add char overload</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>    <span class="kw">virtual</span> <span class="dt">int</span> Foo<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb50-5"><a href="#cb50-5"></a><span class="op">};</span></span></code></pre></div>
<p>Note: bringing base class method with using declation is,
potentially, a breaking change (see above, <code>derived.Foo('x')</code>
now returns 1 instead of 2).</p>
<h4 data-number="34" id="change-base-class-member-access-rights"><span
class="header-section-number">34</span> change base class member access
rights</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/language/using_declaration">Using-declaration</a>.
You can make protected member to be public in derived class:</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb51-1"><a href="#cb51-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="op">{</span></span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="kw">protected</span><span class="op">:</span></span>
<span id="cb51-4"><a href="#cb51-4"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb51-5"><a href="#cb51-5"></a><span class="op">};</span></span>
<span id="cb51-6"><a href="#cb51-6"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb51-7"><a href="#cb51-7"></a><span class="op">{</span></span>
<span id="cb51-8"><a href="#cb51-8"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb51-9"><a href="#cb51-9"></a>    <span class="kw">using</span> MyBase<span class="op">::</span>data<span class="op">;</span> <span class="co">// make data public now</span></span>
<span id="cb51-10"><a href="#cb51-10"></a><span class="op">};</span></span></code></pre></div>
<h4 data-number="35" id="use-default-constructor-for-state-reset"><span
class="header-section-number">35</span> use default constructor for
state reset</h4>
<p>It’s observed that, often, class API has .Reset() function (even more
often when two phase initialization is used):</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb52-1"><a href="#cb52-1"></a><span class="kw">struct</span> MyClass</span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="op">{</span></span>
<span id="cb52-3"><a href="#cb52-3"></a>    <span class="dt">int</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb52-4"><a href="#cb52-4"></a>    <span class="co">// ...</span></span>
<span id="cb52-5"><a href="#cb52-5"></a>    <span class="dt">void</span> Reset<span class="op">()</span> <span class="op">{</span> data <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb52-6"><a href="#cb52-6"></a><span class="op">};</span></span></code></pre></div>
<p>If your API is anything close to modern C++ and supports <a
href="https://youtu.be/G9MxNwUoSt0?si=qbFFjdXYKT58ZThN">value
semantics</a>, just have move assignment implemented with default
constructor, which leads to:</p>
<div class="sourceCode" id="cb53"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb53-1"><a href="#cb53-1"></a>MyClass instance<span class="op">;</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="co">// ...</span></span>
<span id="cb53-3"><a href="#cb53-3"></a>instance <span class="op">=</span> MyClass<span class="op">{};</span> <span class="co">// same as .Reset()</span></span></code></pre></div>
<p>See also “default constructor is a must for modern C++”</p>
<h4 data-number="36"
id="default-constructor-is-a-must-for-modern-c"><span
class="header-section-number">36</span> default constructor is a must
for modern C++</h4>
<p>What happens with the object after the move? The known answer for C++
library types is that it’s in <a
href="https://en.cppreference.com/w/cpp/utility/move">“valid but
unspecified state”</a>. Note, that for most cases in practice, the
object is in empty/null state (see <a
href="https://gist.github.com/sean-parent/fed31bee69bc41d888f84f25743da9f1">Sean
Parent comments</a>) or, to say it another way - you should put the
object into empty state and be nice.</p>
<p>Why it’s in “empty” state? Simply because destructor still runs after
the move and we need to know whether or not it’s needed to free
resources <strong>most of the times</strong>:</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">struct</span> MyFile</span>
<span id="cb54-2"><a href="#cb54-2"></a><span class="op">{</span></span>
<span id="cb54-3"><a href="#cb54-3"></a>    <span class="dt">int</span> handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb54-4"><a href="#cb54-4"></a>    <span class="co">// ...</span></span>
<span id="cb54-5"><a href="#cb54-5"></a>    <span class="op">~</span>MyFile<span class="op">()</span></span>
<span id="cb54-6"><a href="#cb54-6"></a>    <span class="op">{</span></span>
<span id="cb54-7"><a href="#cb54-7"></a>        <span class="cf">if</span> <span class="op">(</span>handle <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb54-8"><a href="#cb54-8"></a>        <span class="op">{</span></span>
<span id="cb54-9"><a href="#cb54-9"></a>            <span class="op">::</span>close<span class="op">(</span>handle<span class="op">);</span></span>
<span id="cb54-10"><a href="#cb54-10"></a>            handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb54-11"><a href="#cb54-11"></a>        <span class="op">}</span></span>
<span id="cb54-12"><a href="#cb54-12"></a>    <span class="op">}</span></span>
<span id="cb54-13"><a href="#cb54-13"></a>    MyFile<span class="op">(</span>MyFile<span class="op">&amp;&amp;</span> rhs<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb54-14"><a href="#cb54-14"></a>        <span class="op">:</span> handle<span class="op">(</span>rhs<span class="op">.</span>handle<span class="op">)</span></span>
<span id="cb54-15"><a href="#cb54-15"></a>    <span class="op">{</span></span>
<span id="cb54-16"><a href="#cb54-16"></a>        rhs<span class="op">.</span>handle <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// take ownership</span></span>
<span id="cb54-17"><a href="#cb54-17"></a>    <span class="op">}</span></span>
<span id="cb54-18"><a href="#cb54-18"></a><span class="op">}</span></span></code></pre></div>
<p>For a user or even class author, it’s also often needed to check if
the object was not moved to ensure correct use:</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb55-1"><a href="#cb55-1"></a><span class="dt">void</span> MyFile<span class="op">::</span>Read<span class="op">(...)</span></span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="op">{</span></span>
<span id="cb55-3"><a href="#cb55-3"></a>    <span class="ot">assert</span><span class="op">(</span>handle <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// hidden/implicit is_valid check</span></span>
<span id="cb55-4"><a href="#cb55-4"></a><span class="op">}</span></span></code></pre></div>
<p>Now, should the class expose <code>is_valid()</code> API? Maybe,
maybe not; up to you. More elegant solution that requires smaller amount
of exposed APIs could be just a pair of default construction and
<code>operator==</code>:</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb56-1"><a href="#cb56-1"></a>MyFile file <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb56-2"><a href="#cb56-2"></a><span class="cf">if</span> <span class="op">(</span>file <span class="op">==</span> MyFile<span class="op">{})</span></span>
<span id="cb56-3"><a href="#cb56-3"></a>    <span class="co">// empty, was moved from, can&#39;t invoke Read().</span></span></code></pre></div>
<p>Leaving validity check alone, any time you support move, just expose
such state with default constructor. More often then not it makes life
easier. See also “state reset”.</p>
<p>Relative: <a
href="https://www.foonathan.net/2016/08/move-default-ctor/">Move
Semantics and Default Constructors – Rule of Six?</a>.</p>
<h4 data-number="37" id="default-constructor-must-do-no-work"><span
class="header-section-number">37</span> default constructor must do no
work</h4>
<p>Default constructor may be used as a fallback in a few places of
STL/your code:</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb57-1"><a href="#cb57-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span>MyData<span class="op">&gt;</span> v<span class="op">;</span></span>
<span id="cb57-2"><a href="#cb57-2"></a>v<span class="op">.</span>resize<span class="op">(</span><span class="dv">1&#39;000</span><span class="op">);</span> <span class="co">// insert 1&#39;000 default-constructed MyData elements</span></span>
<span id="cb57-3"><a href="#cb57-3"></a><span class="bu">std::</span>map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> MyData<span class="op">&gt;</span> m<span class="op">;</span></span>
<span id="cb57-4"><a href="#cb57-4"></a>m<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> MyData<span class="op">{</span><span class="dv">98</span><span class="op">};</span> <span class="co">// default construct MyData, then reassign</span></span>
<span id="cb57-5"><a href="#cb57-5"></a><span class="bu">std::</span>variant<span class="op">&lt;</span>MyData<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> v<span class="op">;</span> <span class="co">// default construct MyData</span></span></code></pre></div>
<p>Following C++ value semantic, move semantic with its empty state, it
may also be used to reset state or check whether or not the instance is
valid:</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb58-1"><a href="#cb58-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> ptr <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb58-2"><a href="#cb58-2"></a>ptr <span class="op">=</span> <span class="op">{};</span> <span class="co">// reset, set to nullptr</span></span></code></pre></div>
<p>Default constructor should contain nothing except default/trivial
data member initialization. Specifically, no memory allocations, no side
effects.</p>
<p>Bonus question: why does this code allocate under MSVC debug?</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb59-1"><a href="#cb59-1"></a><span class="bu">std::</span>string s<span class="op">;</span> <span class="co">// ?</span></span></code></pre></div>
<p>Hint: MSVC STL debug iterators machinery.</p>
<h4 data-number="38" id="constructors-should-do-no-work"><span
class="header-section-number">38</span> constructors should do no
work</h4>
<p>Constructors (at least of objects for types that are part of your
applicaiton domain) should just assign/default initialize data members,
NO business/application logic inside. This applies to copy constructor,
constructors with parameters, move constructor.</p>
<p>Simply because you don’t control when and who and how can invoke
and/or ignore/skip your constructor invocation. See, for instance, (but
not only) <a
href="https://en.cppreference.com/w/cpp/language/copy_elision">Copy
elision/RVO/NRVO/URVO</a>.</p>
<p>But what about RAII? How to make RAII classes then?</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb60-1"><a href="#cb60-1"></a><span class="kw">struct</span> MyFile</span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="op">{</span></span>
<span id="cb60-3"><a href="#cb60-3"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb60-4"><a href="#cb60-4"></a>    <span class="kw">using</span> FileHandle <span class="op">=</span> <span class="op">...;</span></span>
<span id="cb60-5"><a href="#cb60-5"></a></span>
<span id="cb60-6"><a href="#cb60-6"></a>    <span class="at">static</span> Open<span class="op">(</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> file_name<span class="op">)</span></span>
<span id="cb60-7"><a href="#cb60-7"></a>    <span class="op">{</span></span>
<span id="cb60-8"><a href="#cb60-8"></a>        FileHandle handle <span class="op">=</span> <span class="op">::</span>open<span class="op">(</span>file_name<span class="op">);</span> <span class="co">// imaginary system API</span></span>
<span id="cb60-9"><a href="#cb60-9"></a>        <span class="cf">return</span> MyFile<span class="op">{</span>handle<span class="op">};</span></span>
<span id="cb60-10"><a href="#cb60-10"></a>    <span class="op">}</span></span>
<span id="cb60-11"><a href="#cb60-11"></a></span>
<span id="cb60-12"><a href="#cb60-12"></a>    <span class="kw">explicit</span> MyFile<span class="op">()</span> <span class="kw">noexcept</span> <span class="op">=</span> <span class="cf">default</span><span class="op">;</span></span>
<span id="cb60-13"><a href="#cb60-13"></a>    <span class="op">~</span>MyFile<span class="op">();</span> <span class="co">// ...</span></span>
<span id="cb60-14"><a href="#cb60-14"></a></span>
<span id="cb60-15"><a href="#cb60-15"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb60-16"><a href="#cb60-16"></a>    <span class="kw">explicit</span> MyFile<span class="op">(</span>FileHandle handle<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb60-17"><a href="#cb60-17"></a>        <span class="op">:</span> file_handle<span class="op">{</span>handle<span class="op">}</span></span>
<span id="cb60-18"><a href="#cb60-18"></a>    <span class="op">{</span></span>
<span id="cb60-19"><a href="#cb60-19"></a>    <span class="op">}</span></span>
<span id="cb60-20"><a href="#cb60-20"></a>    FileHandle file_handle<span class="op">{};</span></span>
<span id="cb60-21"><a href="#cb60-21"></a><span class="op">};</span></span></code></pre></div>
<p>Isn’t this makes sense only when exceptions are disabled? Not sure
exceptions change anything there.</p>
<p>Sometimes I even leave <code>MyFile(FileHandle handle)</code>-like
constructors public. This makes API extremely hackable and testable.</p>
<h4 data-number="39" id="stdunique_ptr-with-decltype-lambda"><span
class="header-section-number">39</span> <code>std::unique_ptr</code>
with decltype lambda</h4>
<p>Since C++20, with <a
href="https://andreasfertig.blog/2022/08/cpp-insights-lambdas-in-unevaluated-contexts/">Lambdas
in unevaluated contexts</a>, you can have poor man’s scope exit as a
side effect:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb61-1"><a href="#cb61-1"></a><span class="kw">using</span> on_exit <span class="op">=</span> <span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="at">const</span> <span class="dt">char</span><span class="op">,</span></span>
<span id="cb61-2"><a href="#cb61-2"></a>    <span class="kw">decltype</span><span class="op">([](</span><span class="at">const</span> <span class="dt">char</span><span class="op">*</span> msg<span class="op">)</span> <span class="op">{</span> puts<span class="op">(</span>msg<span class="op">);</span> <span class="op">})&gt;;</span></span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="dt">void</span> Foo<span class="op">()</span></span>
<span id="cb61-5"><a href="#cb61-5"></a><span class="op">{</span></span>
<span id="cb61-6"><a href="#cb61-6"></a>    on_exit msg<span class="op">(</span><span class="st">&quot;Foo&quot;</span><span class="op">);</span></span>
<span id="cb61-7"><a href="#cb61-7"></a><span class="op">}</span> <span class="co">// prints Foo on scope exit</span></span></code></pre></div>
<p>from <a
href="https://youtu.be/O2G3bwNP5p4?si=_2yfyq9BEoxF3etB">Creating a
Sender/Receiver HTTP Server for Asynchronous Operations in C++</a>.</p>
<h4 data-number="40" id="auto-vs-auto-for-pointers"><span
class="header-section-number">40</span> <code>auto</code> vs
<code>auto*</code> for pointers</h4>
<p>Since auto type deduction comes from <a
href="https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts">template
argument deduction</a>, it’s fine to have <code>auto*</code> in the same
way it’s fine to have <code>T*</code> as a template parameter:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb62-1"><a href="#cb62-1"></a><span class="kw">auto</span>  p1 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>        <span class="co">// p1 = int*</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="kw">auto</span><span class="op">*</span> p2 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>        <span class="co">// p2 = int*</span></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="at">const</span> <span class="kw">auto</span>  p3 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>  <span class="co">// p3 = int* const</span></span>
<span id="cb62-4"><a href="#cb62-4"></a><span class="at">const</span> <span class="kw">auto</span><span class="op">*</span> p4 <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">;</span>  <span class="co">// p4 = const int*</span></span></code></pre></div>
<p>Still, note the difference for p3 vs p4 - const pointer to int vs
just pointer to const int!</p>
<h4 data-number="41"
id="stdtransform-and-lift-passing-overload-set"><span
class="header-section-number">41</span> std::transform and LIFT (passing
overload set)</h4>
<p>See <a
href="https://blog.tartanllama.xyz/passing-overload-sets/">Passing
overload sets to functions</a>:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb63-1"><a href="#cb63-1"></a><span class="pp">#define FWD</span><span class="op">(...)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb63-2"><a href="#cb63-2"></a><span class="pp">    </span><span class="bu">std::</span>forward<span class="op">&lt;</span><span class="kw">decltype</span><span class="op">(</span><span class="ot">__VA_ARGS__</span><span class="op">)&gt;(</span><span class="ot">__VA_ARGS__</span><span class="op">)</span></span>
<span id="cb63-3"><a href="#cb63-3"></a></span>
<span id="cb63-4"><a href="#cb63-4"></a><span class="pp">#define LIFT</span><span class="op">(</span>X<span class="op">)</span><span class="pp"> </span><span class="op">[](</span><span class="kw">auto</span><span class="pp"> </span><span class="op">&amp;&amp;...</span><span class="pp"> </span>args<span class="op">)</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb63-5"><a href="#cb63-5"></a><span class="pp">    </span><span class="kw">noexcept</span><span class="op">(</span><span class="kw">noexcept</span><span class="op">(</span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...)))</span><span class="pp">  </span><span class="op">\</span></span>
<span id="cb63-6"><a href="#cb63-6"></a><span class="pp">    </span><span class="op">-&gt;</span><span class="pp"> </span><span class="kw">decltype</span><span class="op">(</span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...))</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb63-7"><a href="#cb63-7"></a><span class="op">{</span><span class="pp">  </span><span class="op">\</span></span>
<span id="cb63-8"><a href="#cb63-8"></a><span class="pp">    </span><span class="cf">return</span><span class="pp"> </span>X<span class="op">(</span>FWD<span class="op">(</span>args<span class="op">)...);</span><span class="pp"> </span><span class="op">\</span></span>
<span id="cb63-9"><a href="#cb63-9"></a><span class="op">}</span></span>
<span id="cb63-10"><a href="#cb63-10"></a></span>
<span id="cb63-11"><a href="#cb63-11"></a><span class="co">// ...</span></span>
<span id="cb63-12"><a href="#cb63-12"></a><span class="bu">std::</span>transform<span class="op">(</span>first<span class="op">,</span> last<span class="op">,</span> target<span class="op">,</span> LIFT<span class="op">(</span>foo<span class="op">));</span></span></code></pre></div>
<h4 data-number="42" id="tolower-is-not-an-addressible-function"><span
class="header-section-number">42</span> <code>tolower</code> is not an
addressible function</h4>
<p>You can’t take an adress of std:: function since function could be
implemented differently with different STL(s) and/or in the feature the
function may change, hence such code is not portable. From <a
href="https://devblogs.microsoft.com/oldnewthing/20241007-00/?p=110345">A
popular but wrong way to convert a string to uppercase or
lowercase</a>:</p>
<blockquote>
<p>The standard imposes this limitation because the implementation may
need to add default function parameters, template default parameters, or
overloads in order to accomplish the various requirements of the
standard.</p>
</blockquote>
<p>So, strictly speaking, ignoring facts from the article, this is not
portable C++:</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb64-1"><a href="#cb64-1"></a><span class="bu">std::</span>wstring name<span class="op">;</span></span>
<span id="cb64-2"><a href="#cb64-2"></a><span class="bu">std::</span>transform<span class="op">(</span>name<span class="op">.</span>begin<span class="op">(),</span> name<span class="op">.</span>end<span class="op">(),</span> name<span class="op">.</span>begin<span class="op">(),</span></span>
<span id="cb64-3"><a href="#cb64-3"></a>    <span class="bu">std::</span>tolower<span class="op">);</span></span></code></pre></div>
<h4 data-number="43"
id="replace-operator-new-to-track-third-party-code-allocations"><span
class="header-section-number">43</span> replace operator new to track
third-party code allocations</h4>
<p><code>operator new</code>/<code>operator delete</code> can have <a
href="https://en.cppreference.com/w/cpp/memory/new/operator_new#Global_replacements">global
replacement</a>. Usually used to actually inject custom memory
allocator, but also is used for tracking/profiling purpose. And can be
used for debugging:</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb65-1"><a href="#cb65-1"></a><span class="dt">void</span><span class="op">*</span> <span class="kw">operator</span> <span class="kw">new</span><span class="op">(</span><span class="bu">std::</span>size_t size<span class="op">)</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="op">{</span></span>
<span id="cb65-3"><a href="#cb65-3"></a>    <span class="cf">return</span> malloc<span class="op">(</span>size<span class="op">);</span> <span class="co">// assume size &gt; 0</span></span>
<span id="cb65-4"><a href="#cb65-4"></a><span class="op">}</span></span>
<span id="cb65-5"><a href="#cb65-5"></a><span class="dt">void</span> <span class="kw">operator</span> <span class="kw">delete</span><span class="op">(</span><span class="dt">void</span><span class="op">*</span> ptr<span class="op">)</span> <span class="kw">noexcept</span></span>
<span id="cb65-6"><a href="#cb65-6"></a><span class="op">{</span></span>
<span id="cb65-7"><a href="#cb65-7"></a>    free<span class="op">(</span>ptr<span class="op">);</span></span>
<span id="cb65-8"><a href="#cb65-8"></a><span class="op">}</span></span>
<span id="cb65-9"><a href="#cb65-9"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb65-10"><a href="#cb65-10"></a><span class="op">{</span></span>
<span id="cb65-11"><a href="#cb65-11"></a>    <span class="bu">std::</span>string s<span class="op">{</span><span class="st">&quot;does it allocate for this input?&quot;</span><span class="op">};</span></span>
<span id="cb65-12"><a href="#cb65-12"></a>    <span class="co">// ...</span></span>
<span id="cb65-13"><a href="#cb65-13"></a><span class="op">}</span></span></code></pre></div>
<p>Just put a breakpoint inside your version of new/delete; observe
callstack and all the useful context.</p>
<p>Hint: same can be done with, let say, WinAPI - use <a
href="https://github.com/microsoft/Detours">Detours</a>.</p>
<h4 data-number="44" id="stdshared_ptrvoid-exists"><span
class="header-section-number">44</span>
<code>std::shared_ptr&lt;void&gt;</code> exists</h4>
<p><code>std::shared_ptr&lt;void&gt;</code> holds <code>void*</code>
pointer, but also has <a
href="https://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Type_Erasure">type-erased</a>
destroy function that remembers the actual type it was created with, so
this is fine:</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb66-1"><a href="#cb66-1"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span><span class="dt">void</span><span class="op">&gt;</span>   ptr1 <span class="op">=</span> <span class="bu">std::</span>make_shared<span class="op">&lt;</span>MyData<span class="op">&gt;();</span>             <span class="co">// ok</span></span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="bu">std::</span>shared_ptr<span class="op">&lt;</span>MyData<span class="op">&gt;</span> ptr2 <span class="op">=</span> <span class="bu">std::</span>static_pointer_cast<span class="op">&lt;</span>MyData<span class="op">&gt;(</span>ptr1<span class="op">);</span> <span class="co">// ok</span></span></code></pre></div>
<p>See <a
href="https://stackoverflow.com/questions/5913396/why-do-stdshared-ptrvoid-work">Why
do std::shared_ptr<void> work</a> and <a
href="https://www.nextptr.com/tutorial/ta1227747841/the-stdshared_ptrvoid-as-arbitrary-userdata-pointer">The
std::shared_ptr as arbitrary user-data pointer</a>.</p>
<h4 data-number="45" id="sync_with_stdio-for-stdout-vs-stdcout"><span
class="header-section-number">45</span> sync_with_stdio for stdout vs
std::cout</h4>
<p>See <a
href="https://en.cppreference.com/w/cpp/io/ios_base/sync_with_stdio">sync_with_stdio</a>.</p>
<blockquote>
<p>In practice, this means that the synchronized C++ streams are
unbuffered, and each I/O operation on a C++ stream is immediately
applied to the corresponding C stream’s buffer. This makes it possible
to freely mix C++ and C I/O.</p>
</blockquote>
<blockquote>
<p>In addition, synchronized C++ streams are guaranteed to be
thread-safe (individual characters output from multiple threads may
interleave, but no data races occur).</p>
</blockquote>
<div class="sourceCode" id="cb67"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb67-1"><a href="#cb67-1"></a><span class="bu">std::</span>ios::sync_with_stdio<span class="op">(</span><span class="kw">false</span><span class="op">);</span></span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;a</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb67-3"><a href="#cb67-3"></a><span class="bu">std::</span>printf<span class="op">(</span><span class="st">&quot;b</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span> <span class="co">// may be output before &#39;a&#39; above</span></span>
<span id="cb67-4"><a href="#cb67-4"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;c</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span></code></pre></div>
<p>Note: not the same as <a
href="https://en.cppreference.com/w/cpp/io/basic_osyncstream">syncstream/C++20</a>.</p>
<h4 data-number="46" id="stdclog-vs-stdcerr"><span
class="header-section-number">46</span> std::clog vs std::cerr</h4>
<p><a href="https://en.cppreference.com/w/cpp/io/clog">clog</a>
cppreference and <a
href="https://en.cppreference.com/w/cpp/io/cerr">cerr</a>. Associated
with the standard C error output stream <code>stderr</code> (same as
cerr), but:</p>
<blockquote>
<p>Output to stderr via std::cerr flushes out the pending output on
std::cout, while output to stderr via std::clog does not.</p>
</blockquote>
<div class="sourceCode" id="cb68"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb68-1"><a href="#cb68-1"></a><span class="bu">std::</span>cout <span class="op">&lt;&lt;</span> <span class="st">&quot;aaaaa</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span></span>
<span id="cb68-2"><a href="#cb68-2"></a><span class="bu">std::</span>clog <span class="op">&lt;&lt;</span> <span class="st">&quot;bbbbb</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// may not flush &quot;aaaaa&quot;</span></span>
<span id="cb68-3"><a href="#cb68-3"></a><span class="bu">std::</span>cerr <span class="op">&lt;&lt;</span> <span class="st">&quot;ccccc</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">;</span> <span class="co">// flush &quot;aaaaa&quot;</span></span></code></pre></div>
<h4 data-number="47"
id="capture-less-lambda-can-be-converted-to-c-function"><span
class="header-section-number">47</span> capture-less lambda can be
converted to c-function</h4>
<div class="sourceCode" id="cb69"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb69-1"><a href="#cb69-1"></a><span class="at">extern</span> <span class="st">&quot;C&quot;</span> <span class="dt">void</span> Handle<span class="op">(</span><span class="dt">void</span> <span class="op">(*</span>MyCallback<span class="op">)(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb69-2"><a href="#cb69-2"></a></span>
<span id="cb69-3"><a href="#cb69-3"></a>Handle<span class="op">([](</span><span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span> <span class="bu">std::</span>println<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> V<span class="op">);</span> <span class="op">});</span> <span class="co">// pass to C-function</span></span>
<span id="cb69-4"><a href="#cb69-4"></a><span class="dt">void</span> <span class="op">(*</span>MyFunction<span class="op">)(</span><span class="dt">int</span><span class="op">)</span> <span class="op">=</span> <span class="op">[](</span><span class="dt">int</span><span class="op">)</span> <span class="op">{};</span>         <span class="co">// convert to C-function</span></span></code></pre></div>
<p>In case lambda has empty capture list (and no deducing this is used),
it can be converted to c-style function pointer (has conversion
operator). See <a
href="https://en.cppreference.com/w/cpp/language/lambda">lambda</a>.</p>
<h4 data-number="48" id="to-convert-lambda-to-c-function"><span
class="header-section-number">48</span> <code>+[](){}</code> to convert
lambda to c-function</h4>
<p>See <a
href="https://stackoverflow.com/questions/18889028/a-positive-lambda-what-sorcery-is-this">A
positive lambda: ‘+<span></span>’ - What sorcery is this?</a>:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb70-1"><a href="#cb70-1"></a><span class="pp">#include </span><span class="im">&lt;functional&gt;</span></span>
<span id="cb70-2"><a href="#cb70-2"></a></span>
<span id="cb70-3"><a href="#cb70-3"></a><span class="dt">void</span> foo<span class="op">(</span><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span><span class="op">()&gt;</span> f<span class="op">)</span> <span class="op">{</span> f<span class="op">();</span> <span class="op">}</span></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="dt">void</span> foo<span class="op">(</span><span class="dt">void</span> <span class="op">(*</span>f<span class="op">)())</span> <span class="op">{</span> f<span class="op">();</span> <span class="op">}</span></span>
<span id="cb70-5"><a href="#cb70-5"></a></span>
<span id="cb70-6"><a href="#cb70-6"></a><span class="dt">int</span> main <span class="op">()</span></span>
<span id="cb70-7"><a href="#cb70-7"></a><span class="op">{</span></span>
<span id="cb70-8"><a href="#cb70-8"></a>    foo<span class="op">(</span>  <span class="op">[](){}</span> <span class="op">);</span> <span class="co">// ambiguous</span></span>
<span id="cb70-9"><a href="#cb70-9"></a>    foo<span class="op">(</span> <span class="op">+[](){}</span> <span class="op">);</span> <span class="co">// not ambiguous (calls the function pointer overload)</span></span>
<span id="cb70-10"><a href="#cb70-10"></a><span class="op">}</span></span></code></pre></div>
<blockquote>
<p>The + in the expression <code>+[](){}</code> is the unary + operator
[…] forces the conversion to the function pointer type</p>
</blockquote>
<p>In addition: what <code>*[](){}</code> does? And
<code>+*[](){}</code>?.</p>
<h4 data-number="49" id="virtual-operator-int"><span
class="header-section-number">49</span> virtual operator int</h4>
<p><a
href="https://en.cppreference.com/w/cpp/language/cast_operator">conversion
function or cast operator</a> is the same as regular function and could
also be made virtual:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">struct</span> MyBase</span>
<span id="cb71-2"><a href="#cb71-2"></a><span class="op">{</span></span>
<span id="cb71-3"><a href="#cb71-3"></a>    <span class="kw">virtual</span> <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span></span>
<span id="cb71-4"><a href="#cb71-4"></a>    <span class="op">{</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb71-5"><a href="#cb71-5"></a><span class="op">};</span></span>
<span id="cb71-6"><a href="#cb71-6"></a><span class="kw">struct</span> MyDerived <span class="op">:</span> MyBase</span>
<span id="cb71-7"><a href="#cb71-7"></a><span class="op">{</span></span>
<span id="cb71-8"><a href="#cb71-8"></a>    <span class="kw">virtual</span> <span class="kw">operator</span> <span class="dt">int</span><span class="op">()</span> <span class="at">const</span> <span class="kw">override</span></span>
<span id="cb71-9"><a href="#cb71-9"></a>    <span class="op">{</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="op">}</span></span>
<span id="cb71-10"><a href="#cb71-10"></a><span class="op">};</span></span>
<span id="cb71-11"><a href="#cb71-11"></a></span>
<span id="cb71-12"><a href="#cb71-12"></a><span class="dt">void</span> Handle<span class="op">(</span><span class="at">const</span> MyBase<span class="op">&amp;</span> Base<span class="op">)</span></span>
<span id="cb71-13"><a href="#cb71-13"></a><span class="op">{</span></span>
<span id="cb71-14"><a href="#cb71-14"></a>    <span class="at">const</span> <span class="dt">int</span> V <span class="op">=</span> Base<span class="op">;</span></span>
<span id="cb71-15"><a href="#cb71-15"></a>    <span class="bu">std::</span>print<span class="op">(</span><span class="st">&quot;</span><span class="sc">{}</span><span class="st">&quot;</span><span class="op">,</span> V<span class="op">);</span></span>
<span id="cb71-16"><a href="#cb71-16"></a><span class="op">}</span></span>
<span id="cb71-17"><a href="#cb71-17"></a></span>
<span id="cb71-18"><a href="#cb71-18"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb71-19"><a href="#cb71-19"></a><span class="op">{</span></span>
<span id="cb71-20"><a href="#cb71-20"></a>    Handle<span class="op">(</span>MyDerived<span class="op">{});</span> <span class="co">// prints 2</span></span>
<span id="cb71-21"><a href="#cb71-21"></a><span class="op">}</span></span></code></pre></div>
<h4 data-number="50" id="placement-new-emplace_back-pre-c11"><span
class="header-section-number">50</span> placement new emplace_back
pre-C++11</h4>
<p>Used to perfect-construct object in-place. Below is valid C++98:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb72-1"><a href="#cb72-1"></a><span class="pp">#include </span><span class="im">&lt;cassert&gt;</span></span>
<span id="cb72-2"><a href="#cb72-2"></a><span class="pp">#include </span><span class="im">&lt;new&gt;</span></span>
<span id="cb72-3"><a href="#cb72-3"></a></span>
<span id="cb72-4"><a href="#cb72-4"></a><span class="co">// array of max size 2 for int(s) for illustation</span></span>
<span id="cb72-5"><a href="#cb72-5"></a><span class="kw">struct</span> MyArray</span>
<span id="cb72-6"><a href="#cb72-6"></a><span class="op">{</span></span>
<span id="cb72-7"><a href="#cb72-7"></a>    <span class="co">/*alignas(int)*/</span> <span class="dt">char</span> buffer<span class="op">[</span><span class="dv">2</span> <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">)];</span></span>
<span id="cb72-8"><a href="#cb72-8"></a>    <span class="dt">int</span> size<span class="op">;</span> <span class="co">// = 0;</span></span>
<span id="cb72-9"><a href="#cb72-9"></a></span>
<span id="cb72-10"><a href="#cb72-10"></a>    <span class="dt">void</span><span class="op">*</span> emplace_back<span class="op">()</span></span>
<span id="cb72-11"><a href="#cb72-11"></a>    <span class="op">{</span></span>
<span id="cb72-12"><a href="#cb72-12"></a>        <span class="ot">assert</span><span class="op">(</span>size <span class="op">&lt;</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb72-13"><a href="#cb72-13"></a>        <span class="dt">void</span><span class="op">*</span> memory <span class="op">=</span> <span class="op">(</span>buffer <span class="op">+</span> size <span class="op">*</span> <span class="kw">sizeof</span><span class="op">(</span><span class="dt">int</span><span class="op">));</span></span>
<span id="cb72-14"><a href="#cb72-14"></a>        size <span class="op">+=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb72-15"><a href="#cb72-15"></a>        <span class="cf">return</span> memory<span class="op">;</span></span>
<span id="cb72-16"><a href="#cb72-16"></a>    <span class="op">}</span></span>
<span id="cb72-17"><a href="#cb72-17"></a><span class="op">};</span></span>
<span id="cb72-18"><a href="#cb72-18"></a></span>
<span id="cb72-19"><a href="#cb72-19"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb72-20"><a href="#cb72-20"></a><span class="op">{</span></span>
<span id="cb72-21"><a href="#cb72-21"></a>    MyArray v<span class="op">;</span></span>
<span id="cb72-22"><a href="#cb72-22"></a>    <span class="kw">new</span><span class="op">(</span>v<span class="op">.</span>emplace_back<span class="op">())</span> <span class="dt">int</span><span class="op">(</span><span class="dv">44</span><span class="op">);</span></span>
<span id="cb72-23"><a href="#cb72-23"></a>    <span class="kw">new</span><span class="op">(</span>v<span class="op">.</span>emplace_back<span class="op">())</span> <span class="dt">int</span><span class="op">(</span><span class="dv">45</span><span class="op">);</span></span>
<span id="cb72-24"><a href="#cb72-24"></a><span class="op">}</span></span></code></pre></div>
<p>Observed in Unreal Engine:</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb73-1"><a href="#cb73-1"></a>TArray<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Data<span class="op">;</span></span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="kw">new</span><span class="op">(</span>Data<span class="op">)</span> <span class="dt">int</span><span class="op">{</span><span class="dv">67</span><span class="op">};</span> <span class="co">// push_back to Data</span></span></code></pre></div>
<h4 data-number="51"
id="operator--recursion-returning-non-pointer-type"><span
class="header-section-number">51</span> <code>operator-&gt;</code>
recursion (returning non-pointer type)</h4>
<p>If <code>operator-&gt;</code> returns non-pointer type, compiler will
automatically invoke <code>operator-&gt;</code> on returned value until
its return type is pointer:</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb74-1"><a href="#cb74-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> data<span class="op">;</span> <span class="co">// for illustration purpose</span></span>
<span id="cb74-2"><a href="#cb74-2"></a></span>
<span id="cb74-3"><a href="#cb74-3"></a><span class="kw">struct</span> A0</span>
<span id="cb74-4"><a href="#cb74-4"></a><span class="op">{</span></span>
<span id="cb74-5"><a href="#cb74-5"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;*</span> <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> <span class="op">&amp;</span>data<span class="op">;</span> <span class="op">}</span></span>
<span id="cb74-6"><a href="#cb74-6"></a><span class="op">};</span></span>
<span id="cb74-7"><a href="#cb74-7"></a><span class="kw">struct</span> A1</span>
<span id="cb74-8"><a href="#cb74-8"></a><span class="op">{</span></span>
<span id="cb74-9"><a href="#cb74-9"></a>    A0 <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> A0<span class="op">{};</span> <span class="op">}</span> <span class="co">// note: returns value</span></span>
<span id="cb74-10"><a href="#cb74-10"></a><span class="op">};</span></span>
<span id="cb74-11"><a href="#cb74-11"></a><span class="kw">struct</span> A2</span>
<span id="cb74-12"><a href="#cb74-12"></a><span class="op">{</span></span>
<span id="cb74-13"><a href="#cb74-13"></a>    A1 <span class="kw">operator</span><span class="op">-&gt;()</span> <span class="op">{</span> <span class="cf">return</span> A1<span class="op">{};</span> <span class="op">}</span> <span class="co">// note: returns value</span></span>
<span id="cb74-14"><a href="#cb74-14"></a><span class="op">};</span></span>
<span id="cb74-15"><a href="#cb74-15"></a><span class="dt">int</span> main<span class="op">()</span></span>
<span id="cb74-16"><a href="#cb74-16"></a><span class="op">{</span></span>
<span id="cb74-17"><a href="#cb74-17"></a>    A2 v<span class="op">;</span></span>
<span id="cb74-18"><a href="#cb74-18"></a>    v<span class="op">-&gt;</span>resize<span class="op">(</span><span class="dv">3</span><span class="op">);</span> <span class="co">// finds A0::operator-&gt;()</span></span>
<span id="cb74-19"><a href="#cb74-19"></a><span class="op">}</span></span></code></pre></div>
<p>Used for <a
href="https://quuxplusone.github.io/blog/2019/02/06/arrow-proxy/">arrow_proxy</a>.</p>
<h4 data-number="52" id="move-only-types-and-initializer_list"><span
class="header-section-number">52</span> move-only types and
initializer_list</h4>
<p>std::initializer_list with “uniform initialization” was introduced
together with move semantics in C++11. However, surprisingly,
initializer_list does not support move-only types like std::unique_ptr.
This does not compile:</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb75-1"><a href="#cb75-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> vs<span class="op">{</span></span>
<span id="cb75-2"><a href="#cb75-2"></a>    <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">2</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb75-3"><a href="#cb75-3"></a>    <span class="op">};</span></span></code></pre></div>
<p>The fix could be the use of temporary array in this case:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb76-1"><a href="#cb76-1"></a><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> temp<span class="op">[]{</span></span>
<span id="cb76-2"><a href="#cb76-2"></a>    <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">1</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">2</span><span class="op">),</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">3</span><span class="op">)</span></span>
<span id="cb76-3"><a href="#cb76-3"></a>    <span class="op">};</span></span>
<span id="cb76-4"><a href="#cb76-4"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>unique_ptr<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> vs<span class="op">{</span></span>
<span id="cb76-5"><a href="#cb76-5"></a>    <span class="bu">std::</span>make_move_iterator<span class="op">(</span><span class="bu">std::</span>begin<span class="op">(</span>temp<span class="op">)),</span></span>
<span id="cb76-6"><a href="#cb76-6"></a>    <span class="bu">std::</span>make_move_iterator<span class="op">(</span><span class="bu">std::</span>end<span class="op">(</span>temp<span class="op">))</span></span>
<span id="cb76-7"><a href="#cb76-7"></a>    <span class="op">};</span></span></code></pre></div>
<h4 data-number="53"
id="uniform-initialization-is-not-uniform-use-parentheses-vs"><span
class="header-section-number">53</span> uniform initialization is not
uniform, use parentheses (<code>()</code> vs <code>{}</code>)</h4>
<p>C++ initialization is famously complex. C++11 “uniform
initialization” with braces <code>{}</code> (list-initialization) is
famously non-uniform, see:</p>
<ul>
<li><a
href="https://medium.com/@barryrevzin/uniform-initialization-isnt-82533d3b9c11">Uniform
initialization isn’t</a>;</li>
<li><a
href="https://ianyepan.github.io/posts/cpp-uniform-initialization/">C++
Uniform Initialization - Benefits &amp; Pitfalls</a>;</li>
<li><a
href="https://quuxplusone.github.io/blog/2019/02/18/knightmare-of-initialization/">The
Knightmare of Initialization in C++</a>;</li>
<li>~300 pages book, <a
href="https://www.amazon.com/Initialization-Story-Through-Options-Related/dp/B0BW38DDBK">C++
Initialization Story</a>.</li>
</ul>
<p>Sometimes also called as <a
href="https://www.reddit.com/r/cpp/comments/as8pu1/comment/egslsok/">unicorn
initialization</a>; see also <a
href="https://x.com/timur_audio/status/1004017362381795329">Forrest Gump
C++ initialization</a>.</p>
<p>The best is to fall back to <code>()</code> with C++ 20 <a
href="https://wg21.link/p0960">Allow initializing aggregates from a
parenthesized list of values</a>:</p>
<div class="sourceCode" id="cb77"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb77-1"><a href="#cb77-1"></a><span class="kw">struct</span> A</span>
<span id="cb77-2"><a href="#cb77-2"></a><span class="op">{</span></span>
<span id="cb77-3"><a href="#cb77-3"></a>    <span class="dt">int</span> v1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-4"><a href="#cb77-4"></a>    <span class="dt">int</span> v2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb77-5"><a href="#cb77-5"></a><span class="op">};</span></span>
<span id="cb77-6"><a href="#cb77-6"></a></span>
<span id="cb77-7"><a href="#cb77-7"></a>A v<span class="op">(</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">);</span> <span class="co">// fine, C++20</span></span></code></pre></div>
<p>but also see <a
href="https://quuxplusone.github.io/blog/2022/06/03/aggregate-parens-init-considered-kinda-bad/">C++20’s
parenthesized aggregate initialization has some downsides</a>.</p>
<h4 data-number="54" id="move-only-lambda-and-stdfunction"><span
class="header-section-number">54</span> move-only lambda and
std::function</h4>
<p><code>std::function</code> was introduced together with move
semantics in C++11. However, surprisingly, std::function does not
support move-only lambda/function objects. This does not compile:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode numberSource cpp numberLines"><code class="sourceCode cpp"><span id="cb78-1"><a href="#cb78-1"></a><span class="bu">std::</span>function<span class="op">&lt;</span><span class="dt">void</span> <span class="op">()&gt;</span> f<span class="op">{[</span>x <span class="op">=</span> <span class="bu">std::</span>make_unique<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span><span class="dv">11</span><span class="op">)]()</span> <span class="op">{}};</span></span></code></pre></div>
<p>That’s one of the reasons C++23 <a
href="https://en.cppreference.com/w/cpp/utility/functional/move_only_function">std::move_only_function</a>
was introduced.</p>
<h4 data-number="55" id="stdfunction-issues"><span
class="header-section-number">55</span> std::function issues</h4>
<p>From <a href="https://wg21.link/n4159">std::functionand
Beyond</a>:</p>
<ul>
<li>Const-correctness and data races</li>
<li>Non-copyable function objects</li>
<li>Non-lvalue-callable function objects</li>
</ul>
<p>See also:</p>
<ul>
<li><a href="https://wg21.link/p2548">copyable_function</a> - C++26</li>
<li><a href="https://wg21.link/P0288">move_only_function</a> -
C++23</li>
<li><a href="https://wg21.link/P0792">function_ref</a> - C++26</li>
</ul>
</body>
</html>
